<html><head><style type="text/css">#data{display:none;}.deletion,.insertion,.change,.move,.move-change,.unchanged{border:solid 1px;}.deletion{border-color:#CC929A;background-color:LightPink;}.insertion{border-color:#73BE73;background-color:LightGreen;}.change{border-color:#8AADB8;background-color:LightBlue;cursor:pointer;}.move{border-color:LightPink;cursor:pointer;}.move-change{border-color:LightPink;background-color:LightBlue;cursor:pointer;}.unchanged{border-color:#A9A9A9;cursor:pointer;}span.keyword{font-weight:700;}div.src{width:48%;height:98%;overflow:scroll;border:1px solid;float:left;padding:.5%;}pre{line-height:200%;}p{line-height:200%;}</style><script>window.$=function(a){return document.getElementById(a)};var g=10,h=30,j=10,k=5,l="yellow",m="#FFFF66",n="",o="#FAF0E6",p={left:0,right:0},q=!1,r="leftstart",s="rightstart",t;function u(a){obj=$(a);var b=a=0;if(obj&&obj.offsetParent){a=obj.offsetLeft;for(b=obj.offsetTop;obj=obj.offsetParent;)a+=obj.offsetLeft,b+=obj.offsetTop}return{x:a,y:b}}function v(a,b,c){var d=a.scrollTop,e=a.scrollLeft;a.scrollTop+=c;a.scrollLeft+=b;e=a.scrollLeft-e;d=a.scrollTop-d;return Math.abs(b)>k&&e===0||Math.abs(c)>k&&d===0?(a.style.backgroundColor=o,!0):(p[a.id]+=1,a.style.backgroundColor=n,!1)}function w(a){for(;a&&a.tagName!=="DIV";)a=a.parentElement||a.parentNode;return a}function x(a,b,c){q=!0;var d=$(a),e=$(b),f=w(d),e=w(e),d=u(a).y-f.scrollTop,d=u(b).y-e.scrollTop-d,f=f.scrollLeft-e.scrollLeft;if(d===0&&f===0)clearTimeout(t),q=!1;else if(c<=1)v(e,f,d),q=!1;else{c=Math.floor(Math.abs(d)/c);actualMinStep=Math.min(g,Math.abs(d));var c=Math.abs(c)<g?actualMinStep*(d>0?1:d<0?-1:0):c*(d>0?1:d<0?-1:0),e=v(e,f,c),E=Math.floor(d/c)-1;e?(clearTimeout(t),q=!1):t=setTimeout(function(){return x(a,b,E)},j)}}var y=[];function z(a,b){var c=$(a);if(c!==null)c.style.backgroundColor=b,b!==n&&y.push(a)}function A(a){a=a||window.event;return a.target||a.srcElement}var B=["deletion","insertion","change","move","move-change","unchanged"],C=["deleted","inserted","change","same","same","same"];function D(a){if(typeof a==="string")this.appendChild(document.createTextNode(a));else if(typeof a==="object")if(a.i){var b=document.createElement("a"),c={tid:a.i,id:a.i+this.m,"class":B[a.c],title:C[a.c]},d;for(d in c)b.setAttribute(d,c[d]);b.innerHTML=a.s;this.appendChild(b);b.onmouseover=function(a){var a=A(a),b=a.id,c=a.getAttribute("tid");w(a).id==="left"?(r=b,s=c):(r=c,s=b);for(i=0;i<y.length;i+=1)z(y[i],n);y=[];z(b,l);z(c,l);z("ignore",m);z("ignore",m);x(b,c,h)}}else b=document.createElement("span"),b.setAttribute("class",B[a.c]),b.setAttribute("title",C[a.c]),b.innerHTML=a.s,this.appendChild(b);else throw"render data type err";}window.onload=function(){var a=JSON.parse($("data").innerText);$("leftstart").parentNode.m=-1;a.left.forEach(D,$("leftstart").parentNode);$("rightstart").parentNode.m=1;a.right.forEach(D,$("rightstart").parentNode);[$("left"),$("right")].forEach(function(a){a.onscroll=function(a){a=A(a);a.style.backgroundColor=n;!q&&p[a.id]===0&&(a.id==="left"?x(r,s,1):x(s,r,1));p[a.id]>0&&(p[a.id]-=1)}})};</script></head><body><div id="left" class="src"><pre><a id='leftstart' tid='rightstart'></a></pre></div><div id="right" class="src"><pre><a id='rightstart' tid='leftstart'></a></pre></div><div id="data">{"left":["\n","\n",{"c":0,"s":";;; -*- Mode: Emacs-Lisp; outline-regexp: \"\\n;;;;+\" -*-\n"},"\n",{"c":0,"s":";;;;;; Paredit: Parenthesis-Editing Minor Mode\n"},{"c":0,"s":";;;;;; Version 20\n"},"\n",{"c":0,"s":";;; This code is written by Taylor R. Campbell (except where explicitly\n"},{"c":0,"s":";;; noted) and placed in the Public Domain.  All warranties are\n"},{"c":0,"s":";;; disclaimed.\n"},"\n",{"c":0,"s":";;; Add this to your .emacs after adding paredit.el to /path/to/elisp/:\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;;   (add-to-list 'load-path \"/path/to/elisp/\")\n"},{"c":0,"s":";;;   (autoload 'paredit-mode \"paredit\"\n"},{"c":0,"s":";;;     \"Minor mode for pseudo-structurally editing Lisp code.\"\n"},{"c":0,"s":";;;     t)\n"},{"c":0,"s":";;;   (add-hook '...-mode-hook (lambda () (paredit-mode +1)))\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;; Usually the ... will be lisp or scheme or both.  Alternatively, you\n"},{"c":0,"s":";;; can manually toggle this mode with M-x paredit-mode.  Customization\n"},{"c":0,"s":";;; of paredit can be accomplished with `eval-after-load':\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;;   (eval-after-load 'paredit\n"},{"c":0,"s":";;;     '(progn ...redefine keys, &c....))\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;; This should run in GNU Emacs 21 or later and XEmacs 21.5 or later.\n"},{"c":0,"s":";;; It is highly unlikely to work in earlier versions of GNU Emacs, and\n"},{"c":0,"s":";;; it may have obscure problems in earlier versions of XEmacs due to\n"},{"c":0,"s":";;; the way its syntax parser reports conditions, as a result of which\n"},{"c":0,"s":";;; the code that uses the syntax parser must mask *all* error\n"},{"c":0,"s":";;; conditions, not just those generated by the syntax parser.\n"},"\n",{"c":0,"s":";;; This mode changes the keybindings for a number of simple keys,\n"},{"c":0,"s":";;; notably (, ), \", \\, and ;.  The bracket keys (round or square) are\n"},{"c":0,"s":";;; defined to insert parenthesis pairs and move past the close,\n"},{"c":0,"s":";;; respectively; the double-quote key is multiplexed to do both, and\n"},{"c":0,"s":";;; also insert an escape if within a string; backslashes prompt the\n"},{"c":0,"s":";;; user for the next character to input, because a lone backslash can\n"},{"c":0,"s":";;; break structure inadvertently; and semicolons ensure that they do\n"},{"c":0,"s":";;; not accidentally comment valid structure.  (Use M-; to comment an\n"},{"c":0,"s":";;; expression.)  These all have their ordinary behaviour when inside\n"},{"c":0,"s":";;; comments, and, outside comments, if truly necessary, you can insert\n"},{"c":0,"s":";;; them literally with C-q.\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;; These keybindings are set up for my preference.  One particular\n"},{"c":0,"s":";;; preference which I've seen vary greatly from person to person is\n"},{"c":0,"s":";;; whether the command to move past a closing delimiter ought to\n"},{"c":0,"s":";;; insert a newline.  Since I find this behaviour to be more common\n"},{"c":0,"s":";;; than that which inserts no newline, I have ) bound to it, and the\n"},{"c":0,"s":";;; more involved M-) to perform the less common action.  This bothers\n"},{"c":0,"s":";;; some users, though, and they prefer the other way around.  This\n"},{"c":0,"s":";;; code, which you can use `eval-after-load' to put in your .emacs,\n"},{"c":0,"s":";;; will exchange the bindings:\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;;   (define-key paredit-mode-map (kbd \")\")\n"},{"c":0,"s":";;;     'paredit-close-parenthesis)\n"},{"c":0,"s":";;;   (define-key paredit-mode-map (kbd \"M-)\")\n"},{"c":0,"s":";;;     'paredit-close-parenthesis-and-newline)\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;; Paredit also changes the bindings of keys for deleting and killing,\n"},{"c":0,"s":";;; so that they will not destroy any S-expression structure by killing\n"},{"c":0,"s":";;; or deleting only one side of a bracket or quote pair.  If the point\n"},{"c":0,"s":";;; is on a closing bracket, DEL will move left over it; if it is on an\n"},{"c":0,"s":";;; opening bracket, C-d will move right over it.  Only if the point is\n"},{"c":0,"s":";;; between a pair of brackets will C-d or DEL delete them, and in that\n"},{"c":0,"s":";;; case it will delete both simultaneously.  M-d and M-DEL kill words,\n"},{"c":0,"s":";;; but skip over any S-expression structure.  C-k kills from the start\n"},{"c":0,"s":";;; of the line, either to the line's end, if it contains only balanced\n"},{"c":0,"s":";;; expressions; to the first closing bracket, if the point is within a\n"},{"c":0,"s":";;; form that ends on the line; or up to the end of the last expression\n"},{"c":0,"s":";;; that starts on the line after the point.\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;; Automatic reindentation is performed as locally as possible, to\n"},{"c":0,"s":";;; ensure that Emacs does not interfere with custom indentation used\n"},{"c":0,"s":";;; elsewhere in some S-expression.  It is performed only by the\n"},{"c":0,"s":";;; advanced S-expression frobnication commands, and only on the forms\n"},{"c":0,"s":";;; that were immediately operated upon (& their subforms).\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;; This code is written for clarity, not efficiency.  S-expressions\n"},{"c":0,"s":";;; are frequently walked over redundantly.  If you have problems with\n"},{"c":0,"s":";;; some of the commands taking too long to execute, tell me, but first\n"},{"c":0,"s":";;; make sure that what you're doing is reasonable: it is stylistically\n"},{"c":0,"s":";;; bad to have huge, long, hideously nested code anyway.\n"},{"c":0,"s":";;;\n"},{"c":0,"s":";;; Questions, bug reports, comments, feature suggestions, &c., can be\n"},{"c":0,"s":";;; addressed to the author via mail on the host mumble.net to campbell\n"},{"c":0,"s":";;; or via IRC on irc.freenode.net in the #paredit channel under the\n"},{"c":0,"s":";;; nickname Riastradh.\n"},"\n",{"c":0,"s":";;; This assumes Unix-style LF line endings.\n"},"\n",{"c":0,"s":"(defconst paredit-version 20)"},"\n\n",{"c":0,"s":"(eval-and-compile\n\n  (defun paredit-xemacs-p ()\n    ;; No idea I got this definition from.  Edward O'Connor (hober on\n    ;; IRC) suggested the current definition.\n    ;;   (and (boundp 'running-xemacs)\n    ;;        running-xemacs)\n    (featurep 'xemacs))\n\n  (defun paredit-gnu-emacs-p ()\n    (not (paredit-xemacs-p)))\n\n  (defmacro xcond (&rest clauses)\n    \"Exhaustive COND.\nSignal an error if no clause matches.\"\n    `(cond ,@clauses\n           (t (error \"XCOND lost.\"))))\n\n  (defalias 'paredit-warn (if (fboundp 'warn) 'warn 'message))\n\n  (defvar paredit-sexp-error-type\n    (with-temp-buffer\n      (insert \"(\")\n      (condition-case condition\n          (backward-sexp)\n        (error (if (eq (car condition) 'error)\n                   (paredit-warn \"%s%s%s%s\"\n                                 \"Paredit is unable to discriminate\"\n                                 \" S-expression parse errors from\"\n                                 \" other errors. \"\n                                 \" This may cause obscure problems. \"\n                                 \" Please upgrade Emacs.\"))\n               (car condition)))))\n\n  (defmacro paredit-handle-sexp-errors (body &rest handler)\n    `(condition-case ()\n         ,body\n       (,paredit-sexp-error-type ,@handler)))\n\n  (put 'paredit-handle-sexp-errors 'lisp-indent-function 1)\n\n  (defmacro paredit-ignore-sexp-errors (&rest body)\n    `(paredit-handle-sexp-errors (progn ,@body)\n       nil))\n\n  (put 'paredit-ignore-sexp-errors 'lisp-indent-function 0)\n\n  nil)"},"\n\n",{"c":0,"s":";;;; Minor Mode Definition\n"},"\n(",{"c":5,"s":"defvar","i":1198}," ",{"c":5,"s":"paredit-mode-map","i":1200}," (",{"c":5,"s":"make-sparse-keymap","i":1202},")\n  ",{"c":5,"s":"\"Keymap for the paredit minor mode.\"","i":1204},")\n\n",{"c":0,"s":"(define-minor-mode paredit-mode\n  \"Minor mode for pseudo-structurally editing Lisp code.\n\\\\<paredit-mode-map>\"\n  :lighter \" Paredit\"\n  ;; If we're enabling paredit-mode, the prefix to this code that\n  ;; DEFINE-MINOR-MODE inserts will have already set PAREDIT-MODE to\n  ;; true.  If this is the case, then first check the parentheses, and\n  ;; if there are any imbalanced ones we must inhibit the activation of\n  ;; paredit mode.  We skip the check, though, if the user supplied a\n  ;; prefix argument interactively.\n  (if (and paredit-mode\n           (not current-prefix-arg))\n      (if (not (fboundp 'check-parens))\n          (paredit-warn \"`check-parens' is not defined; %s\"\n                        \"be careful of malformed S-expressions.\")\n          (condition-case condition\n              (check-parens)\n            (error (setq paredit-mode nil)\n                   (signal (car condition) (cdr condition)))))))"},"\n\n",{"c":0,"s":";;; Old functions from when there was a different mode for emacs -nw.\n"},"\n(",{"c":5,"s":"defun","i":1206}," ",{"c":5,"s":"enable-paredit-mode","i":1208}," ()\n  ",{"c":0,"s":"\"Turn on pseudo-structural editing of Lisp code.\n\nDeprecated: use `paredit-mode' instead.\""},"\n  (",{"c":5,"s":"interactive","i":1210},")\n  (",{"c":5,"s":"paredit-mode","i":1212}," ",{"c":5,"s":"+1","i":1214},"))\n\n(",{"c":5,"s":"defun","i":1216}," ",{"c":5,"s":"disable-paredit-mode","i":1218}," ()\n  ",{"c":0,"s":"\"Turn off pseudo-structural editing of Lisp code.\n\nDeprecated: use `paredit-mode' instead.\""},"\n  (",{"c":5,"s":"interactive","i":1220},")\n  (",{"c":5,"s":"paredit-mode","i":1222}," ",{"c":5,"s":"-1","i":1224},"))\n\n(",{"c":5,"s":"defvar","i":1226}," ",{"c":5,"s":"paredit-backward-delete-key","i":1228},"\n  (",{"c":5,"s":"xcond","i":1230}," ((",{"c":5,"s":"paredit-xemacs-p","i":1232},")    ",{"c":5,"s":"\"BS\"","i":1234},")\n         ((",{"c":5,"s":"paredit-gnu-emacs-p","i":1236},") ",{"c":5,"s":"\"DEL\"","i":1238},")))\n\n(",{"c":5,"s":"defvar","i":1240}," ",{"c":5,"s":"paredit-forward-delete-keys","i":1242},"\n  (",{"c":5,"s":"xcond","i":1244}," ((",{"c":5,"s":"paredit-xemacs-p","i":1246},")    ",{"c":5,"s":"'","i":1248},"(",{"c":5,"s":"\"DEL\"","i":1250},"))\n         ((",{"c":5,"s":"paredit-gnu-emacs-p","i":1252},") ",{"c":5,"s":"'","i":1254},"(",{"c":5,"s":"\"<delete>\"","i":1256}," ",{"c":5,"s":"\"<deletechar>\"","i":1258},"))))\n\n",{"c":5,"s":";;;; Paredit Keys\n","i":1260},"\n",{"c":5,"s":";;; Separating the definition and initialization of this variable\n","i":1262},{"c":5,"s":";;; simplifies the development of paredit, since re-evaluating DEFVAR\n","i":1264},{"c":5,"s":";;; forms doesn't actually do anything.\n","i":1266},"\n(",{"c":5,"s":"defvar","i":1268}," ",{"c":5,"s":"paredit-commands","i":1270}," ",{"c":5,"s":"nil","i":1272},"\n  ",{"c":5,"s":"\"List of paredit commands with their keys and examples.\"","i":1274},")\n\n",{"c":5,"s":";;; Each specifier is of the form:\n","i":1276},{"c":5,"s":";;;   (key[s] function (example-input example-output) ...)\n","i":1278},{"c":5,"s":";;; where key[s] is either a single string suitable for passing to KBD\n","i":1280},{"c":5,"s":";;; or a list of such strings.  Entries in this list may also just be\n","i":1282},{"c":5,"s":";;; strings, in which case they are headings for the next entries.\n","i":1284},"\n(",{"c":3,"s":"progn","i":556}," (",{"c":3,"s":"setq","i":558}," ",{"c":3,"s":"paredit-commands","i":560},"\n ",{"c":3,"s":"`","i":562},"(\n   ",{"c":0,"s":"\"Basic Insertion Commands\""},"\n   ",{"c":0,"s":"(\"(\"         paredit-open-parenthesis\n                (\"(a b |c d)\"\n                 \"(a b (|) c d)\")\n                (\"(foo \\\"bar |baz\\\" quux)\"\n                 \"(foo \\\"bar (|baz\\\" quux)\"))"},"\n   ",{"c":0,"s":"(\")\"         paredit-close-parenthesis-and-newline\n                (\"(defun f (x|  ))\"\n                 \"(defun f (x)\\n  |)\")\n                (\"; (Foo.|\"\n                 \"; (Foo.)|\"))"},"\n   ",{"c":0,"s":"(\"M-)\"       paredit-close-parenthesis\n                (\"(a b |c   )\" \"(a b c)|\")\n                (\"; Hello,| world!\"\n                 \"; Hello,)| world!\"))"},"\n   ",{"c":0,"s":"(\"[\"         paredit-open-bracket\n                (\"(a b |c d)\"\n                 \"(a b [|] c d)\")\n                (\"(foo \\\"bar |baz\\\" quux)\"\n                 \"(foo \\\"bar [baz\\\" quux)\"))"},"\n   ",{"c":0,"s":"(\"]\"         paredit-close-bracket\n                (\"(define-key keymap [frob|  ] 'frobnicate)\"\n                 \"(define-key keymap [frob]| 'frobnicate)\")\n                (\"; [Bar.|\"\n                 \"; [Bar.]|\"))"},"\n   (",{"c":3,"s":"\"\\\"\"","i":564},"        ",{"c":3,"s":"paredit-doublequote","i":566},"\n                (",{"c":3,"s":"\"(frob grovel |full lexical)\"","i":568},"\n                 ",{"c":3,"s":"\"(frob grovel \\\"|\\\" full lexical)\"","i":570},")\n                (",{"c":3,"s":"\"(foo \\\"bar |baz\\\" quux)\"","i":572},"\n                 ",{"c":3,"s":"\"(foo \\\"bar \\\\\\\"|baz\\\" quux)\"","i":574},"))\n   (",{"c":3,"s":"\"M-\\\"\"","i":478},"      ",{"c":3,"s":"paredit-meta-doublequote","i":480},"\n                (",{"c":3,"s":"\"(foo \\\"bar |baz\\\" quux)\"","i":482},"\n                 ",{"c":3,"s":"\"(foo \\\"bar baz\\\"\\n     |quux)\"","i":484},")\n                (",{"c":3,"s":"\"(foo |(bar #\\\\x \\\"baz \\\\\\\\ quux\\\") zot)\"","i":486},"\n                 ",{"c":3,"s":",","i":488},"(",{"c":3,"s":"concat","i":490}," ",{"c":3,"s":"\"(foo \\\"|(bar #\\\\\\\\x \\\\\\\"baz \\\\\\\\\"","i":492},"\n                          ",{"c":3,"s":"\"\\\\\\\\ quux\\\\\\\")\\\" zot)\"","i":494},")))\n   (",{"c":3,"s":"\"\\\\\"","i":376},"        ",{"c":3,"s":"paredit-backslash","i":378},"\n                (",{"c":3,"s":"\"(string #|)\\n  ; Escaping character... (x)\"","i":380},"\n                 ",{"c":3,"s":"\"(string #\\\\x|)\"","i":382},")\n                (",{"c":3,"s":"\"\\\"foo|bar\\\"\\n  ; Escaping character... (\\\")\"","i":384},"\n                 ",{"c":3,"s":"\"\\\"foo\\\\\\\"|bar\\\"\"","i":386},"))\n   ",{"c":0,"s":"(\";\"         paredit-semicolon\n                (\"|(frob grovel)\"\n                 \";|\\n(frob grovel)\")\n                (\"(frob grovel)    |\"\n                 \"(frob grovel)    ;|\"))"},"\n   (",{"c":3,"s":"\"M-;\"","i":288},"       ",{"c":3,"s":"paredit-comment-dwim","i":290},"\n                (",{"c":3,"s":"\"(foo |bar)   ; baz\"","i":292},"\n                 ",{"c":3,"s":"\"(foo bar)                               ; |baz\"","i":294},")\n                (",{"c":3,"s":"\"(frob grovel)|\"","i":296},"\n                 ",{"c":3,"s":"\"(frob grovel)                           ;|\"","i":298},")\n                (",{"c":3,"s":"\"    (foo bar)\\n|\\n    (baz quux)\"","i":300},"\n                 ",{"c":3,"s":"\"    (foo bar)\\n    ;; |\\n    (baz quux)\"","i":302},")\n                (",{"c":3,"s":"\"    (foo bar) |(baz quux)\"","i":304},"\n                 ",{"c":3,"s":"\"    (foo bar)\\n    ;; |\\n    (baz quux)\"","i":306},")\n                (",{"c":3,"s":"\"|(defun hello-world ...)\"","i":308},"\n                 ",{"c":3,"s":"\";;; |\\n(defun hello-world ...)\"","i":310},"))\n\n   (",{"c":3,"s":"\"C-j\"","i":244},"       ",{"c":3,"s":"paredit-newline","i":246},"\n                (",{"c":3,"s":"\"(let ((n (frobbotz))) |(display (+ n 1)\\nport))\"","i":248},"\n                 ",{"c":3,"s":",","i":250},"(",{"c":3,"s":"concat","i":252}," ",{"c":3,"s":"\"(let ((n (frobbotz)))\"","i":254},"\n                          ",{"c":3,"s":"\"\\n  |(display (+ n 1)\"","i":256},"\n                          ",{"c":3,"s":"\"\\n            port))\"","i":258},")))\n\n   ",{"c":0,"s":"\"Deleting & Killing\""},"\n   ((",{"c":3,"s":"\"C-d\"","i":218}," ",{"c":3,"s":",","i":220},{"c":3,"s":"@paredit-forward-delete-keys","i":222},")\n                ",{"c":3,"s":"paredit-forward-delete","i":224},"\n                (",{"c":3,"s":"\"(quu|x \\\"zot\\\")\"","i":226}," ",{"c":3,"s":"\"(quu| \\\"zot\\\")\"","i":228},")\n                (",{"c":3,"s":"\"(quux |\\\"zot\\\")\"","i":230},"\n                 ",{"c":3,"s":"\"(quux \\\"|zot\\\")\"","i":232},"\n                 ",{"c":3,"s":"\"(quux \\\"|ot\\\")\"","i":234},")\n                (",{"c":3,"s":"\"(foo (|) bar)\"","i":236}," ",{"c":3,"s":"\"(foo | bar)\"","i":238},")\n                (",{"c":3,"s":"\"|(foo bar)\"","i":240}," ",{"c":3,"s":"\"(|foo bar)\"","i":242},"))\n   (",{"c":3,"s":",","i":194},{"c":3,"s":"paredit-backward-delete-key","i":196},"\n                ",{"c":3,"s":"paredit-backward-delete","i":198},"\n                (",{"c":3,"s":"\"(\\\"zot\\\" q|uux)\"","i":200}," ",{"c":3,"s":"\"(\\\"zot\\\" |uux)\"","i":202},")\n                (",{"c":3,"s":"\"(\\\"zot\\\"| quux)\"","i":204},"\n                 ",{"c":3,"s":"\"(\\\"zot|\\\" quux)\"","i":206},"\n                 ",{"c":3,"s":"\"(\\\"zo|\\\" quux)\"","i":208},")\n                (",{"c":3,"s":"\"(foo (|) bar)\"","i":210}," ",{"c":3,"s":"\"(foo | bar)\"","i":212},")\n                (",{"c":3,"s":"\"(foo bar)|\"","i":214}," ",{"c":3,"s":"\"(foo bar|)\"","i":216},"))\n   (",{"c":3,"s":"\"C-k\"","i":174},"       ",{"c":3,"s":"paredit-kill","i":176},"\n                (",{"c":3,"s":"\"(foo bar)|     ; Useless comment!\"","i":178},"\n                 ",{"c":3,"s":"\"(foo bar)|\"","i":180},")\n                (",{"c":3,"s":"\"(|foo bar)     ; Useful comment!\"","i":182},"\n                 ",{"c":3,"s":"\"(|)     ; Useful comment!\"","i":184},")\n                (",{"c":3,"s":"\"|(foo bar)     ; Useless line!\"","i":186},"\n                 ",{"c":3,"s":"\"|\"","i":188},")\n                (",{"c":3,"s":"\"(foo \\\"|bar baz\\\"\\n     quux)\"","i":190},"\n                 ",{"c":3,"s":"\"(foo \\\"|\\\"\\n     quux)\"","i":192},"))\n   (",{"c":3,"s":"\"M-d\"","i":156},"       ",{"c":3,"s":"paredit-forward-kill-word","i":158},"\n                (",{"c":3,"s":"\"|(foo bar)    ; baz\"","i":160},"\n                 ",{"c":3,"s":"\"(| bar)    ; baz\"","i":162},"\n                 ",{"c":3,"s":"\"(|)    ; baz\"","i":164},"\n                 ",{"c":3,"s":"\"()    ;|\"","i":166},")\n                (",{"c":3,"s":"\";;;| Frobnicate\\n(defun frobnicate ...)\"","i":168},"\n                 ",{"c":3,"s":"\";;;|\\n(defun frobnicate ...)\"","i":170},"\n                 ",{"c":3,"s":"\";;;\\n(| frobnicate ...)\"","i":172},"))\n   (",{"c":3,"s":",","i":136},"(",{"c":3,"s":"concat","i":138}," ",{"c":3,"s":"\"M-\"","i":140}," ",{"c":3,"s":"paredit-backward-delete-key","i":142},")\n                ",{"c":3,"s":"paredit-backward-kill-word","i":144},"\n                (",{"c":3,"s":"\"(foo bar)    ; baz\\n(quux)|\"","i":146},"\n                 ",{"c":3,"s":"\"(foo bar)    ; baz\\n(|)\"","i":148},"\n                 ",{"c":3,"s":"\"(foo bar)    ; |\\n()\"","i":150},"\n                 ",{"c":3,"s":"\"(foo |)    ; \\n()\"","i":152},"\n                 ",{"c":3,"s":"\"(|)    ; \\n()\"","i":154},"))\n\n   ",{"c":0,"s":"\"Movement & Navigation\""},"\n   (",{"c":3,"s":"\"C-M-f\"","i":124},"     ",{"c":3,"s":"paredit-forward","i":126},"\n                (",{"c":3,"s":"\"(foo |(bar baz) quux)\"","i":128},"\n                 ",{"c":3,"s":"\"(foo (bar baz)| quux)\"","i":130},")\n                (",{"c":3,"s":"\"(foo (bar)|)\"","i":132},"\n                 ",{"c":3,"s":"\"(foo (bar))|\"","i":134},"))\n   (",{"c":3,"s":"\"C-M-b\"","i":112},"     ",{"c":3,"s":"paredit-backward","i":114},"\n                (",{"c":3,"s":"\"(foo (bar baz)| quux)\"","i":116},"\n                 ",{"c":3,"s":"\"(foo |(bar baz) quux)\"","i":118},")\n                (",{"c":3,"s":"\"(|(foo) bar)\"","i":120},"\n                 ",{"c":3,"s":"\"|((foo) bar)\"","i":122},"))\n",{"c":0,"s":";;;(\"C-M-u\"     backward-up-list)       ; These two are built-in.\n"},{"c":0,"s":";;;(\"C-M-d\"     down-list)\n"},"   ",{"c":0,"s":"(\"C-M-p\"     backward-down-list)"},"     ",{"c":0,"s":"; Built-in, these are FORWARD-\n"},"   ",{"c":0,"s":"(\"C-M-n\"     up-list)"},"                ",{"c":0,"s":"; & BACKWARD-LIST, which have\n"},"                                        ",{"c":0,"s":"; no need given C-M-f & C-M-b.\n"},"\n   ",{"c":0,"s":"\"Depth-Changing Commands\""},"\n   ",{"c":0,"s":"(\"M-(\"       paredit-wrap-sexp\n                (\"(foo |bar baz)\"\n                 \"(foo (|bar) baz)\"))"},"\n   ",{"c":0,"s":"(\"M-s\"       paredit-splice-sexp\n                (\"(foo (bar| baz) quux)\"\n                 \"(foo bar| baz quux)\"))"},"\n   ((",{"c":3,"s":"\"M-<up>\"","i":102}," ",{"c":3,"s":"\"ESC <up>\"","i":104},")\n                ",{"c":3,"s":"paredit-splice-sexp-killing-backward","i":106},"\n                (",{"c":3,"s":"\"(foo (let ((x 5)) |(sqrt n)) bar)\"","i":108},"\n                 ",{"c":3,"s":"\"(foo (sqrt n) bar)\"","i":110},"))\n   ((",{"c":3,"s":"\"M-<down>\"","i":92}," ",{"c":3,"s":"\"ESC <down>\"","i":94},")\n                ",{"c":3,"s":"paredit-splice-sexp-killing-forward","i":96},"\n                (",{"c":3,"s":"\"(a (b c| d e) f)\"","i":98},"\n                 ",{"c":3,"s":"\"(a b c f)\"","i":100},"))\n   (",{"c":3,"s":"\"M-r\"","i":82},"       ",{"c":3,"s":"paredit-raise-sexp","i":84},"\n                (",{"c":3,"s":"\"(dynamic-wind in (lambda () |body) out)\"","i":86},"\n                 ",{"c":3,"s":"\"(dynamic-wind in |body out)\"","i":88},"\n                 ",{"c":3,"s":"\"|body\"","i":90},"))\n\n   ",{"c":0,"s":"\"Barfage & Slurpage\""},"\n   ((",{"c":3,"s":"\"C-)\"","i":68}," ",{"c":3,"s":"\"C-<right>\"","i":70},")\n                ",{"c":3,"s":"paredit-forward-slurp-sexp","i":72},"\n                (",{"c":3,"s":"\"(foo (bar |baz) quux zot)\"","i":74},"\n                 ",{"c":3,"s":"\"(foo (bar |baz quux) zot)\"","i":76},")\n                (",{"c":3,"s":"\"(a b ((c| d)) e f)\"","i":78},"\n                 ",{"c":3,"s":"\"(a b ((c| d) e) f)\"","i":80},"))\n   ((",{"c":3,"s":"\"C-}\"","i":58}," ",{"c":3,"s":"\"C-<left>\"","i":60},")\n                ",{"c":3,"s":"paredit-forward-barf-sexp","i":62},"\n                (",{"c":3,"s":"\"(foo (bar |baz quux) zot)\"","i":64},"\n                 ",{"c":3,"s":"\"(foo (bar |baz) quux zot)\"","i":66},"))\n   ((",{"c":3,"s":"\"C-(\"","i":42}," ",{"c":3,"s":"\"C-M-<left>\"","i":44}," ",{"c":3,"s":"\"ESC C-<left>\"","i":46},")\n                ",{"c":3,"s":"paredit-backward-slurp-sexp","i":48},"\n                (",{"c":3,"s":"\"(foo bar (baz| quux) zot)\"","i":50},"\n                 ",{"c":3,"s":"\"(foo (bar baz| quux) zot)\"","i":52},")\n                (",{"c":3,"s":"\"(a b ((c| d)) e f)\"","i":54},"\n                 ",{"c":3,"s":"\"(a (b (c| d)) e f)\"","i":56},"))\n   ((",{"c":3,"s":"\"C-{\"","i":30}," ",{"c":3,"s":"\"C-M-<right>\"","i":32}," ",{"c":3,"s":"\"ESC C-<right>\"","i":34},")\n                ",{"c":3,"s":"paredit-backward-barf-sexp","i":36},"\n                (",{"c":3,"s":"\"(foo (bar baz |quux) zot)\"","i":38},"\n                 ",{"c":3,"s":"\"(foo bar (baz |quux) zot)\"","i":40},"))\n\n   ",{"c":0,"s":"\"Miscellaneous Commands\""},"\n   (",{"c":3,"s":"\"M-S\"","i":18},"       ",{"c":3,"s":"paredit-split-sexp","i":20},"\n                (",{"c":3,"s":"\"(hello| world)\"","i":22},"\n                 ",{"c":3,"s":"\"(hello)| (world)\"","i":24},")\n                (",{"c":3,"s":"\"\\\"Hello, |world!\\\"\"","i":26},"\n                 ",{"c":3,"s":"\"\\\"Hello, \\\"| \\\"world!\\\"\"","i":28},"))\n   (",{"c":3,"s":"\"M-J\"","i":2},"       ",{"c":3,"s":"paredit-join-sexps","i":4},"\n                (",{"c":3,"s":"\"(hello)| (world)\"","i":6},"\n                 ",{"c":3,"s":"\"(hello| world)\"","i":8},")\n                (",{"c":3,"s":"\"\\\"Hello, \\\"| \\\"world!\\\"\"","i":10},"\n                 ",{"c":3,"s":"\"\\\"Hello, |world!\\\"\"","i":12},")\n                (",{"c":3,"s":"\"hello-\\n|  world\"","i":14},"\n                 ",{"c":3,"s":"\"hello-|world\"","i":16},"))\n   ",{"c":0,"s":"(\"C-c C-M-l\" paredit-recentre-on-sexp)"},"\n   ))\n       ",{"c":3,"s":"nil","i":576},")                             ",{"c":0,"s":"; end of PROGN\n"},"\n",{"c":0,"s":";;;;; Command Examples\n"},"\n(",{"c":5,"s":"eval-and-compile","i":1286},"\n  (",{"c":5,"s":"defmacro","i":1288}," ",{"c":5,"s":"paredit-do-commands","i":1290}," (",{"c":5,"s":"vars","i":1292}," ",{"c":5,"s":"string-case","i":1294}," ",{"c":5,"s":"&rest","i":1296}," ",{"c":5,"s":"body","i":1298},")\n    (",{"c":5,"s":"let","i":1300}," ((",{"c":5,"s":"spec","i":1302},"     (",{"c":5,"s":"nth","i":1304}," ",{"c":5,"s":"0","i":1306}," ",{"c":5,"s":"vars","i":1308},"))\n          (",{"c":5,"s":"keys","i":1310},"     (",{"c":5,"s":"nth","i":1312}," ",{"c":5,"s":"1","i":1314}," ",{"c":5,"s":"vars","i":1316},"))\n          (",{"c":5,"s":"fn","i":1318},"       (",{"c":5,"s":"nth","i":1320}," ",{"c":5,"s":"2","i":1322}," ",{"c":5,"s":"vars","i":1324},"))\n          (",{"c":5,"s":"examples","i":1326}," (",{"c":5,"s":"nth","i":1328}," ",{"c":5,"s":"3","i":1330}," ",{"c":5,"s":"vars","i":1332},")))\n      ",{"c":5,"s":"`","i":1334},"(",{"c":5,"s":"dolist","i":1336}," (",{"c":5,"s":",","i":1338},{"c":5,"s":"spec","i":1340}," ",{"c":5,"s":"paredit-commands","i":1342},")\n         (",{"c":5,"s":"if","i":1344}," (",{"c":5,"s":"stringp","i":1346}," ",{"c":5,"s":",","i":1348},{"c":5,"s":"spec","i":1350},")\n             ",{"c":5,"s":",","i":1352},{"c":5,"s":"string-case","i":1354},"\n           (",{"c":5,"s":"let","i":1356}," ((",{"c":5,"s":",","i":1358},{"c":5,"s":"keys","i":1360}," (",{"c":5,"s":"let","i":1362}," ((",{"c":5,"s":"k","i":1364}," (",{"c":5,"s":"car","i":1366}," ",{"c":5,"s":",","i":1368},{"c":5,"s":"spec","i":1370},")))\n                          (",{"c":5,"s":"cond","i":1372}," ((",{"c":5,"s":"stringp","i":1374}," ",{"c":5,"s":"k","i":1376},") (",{"c":5,"s":"list","i":1378}," ",{"c":5,"s":"k","i":1380},"))\n                                ((",{"c":5,"s":"listp","i":1382}," ",{"c":5,"s":"k","i":1384},") ",{"c":5,"s":"k","i":1386},")\n                                (",{"c":5,"s":"t","i":1388}," (",{"c":5,"s":"error","i":1390}," ",{"c":5,"s":"\"Invalid paredit command %s.\"","i":1392},"\n                                          ",{"c":5,"s":",","i":1394},{"c":5,"s":"spec","i":1396},")))))\n                 (",{"c":5,"s":",","i":1398},{"c":5,"s":"fn","i":1400}," (",{"c":5,"s":"cadr","i":1402}," ",{"c":5,"s":",","i":1404},{"c":5,"s":"spec","i":1406},"))\n                 (",{"c":5,"s":",","i":1408},{"c":5,"s":"examples","i":1410}," (",{"c":5,"s":"cddr","i":1412}," ",{"c":5,"s":",","i":1414},{"c":5,"s":"spec","i":1416},")))\n             ",{"c":5,"s":",","i":1418},{"c":5,"s":"@body","i":1420},")))))\n\n  (",{"c":5,"s":"put","i":1422}," ",{"c":5,"s":"'","i":1424},{"c":5,"s":"paredit-do-commands","i":1426}," ",{"c":5,"s":"'","i":1428},{"c":5,"s":"lisp-indent-function","i":1430}," ",{"c":5,"s":"2","i":1432},"))\n\n(",{"c":5,"s":"defun","i":1434}," ",{"c":5,"s":"paredit-define-keys","i":1436}," ()\n  (",{"c":5,"s":"paredit-do-commands","i":1438}," (",{"c":5,"s":"spec","i":1440}," ",{"c":5,"s":"keys","i":1442}," ",{"c":5,"s":"fn","i":1444}," ",{"c":5,"s":"examples","i":1446},")\n      ",{"c":5,"s":"nil","i":1448},"       ",{"c":5,"s":"; string case\n","i":1450},"    (",{"c":5,"s":"dolist","i":1452}," (",{"c":5,"s":"key","i":1454}," ",{"c":5,"s":"keys","i":1456},")\n      (",{"c":5,"s":"define-key","i":1458}," ",{"c":5,"s":"paredit-mode-map","i":1460}," (",{"c":5,"s":"read-kbd-macro","i":1462}," ",{"c":5,"s":"key","i":1464},") ",{"c":5,"s":"fn","i":1466},"))))\n\n(",{"c":5,"s":"defun","i":1468}," ",{"c":5,"s":"paredit-function-documentation","i":1470}," (",{"c":5,"s":"fn","i":1472},")\n  (",{"c":5,"s":"let","i":1474}," ((",{"c":5,"s":"original-doc","i":1476}," (",{"c":5,"s":"get","i":1478}," ",{"c":5,"s":"fn","i":1480}," ",{"c":5,"s":"'","i":1482},{"c":5,"s":"paredit-original-documentation","i":1484},"))\n        (",{"c":5,"s":"doc","i":1486}," (",{"c":5,"s":"documentation","i":1488}," ",{"c":5,"s":"fn","i":1490}," ",{"c":5,"s":"'","i":1492},{"c":5,"s":"function-documentation","i":1494},")))\n    (",{"c":5,"s":"or","i":1496}," ",{"c":5,"s":"original-doc","i":1498},"\n        (",{"c":5,"s":"progn","i":1500}," (",{"c":5,"s":"put","i":1502}," ",{"c":5,"s":"fn","i":1504}," ",{"c":5,"s":"'","i":1506},{"c":5,"s":"paredit-original-documentation","i":1508}," ",{"c":5,"s":"doc","i":1510},")\n               ",{"c":5,"s":"doc","i":1512},"))))\n\n(",{"c":5,"s":"defun","i":1514}," ",{"c":5,"s":"paredit-annotate-mode-with-examples","i":1516}," ()\n  (",{"c":5,"s":"let","i":1518}," ((",{"c":5,"s":"contents","i":1520},"\n         (",{"c":5,"s":"list","i":1522}," (",{"c":5,"s":"paredit-function-documentation","i":1524}," ",{"c":5,"s":"'","i":1526},{"c":5,"s":"paredit-mode","i":1528},"))))\n    (",{"c":5,"s":"paredit-do-commands","i":1530}," (",{"c":5,"s":"spec","i":1532}," ",{"c":5,"s":"keys","i":1534}," ",{"c":5,"s":"fn","i":1536}," ",{"c":5,"s":"examples","i":1538},")\n        (",{"c":5,"s":"push","i":1540}," (",{"c":5,"s":"concat","i":1542}," ",{"c":5,"s":"\"\\n\\n\"","i":1544}," ",{"c":5,"s":"spec","i":1546}," ",{"c":5,"s":"\"\\n\"","i":1548},")\n              ",{"c":5,"s":"contents","i":1550},")\n      (",{"c":5,"s":"let","i":1552}," ((",{"c":5,"s":"name","i":1554}," (",{"c":5,"s":"symbol-name","i":1556}," ",{"c":5,"s":"fn","i":1558},")))\n        (",{"c":5,"s":"if","i":1560}," (",{"c":5,"s":"string-match","i":1562}," (",{"c":5,"s":"symbol-name","i":1564}," ",{"c":5,"s":"'","i":1566},{"c":5,"s":"paredit-","i":1568},") ",{"c":5,"s":"name","i":1570},")\n            (",{"c":5,"s":"push","i":1572}," (",{"c":5,"s":"concat","i":1574}," ",{"c":5,"s":"\"\\n\\n\\\\[\"","i":1576}," ",{"c":5,"s":"name","i":1578}," ",{"c":5,"s":"\"]\\t\"","i":1580}," ",{"c":5,"s":"name","i":1582},"\n                          (",{"c":5,"s":"if","i":1584}," ",{"c":5,"s":"examples","i":1586},"\n                              (",{"c":5,"s":"mapconcat","i":1588}," (",{"c":5,"s":"lambda","i":1590}," (",{"c":5,"s":"example","i":1592},")\n                                           (",{"c":5,"s":"concat","i":1594},"\n                                            ",{"c":5,"s":"\"\\n\"","i":1596},"\n                                            (",{"c":5,"s":"mapconcat","i":1598}," ",{"c":5,"s":"'","i":1600},{"c":5,"s":"identity","i":1602},"\n                                                       ",{"c":5,"s":"example","i":1604},"\n                                                       ",{"c":5,"s":"\"\\n  --->\\n\"","i":1606},")\n                                            ",{"c":5,"s":"\"\\n\"","i":1608},"))\n                                         ",{"c":5,"s":"examples","i":1610},"\n                                         ",{"c":5,"s":"\"\"","i":1612},")\n                              ",{"c":5,"s":"\"\\n  (no examples)\\n\"","i":1614},"))\n                  ",{"c":5,"s":"contents","i":1616},"))))\n    (",{"c":5,"s":"put","i":1618}," ",{"c":5,"s":"'","i":1620},{"c":5,"s":"paredit-mode","i":1622}," ",{"c":5,"s":"'","i":1624},{"c":5,"s":"function-documentation","i":1626},"\n         (",{"c":5,"s":"apply","i":1628}," ",{"c":5,"s":"'","i":1630},{"c":5,"s":"concat","i":1632}," (",{"c":5,"s":"reverse","i":1634}," ",{"c":5,"s":"contents","i":1636},"))))\n  ",{"c":5,"s":";; PUT returns the huge string we just constructed, which we don't\n","i":1638},"  ",{"c":5,"s":";; want it to return.\n","i":1640},"  ",{"c":5,"s":"nil","i":1642},")\n\n(",{"c":5,"s":"defun","i":1644}," ",{"c":5,"s":"paredit-annotate-functions-with-examples","i":1646}," ()\n  (",{"c":5,"s":"paredit-do-commands","i":1648}," (",{"c":5,"s":"spec","i":1650}," ",{"c":5,"s":"keys","i":1652}," ",{"c":5,"s":"fn","i":1654}," ",{"c":5,"s":"examples","i":1656},")\n      ",{"c":5,"s":"nil","i":1658},"       ",{"c":5,"s":"; string case\n","i":1660},"    (",{"c":5,"s":"put","i":1662}," ",{"c":5,"s":"fn","i":1664}," ",{"c":5,"s":"'","i":1666},{"c":5,"s":"function-documentation","i":1668},"\n         (",{"c":5,"s":"concat","i":1670}," (",{"c":5,"s":"paredit-function-documentation","i":1672}," ",{"c":5,"s":"fn","i":1674},")\n                 ",{"c":5,"s":"\"\\n\\n\\\\<paredit-mode-map>\\\\[\"","i":1676}," (",{"c":5,"s":"symbol-name","i":1678}," ",{"c":5,"s":"fn","i":1680},") ",{"c":5,"s":"\"]\\n\"","i":1682},"\n                 (",{"c":5,"s":"mapconcat","i":1684}," (",{"c":5,"s":"lambda","i":1686}," (",{"c":5,"s":"example","i":1688},")\n                              (",{"c":5,"s":"concat","i":1690}," ",{"c":5,"s":"\"\\n\"","i":1692},"\n                                      (",{"c":5,"s":"mapconcat","i":1694}," ",{"c":5,"s":"'","i":1696},{"c":5,"s":"identity","i":1698},"\n                                                 ",{"c":5,"s":"example","i":1700},"\n                                                 ",{"c":5,"s":"\"\\n  ->\\n\"","i":1702},")\n                                      ",{"c":5,"s":"\"\\n\"","i":1704},"))\n                            ",{"c":5,"s":"examples","i":1706},"\n                            ",{"c":5,"s":"\"\"","i":1708},")))))\n\n",{"c":5,"s":";;;;; HTML Examples\n","i":1710},"\n(",{"c":5,"s":"defun","i":1712}," ",{"c":5,"s":"paredit-insert-html-examples","i":1714}," ()\n  ",{"c":5,"s":"\"Insert HTML for a paredit quick reference table.\"","i":1716},"\n  (",{"c":5,"s":"interactive","i":1718},")\n  (",{"c":5,"s":"let","i":1720}," ((",{"c":5,"s":"insert-lines","i":1722}," (",{"c":5,"s":"lambda","i":1724}," (",{"c":5,"s":"&rest","i":1726}," ",{"c":5,"s":"lines","i":1728},")\n                        (",{"c":5,"s":"mapc","i":1730}," (",{"c":5,"s":"lambda","i":1732}," (",{"c":5,"s":"line","i":1734},") (",{"c":5,"s":"insert","i":1736}," ",{"c":5,"s":"line","i":1738},") (",{"c":5,"s":"newline","i":1740},"))\n                              ",{"c":5,"s":"lines","i":1742},")))\n        (",{"c":5,"s":"html-keys","i":1744}," (",{"c":5,"s":"lambda","i":1746}," (",{"c":5,"s":"keys","i":1748},")\n                     (",{"c":5,"s":"mapconcat","i":1750}," ",{"c":5,"s":"'","i":1752},{"c":5,"s":"paredit-html-quote","i":1754}," ",{"c":5,"s":"keys","i":1756}," ",{"c":5,"s":"\", \"","i":1758},")))\n        (",{"c":5,"s":"html-example","i":1760},"\n         (",{"c":5,"s":"lambda","i":1762}," (",{"c":5,"s":"example","i":1764},")\n           (",{"c":5,"s":"concat","i":1766}," ",{"c":5,"s":"\"<table><tr><td><pre>\"","i":1768},"\n                   (",{"c":5,"s":"mapconcat","i":1770}," ",{"c":5,"s":"'","i":1772},{"c":5,"s":"paredit-html-quote","i":1774},"\n                              ",{"c":5,"s":"example","i":1776},"\n                              (",{"c":5,"s":"concat","i":1778}," ",{"c":5,"s":"\"</pre></td></tr><tr><td>\"","i":1780},"\n                                      ",{"c":5,"s":"\"    --->\"","i":1782},"\n                                      ",{"c":5,"s":"\"</td></tr><tr><td><pre>\"","i":1784},"))\n                   ",{"c":5,"s":"\"</pre></td></tr></table>\"","i":1786},")))\n        (",{"c":5,"s":"firstp","i":1788}," ",{"c":5,"s":"t","i":1790},"))\n    (",{"c":5,"s":"paredit-do-commands","i":1792}," (",{"c":5,"s":"spec","i":1794}," ",{"c":5,"s":"keys","i":1796}," ",{"c":5,"s":"fn","i":1798}," ",{"c":5,"s":"examples","i":1800},")\n        (",{"c":5,"s":"progn","i":1802}," (",{"c":5,"s":"if","i":1804}," (",{"c":5,"s":"not","i":1806}," ",{"c":5,"s":"firstp","i":1808},")\n                   (",{"c":5,"s":"insert","i":1810}," ",{"c":5,"s":"\"</table>\\n\"","i":1812},")\n                   (",{"c":5,"s":"setq","i":1814}," ",{"c":5,"s":"firstp","i":1816}," ",{"c":5,"s":"nil","i":1818},"))\n               (",{"c":5,"s":"funcall","i":1820}," ",{"c":5,"s":"insert-lines","i":1822},"\n                        (",{"c":5,"s":"concat","i":1824}," ",{"c":5,"s":"\"<h3>\"","i":1826}," ",{"c":5,"s":"spec","i":1828}," ",{"c":5,"s":"\"</h3>\"","i":1830},")\n                        ",{"c":5,"s":"\"<table border=\\\"1\\\" cellpadding=\\\"1\\\">\"","i":1832},"\n                        ",{"c":5,"s":"\"  <tr>\"","i":1834},"\n                        ",{"c":5,"s":"\"    <th>Command</th>\"","i":1836},"\n                        ",{"c":5,"s":"\"    <th>Keys</th>\"","i":1838},"\n                        ",{"c":5,"s":"\"    <th>Examples</th>\"","i":1840},"\n                        ",{"c":5,"s":"\"  </tr>\"","i":1842},"))\n      (",{"c":5,"s":"let","i":1844}," ((",{"c":5,"s":"name","i":1846}," (",{"c":5,"s":"symbol-name","i":1848}," ",{"c":5,"s":"fn","i":1850},")))\n        (",{"c":5,"s":"if","i":1852}," (",{"c":5,"s":"string-match","i":1854}," (",{"c":5,"s":"symbol-name","i":1856}," ",{"c":5,"s":"'","i":1858},{"c":5,"s":"paredit-","i":1860},") ",{"c":5,"s":"name","i":1862},")\n            (",{"c":5,"s":"funcall","i":1864}," ",{"c":5,"s":"insert-lines","i":1866},"\n                     ",{"c":5,"s":"\"  <tr>\"","i":1868},"\n                     (",{"c":5,"s":"concat","i":1870}," ",{"c":5,"s":"\"    <td><tt>\"","i":1872}," ",{"c":5,"s":"name","i":1874}," ",{"c":5,"s":"\"</tt></td>\"","i":1876},")\n                     (",{"c":5,"s":"concat","i":1878}," ",{"c":5,"s":"\"    <td align=\\\"center\\\">\"","i":1880},"\n                             (",{"c":5,"s":"funcall","i":1882}," ",{"c":5,"s":"html-keys","i":1884}," ",{"c":5,"s":"keys","i":1886},")\n                             ",{"c":5,"s":"\"</td>\"","i":1888},")\n                     (",{"c":5,"s":"concat","i":1890}," ",{"c":5,"s":"\"    <td>\"","i":1892},"\n                             (",{"c":5,"s":"if","i":1894}," ",{"c":5,"s":"examples","i":1896},"\n                                 (",{"c":5,"s":"mapconcat","i":1898}," ",{"c":5,"s":"html-example","i":1900}," ",{"c":5,"s":"examples","i":1902},"\n                                            ",{"c":5,"s":"\"<hr>\"","i":1904},")\n                                 ",{"c":5,"s":"\"(no examples)\"","i":1906},")\n                             ",{"c":5,"s":"\"</td>\"","i":1908},")\n                     ",{"c":5,"s":"\"  </tr>\"","i":1910},")))))\n  (",{"c":5,"s":"insert","i":1912}," ",{"c":5,"s":"\"</table>\\n\"","i":1914},"))\n\n(",{"c":5,"s":"defun","i":1916}," ",{"c":5,"s":"paredit-html-quote","i":1918}," (",{"c":5,"s":"string","i":1920},")\n  (",{"c":5,"s":"with-temp-buffer","i":1922},"\n    (",{"c":5,"s":"dotimes","i":1924}," (",{"c":5,"s":"i","i":1926}," (",{"c":5,"s":"length","i":1928}," ",{"c":5,"s":"string","i":1930},"))\n      (",{"c":5,"s":"insert","i":1932}," (",{"c":5,"s":"let","i":1934}," ((",{"c":5,"s":"c","i":1936}," (",{"c":5,"s":"elt","i":1938}," ",{"c":5,"s":"string","i":1940}," ",{"c":5,"s":"i","i":1942},")))\n                (",{"c":5,"s":"cond","i":1944}," ((",{"c":5,"s":"eq","i":1946}," ",{"c":5,"s":"c","i":1948}," ",{"c":5,"s":"?\\<","i":1950},") ",{"c":5,"s":"\"<\"","i":1952},")\n                      ((",{"c":5,"s":"eq","i":1954}," ",{"c":5,"s":"c","i":1956}," ",{"c":5,"s":"?\\>","i":1958},") ",{"c":5,"s":"\">\"","i":1960},")\n                      ((",{"c":5,"s":"eq","i":1962}," ",{"c":5,"s":"c","i":1964}," ",{"c":5,"s":"?\\&","i":1966},") ",{"c":5,"s":"\"&\"","i":1968},")\n                      ((",{"c":5,"s":"eq","i":1970}," ",{"c":5,"s":"c","i":1972}," ",{"c":5,"s":"?\\'","i":1974},") ",{"c":5,"s":"\"'\"","i":1976},")\n                      ((",{"c":5,"s":"eq","i":1978}," ",{"c":5,"s":"c","i":1980}," ",{"c":5,"s":"?\\\"","i":1982},") ",{"c":5,"s":"\"\"\"","i":1984},")\n                      (",{"c":5,"s":"t","i":1986}," ",{"c":5,"s":"c","i":1988},")))))\n    (",{"c":5,"s":"buffer-string","i":1990},")))\n\n",{"c":5,"s":";;;; Delimiter Insertion\n","i":1992},"\n(",{"c":3,"s":"eval-and-compile","i":578},"\n  (",{"c":3,"s":"defun","i":580}," ",{"c":3,"s":"paredit-conc-name","i":582}," (",{"c":3,"s":"&rest","i":584}," ",{"c":3,"s":"strings","i":586},")\n    (",{"c":3,"s":"intern","i":588}," (",{"c":3,"s":"apply","i":590}," ",{"c":3,"s":"'","i":592},{"c":3,"s":"concat","i":594}," ",{"c":3,"s":"strings","i":596},")))\n\n  (",{"c":3,"s":"defmacro","i":598}," ",{"c":3,"s":"define-paredit-pair","i":600}," (",{"c":3,"s":"open","i":602}," ",{"c":3,"s":"close","i":604}," ",{"c":3,"s":"name","i":606},")\n    ",{"c":3,"s":"`","i":608},"(",{"c":0,"s":"progn"},"\n       (",{"c":3,"s":"defun","i":610}," ",{"c":3,"s":",","i":612},"(",{"c":3,"s":"paredit-conc-name","i":614}," ",{"c":3,"s":"\"paredit-open-\"","i":616}," ",{"c":3,"s":"name","i":618},") (",{"c":3,"s":"&optional","i":620}," ",{"c":3,"s":"n","i":622},")\n         ",{"c":3,"s":",","i":624},"(",{"c":3,"s":"concat","i":626}," ",{"c":3,"s":"\"Insert a balanced \"","i":628}," ",{"c":3,"s":"name","i":630}," ",{"c":3,"s":"\" pair.\nWith a prefix argument N, put the closing \"","i":632}," ",{"c":3,"s":"name","i":634}," ",{"c":3,"s":"\" after N\n  S-expressions forward.\nIf the region is active, `transient-mark-mode' is enabled, and the\n  region's start and end fall in the same parenthesis depth, insert a\n  \"","i":636}," ",{"c":3,"s":"name","i":638}," ",{"c":3,"s":"\" pair around the region.\nIf in a string or a comment, insert a single \"","i":640}," ",{"c":3,"s":"name","i":642}," ",{"c":3,"s":"\".\nIf in a character literal, do nothing.  This prevents changing what was\n  in the character literal to a meaningful delimiter unintentionally.\"","i":644},")\n         (",{"c":3,"s":"interactive","i":646}," ",{"c":3,"s":"\"P\"","i":648},")\n         (",{"c":3,"s":"cond","i":650}," ((",{"c":3,"s":"or","i":652}," (",{"c":3,"s":"paredit-in-string-p","i":654},")\n                    (",{"c":3,"s":"paredit-in-comment-p","i":656},"))\n                (",{"c":3,"s":"insert","i":658}," ",{"c":3,"s":",","i":660},{"c":3,"s":"open","i":662},"))\n               ((",{"c":3,"s":"not","i":664}," (",{"c":3,"s":"paredit-in-char-p","i":666},"))\n                (",{"c":3,"s":"paredit-insert-pair","i":668}," ",{"c":3,"s":"n","i":670}," ",{"c":3,"s":",","i":672},{"c":3,"s":"open","i":674}," ",{"c":3,"s":",","i":676},{"c":3,"s":"close","i":678}," ",{"c":3,"s":"'","i":680},{"c":3,"s":"goto-char","i":682},"))))\n       (",{"c":3,"s":"defun","i":496}," ",{"c":3,"s":",","i":498},"(",{"c":3,"s":"paredit-conc-name","i":500}," ",{"c":3,"s":"\"paredit-close-\"","i":502}," ",{"c":3,"s":"name","i":504},") ()\n         ",{"c":3,"s":",","i":506},"(",{"c":3,"s":"concat","i":508}," ",{"c":3,"s":"\"Move past one closing delimiter and reindent.\n\\(Agnostic to the specific closing delimiter.)\nIf in a string or comment, insert a single closing \"","i":510}," ",{"c":3,"s":"name","i":512}," ",{"c":3,"s":"\".\nIf in a character literal, do nothing.  This prevents changing what was\n  in the character literal to a meaningful delimiter unintentionally.\"","i":514},")\n         (",{"c":3,"s":"interactive","i":516},")\n         (",{"c":3,"s":"paredit-move-past-close","i":518}," ",{"c":3,"s":",","i":520},{"c":3,"s":"close","i":522},"))\n       (",{"c":3,"s":"defun","i":388}," ",{"c":3,"s":",","i":390},"(",{"c":3,"s":"paredit-conc-name","i":392}," ",{"c":3,"s":"\"paredit-close-\"","i":394}," ",{"c":3,"s":"name","i":396}," ",{"c":3,"s":"\"-and-newline\"","i":398},") ()\n         ",{"c":3,"s":",","i":400},"(",{"c":3,"s":"concat","i":402}," ",{"c":3,"s":"\"Move past one closing delimiter, add a newline,\"","i":404},"\n                  ",{"c":3,"s":"\" and reindent.\nIf there was a margin comment after the closing delimiter, preserve it\n  on the same line.\"","i":406},")\n         (",{"c":3,"s":"interactive","i":408},")\n         (",{"c":3,"s":"paredit-move-past-close-and-newline","i":410}," ",{"c":3,"s":",","i":412},{"c":3,"s":"close","i":414},")))))\n\n",{"c":0,"s":"(define-paredit-pair ?\\( ?\\) \"parenthesis\")"},"\n",{"c":0,"s":"(define-paredit-pair ?\\[ ?\\] \"bracket\")"},"\n",{"c":0,"s":"(define-paredit-pair ?\\{ ?\\} \"brace\")"},"\n",{"c":0,"s":"(define-paredit-pair ?\\< ?\\> \"brocket\")"},"\n\n(",{"c":5,"s":"defun","i":1994}," ",{"c":5,"s":"paredit-move-past-close","i":1996}," (",{"c":5,"s":"close","i":1998},")\n  (",{"c":0,"s":"cond"}," ((",{"c":3,"s":"or","i":684}," (",{"c":3,"s":"paredit-in-string-p","i":686},")\n             (",{"c":3,"s":"paredit-in-comment-p","i":688},"))\n         (",{"c":3,"s":"insert","i":690}," ",{"c":3,"s":"close","i":692},"))\n        ",{"c":0,"s":"((not (paredit-in-char-p))\n         (paredit-move-past-close-and-reindent)\n         (paredit-blink-paren-match nil))"},"))\n\n(",{"c":5,"s":"defun","i":2000}," ",{"c":5,"s":"paredit-move-past-close-and-newline","i":2002}," (",{"c":5,"s":"close","i":2004},")\n  ",{"c":0,"s":"(cond ((or (paredit-in-string-p)\n             (paredit-in-comment-p))\n         (insert close))\n        (t (if (paredit-in-char-p) (forward-char))\n           (paredit-move-past-close-and-reindent)\n           (let ((comment.point (paredit-find-comment-on-line)))\n             (newline)\n             (if comment.point\n                 (save-excursion\n                   (forward-line -1)\n                   (end-of-line)\n                   (indent-to (cdr comment.point))\n                   (insert (car comment.point)))))\n           (lisp-indent-line)\n           (paredit-ignore-sexp-errors (indent-sexp))\n           (paredit-blink-paren-match t)))"},")\n\n(",{"c":5,"s":"defun","i":2006}," ",{"c":5,"s":"paredit-find-comment-on-line","i":2008}," ()\n  ",{"c":0,"s":"\"Find a margin comment on the current line.\nIf such a comment exists, delete the comment (including all leading\n  whitespace) and return a cons whose car is the comment as a string\n  and whose cdr is the point of the comment's initial semicolon,\n  relative to the start of the line.\""},"\n  (",{"c":0,"s":"save-excursion"},"\n    (",{"c":0,"s":"catch"}," ",{"c":0,"s":"'"},{"c":0,"s":"return"},"\n      (",{"c":0,"s":"while"}," ",{"c":0,"s":"t"},"\n        (",{"c":0,"s":"if"}," ",{"c":0,"s":"(search-forward \";\" (point-at-eol) t)"},"\n            (",{"c":0,"s":"if"}," ",{"c":0,"s":"(not (or (paredit-in-string-p)\n                         (paredit-in-char-p)))"},"\n                (",{"c":3,"s":"let*","i":694}," ((",{"c":3,"s":"start","i":696}," (",{"c":3,"s":"progn","i":698}," (",{"c":3,"s":"backward-char","i":700},")  ",{"c":0,"s":";before semicolon\n"},"                                     (",{"c":3,"s":"point","i":702},")))\n                       (",{"c":3,"s":"comment","i":704}," (",{"c":3,"s":"buffer-substring","i":706}," ",{"c":3,"s":"start","i":708},"\n                                                  (",{"c":3,"s":"point-at-eol","i":710},"))))\n                  (",{"c":3,"s":"paredit-skip-whitespace","i":712}," ",{"c":3,"s":"nil","i":714}," (",{"c":3,"s":"point-at-bol","i":716},"))\n                  (",{"c":3,"s":"delete-region","i":718}," (",{"c":3,"s":"point","i":720},") (",{"c":3,"s":"point-at-eol","i":722},"))\n                  (",{"c":0,"s":"throw"}," ",{"c":0,"s":"'"},{"c":0,"s":"return"},"\n                         (",{"c":3,"s":"cons","i":724}," ",{"c":3,"s":"comment","i":726}," (",{"c":3,"s":"-","i":728}," ",{"c":3,"s":"start","i":730}," (",{"c":3,"s":"point-at-bol","i":732},"))))))\n            ",{"c":0,"s":"(throw 'return nil)"},")))))\n\n(",{"c":5,"s":"defun","i":2010}," ",{"c":5,"s":"paredit-insert-pair","i":2012}," (",{"c":5,"s":"n","i":2014}," ",{"c":5,"s":"open","i":2016}," ",{"c":5,"s":"close","i":2018}," ",{"c":5,"s":"forward","i":2020},")\n  (",{"c":5,"s":"let*","i":2022}," ((",{"c":5,"s":"regionp","i":2024}," (",{"c":5,"s":"and","i":2026}," (",{"c":5,"s":"paredit-region-active-p","i":2028},")\n                       (",{"c":5,"s":"paredit-region-safe-for-insert-p","i":2030},")))\n         (",{"c":5,"s":"end","i":2032}," (",{"c":5,"s":"and","i":2034}," ",{"c":5,"s":"regionp","i":2036},"\n                   (",{"c":5,"s":"not","i":2038}," ",{"c":5,"s":"n","i":2040},")\n                   (",{"c":5,"s":"prog1","i":2042}," (",{"c":5,"s":"region-end","i":2044},")\n                     (",{"c":5,"s":"goto-char","i":2046}," (",{"c":5,"s":"region-beginning","i":2048},"))))))\n    (",{"c":5,"s":"let","i":2050}," ((",{"c":5,"s":"spacep","i":2052}," (",{"c":5,"s":"paredit-space-for-delimiter-p","i":2054}," ",{"c":5,"s":"nil","i":2056}," ",{"c":5,"s":"open","i":2058},")))\n      (",{"c":5,"s":"if","i":2060}," ",{"c":5,"s":"spacep","i":2062}," (",{"c":5,"s":"insert","i":2064}," ",{"c":5,"s":"\" \"","i":2066},"))\n      (",{"c":5,"s":"insert","i":2068}," ",{"c":5,"s":"open","i":2070},")\n      (",{"c":5,"s":"save-excursion","i":2072},"\n        ",{"c":5,"s":";; Move past the desired region.\n","i":2074},"        (",{"c":5,"s":"cond","i":2076}," (",{"c":5,"s":"n","i":2078}," (",{"c":5,"s":"funcall","i":2080}," ",{"c":5,"s":"forward","i":2082},"\n                          (",{"c":5,"s":"save-excursion","i":2084},"\n                            (",{"c":5,"s":"forward-sexp","i":2086}," (",{"c":5,"s":"prefix-numeric-value","i":2088}," ",{"c":5,"s":"n","i":2090},"))\n                            (",{"c":5,"s":"point","i":2092},"))))\n              (",{"c":5,"s":"regionp","i":2094}," (",{"c":5,"s":"funcall","i":2096}," ",{"c":5,"s":"forward","i":2098}," (",{"c":5,"s":"+","i":2100}," ",{"c":5,"s":"end","i":2102}," (",{"c":5,"s":"if","i":2104}," ",{"c":5,"s":"spacep","i":2106}," ",{"c":5,"s":"2","i":2108}," ",{"c":5,"s":"1","i":2110},")))))\n        (",{"c":5,"s":"insert","i":2112}," ",{"c":5,"s":"close","i":2114},")\n        (",{"c":5,"s":"if","i":2116}," (",{"c":5,"s":"paredit-space-for-delimiter-p","i":2118}," ",{"c":5,"s":"t","i":2120}," ",{"c":5,"s":"close","i":2122},")\n            (",{"c":5,"s":"insert","i":2124}," ",{"c":5,"s":"\" \"","i":2126},"))))))\n\n(",{"c":5,"s":"defun","i":2128}," ",{"c":5,"s":"paredit-region-safe-for-insert-p","i":2130}," ()\n  (",{"c":5,"s":"save-excursion","i":2132},"\n    (",{"c":5,"s":"let","i":2134}," ((",{"c":5,"s":"beginning","i":2136}," (",{"c":5,"s":"region-beginning","i":2138},"))\n          (",{"c":5,"s":"end","i":2140}," (",{"c":5,"s":"region-end","i":2142},")))\n      (",{"c":5,"s":"goto-char","i":2144}," ",{"c":5,"s":"beginning","i":2146},")\n      (",{"c":5,"s":"let*","i":2148}," ((",{"c":5,"s":"beginning-state","i":2150}," (",{"c":5,"s":"paredit-current-parse-state","i":2152},"))\n             (",{"c":5,"s":"end-state","i":2154}," (",{"c":5,"s":"parse-partial-sexp","i":2156}," ",{"c":5,"s":"beginning","i":2158}," ",{"c":5,"s":"end","i":2160},"\n                                            ",{"c":5,"s":"nil","i":2162}," ",{"c":5,"s":"nil","i":2164}," ",{"c":5,"s":"beginning-state","i":2166},")))\n        (",{"c":5,"s":"and","i":2168}," (",{"c":5,"s":"=","i":2170},"  (",{"c":5,"s":"nth","i":2172}," ",{"c":5,"s":"0","i":2174}," ",{"c":5,"s":"beginning-state","i":2176},")   ",{"c":5,"s":"; 0. depth in parens\n","i":2178},"                 (",{"c":5,"s":"nth","i":2180}," ",{"c":5,"s":"0","i":2182}," ",{"c":5,"s":"end-state","i":2184},"))\n             (",{"c":5,"s":"eq","i":2186}," (",{"c":5,"s":"nth","i":2188}," ",{"c":5,"s":"3","i":2190}," ",{"c":5,"s":"beginning-state","i":2192},")   ",{"c":5,"s":"; 3. non-nil if inside a\n","i":2194},"                 (",{"c":5,"s":"nth","i":2196}," ",{"c":5,"s":"3","i":2198}," ",{"c":5,"s":"end-state","i":2200},"))        ",{"c":5,"s":";    string\n","i":2202},"             (",{"c":5,"s":"eq","i":2204}," (",{"c":5,"s":"nth","i":2206}," ",{"c":5,"s":"4","i":2208}," ",{"c":5,"s":"beginning-state","i":2210},")   ",{"c":5,"s":"; 4. comment status, yada\n","i":2212},"                 (",{"c":5,"s":"nth","i":2214}," ",{"c":5,"s":"4","i":2216}," ",{"c":5,"s":"end-state","i":2218},"))\n             (",{"c":5,"s":"eq","i":2220}," (",{"c":5,"s":"nth","i":2222}," ",{"c":5,"s":"5","i":2224}," ",{"c":5,"s":"beginning-state","i":2226},")   ",{"c":5,"s":"; 5. t if following char\n","i":2228},"                 (",{"c":5,"s":"nth","i":2230}," ",{"c":5,"s":"5","i":2232}," ",{"c":5,"s":"end-state","i":2234},")))))))   ",{"c":5,"s":";    quote\n","i":2236},"\n(",{"c":5,"s":"defun","i":2238}," ",{"c":5,"s":"paredit-space-for-delimiter-p","i":2240}," (",{"c":5,"s":"endp","i":2242}," ",{"c":5,"s":"delimiter","i":2244},")\n  ",{"c":5,"s":";; If at the buffer limit, don't insert a space.  If there is a word,\n","i":2246},"  ",{"c":5,"s":";; symbol, other quote, or non-matching parenthesis delimiter (i.e. a\n","i":2248},"  ",{"c":5,"s":";; close when want an open the string or an open when we want to\n","i":2250},"  ",{"c":5,"s":";; close the string), do insert a space.\n","i":2252},"  (",{"c":0,"s":"and"}," (",{"c":3,"s":"not","i":734}," (",{"c":3,"s":"if","i":736}," ",{"c":3,"s":"endp","i":738}," (",{"c":3,"s":"eobp","i":740},") (",{"c":3,"s":"bobp","i":742},")))\n       (",{"c":3,"s":"memq","i":416}," (",{"c":3,"s":"char-syntax","i":524}," (",{"c":3,"s":"if","i":526}," ",{"c":3,"s":"endp","i":528},"\n                              (",{"c":3,"s":"char-after","i":530},")\n                              (",{"c":3,"s":"char-before","i":532},")))\n             (",{"c":0,"s":"list"}," ",{"c":0,"s":"?w"}," ",{"c":0,"s":"?_"}," ",{"c":0,"s":"?\\\""},"\n                   (",{"c":3,"s":"let","i":418}," ((",{"c":3,"s":"matching","i":420}," (",{"c":3,"s":"matching-paren","i":422}," ",{"c":3,"s":"delimiter","i":424},")))\n                     (",{"c":3,"s":"and","i":426}," ",{"c":3,"s":"matching","i":428}," (",{"c":3,"s":"char-syntax","i":430}," ",{"c":3,"s":"matching","i":432},")))))))\n\n(",{"c":5,"s":"defun","i":2254}," ",{"c":5,"s":"paredit-move-past-close-and-reindent","i":2256}," ",{"c":0,"s":"()"},"\n  (",{"c":0,"s":"let"}," ",{"c":0,"s":"((orig (point)))"},"\n    ",{"c":0,"s":"(up-list)"},"\n    (",{"c":3,"s":"if","i":744}," (",{"c":3,"s":"catch","i":746}," ",{"c":3,"s":"'","i":748},{"c":3,"s":"return","i":750},"                  ",{"c":3,"s":"; This CATCH returns T if it\n","i":752},"          (",{"c":3,"s":"while","i":754}," ",{"c":3,"s":"t","i":756},"                      ",{"c":3,"s":"; should delete leading spaces\n","i":758},"            (",{"c":3,"s":"save-excursion","i":760},"             ",{"c":3,"s":"; and NIL if not.\n","i":762},"              (",{"c":3,"s":"let","i":764}," ((",{"c":3,"s":"before-paren","i":766}," (",{"c":3,"s":"1-","i":768}," (",{"c":3,"s":"point","i":770},"))))\n                (",{"c":3,"s":"back-to-indentation","i":772},")\n                (",{"c":3,"s":"cond","i":774}," ((",{"c":3,"s":"not","i":776}," (",{"c":3,"s":"eq","i":778}," (",{"c":3,"s":"point","i":780},") ",{"c":3,"s":"before-paren","i":782},"))\n                       ",{"c":3,"s":";; Can't call PAREDIT-DELETE-LEADING-WHITESPACE\n","i":784},"                       ",{"c":3,"s":";; here -- we must return from SAVE-EXCURSION\n","i":786},"                       ",{"c":3,"s":";; first.\n","i":788},"                       (",{"c":3,"s":"throw","i":790}," ",{"c":3,"s":"'","i":792},{"c":3,"s":"return","i":794}," ",{"c":3,"s":"t","i":796},"))\n                      ((",{"c":3,"s":"save-excursion","i":798}," (",{"c":3,"s":"forward-line","i":800}," ",{"c":3,"s":"-1","i":802},")\n                                       (",{"c":3,"s":"end-of-line","i":804},")\n                                       (",{"c":3,"s":"paredit-in-comment-p","i":806},"))\n                       ",{"c":0,"s":";; Moving the closing parenthesis any further\n"},"                       ",{"c":0,"s":";; would put it into a comment, so we just\n"},"                       ",{"c":0,"s":";; indent the closing parenthesis where it is\n"},"                       ",{"c":0,"s":";; and abort the loop, telling its continuation\n"},"                       ",{"c":0,"s":";; that no leading whitespace should be deleted.\n"},"                       (",{"c":3,"s":"lisp-indent-line","i":808},")\n                       (",{"c":3,"s":"throw","i":810}," ",{"c":3,"s":"'","i":812},{"c":3,"s":"return","i":814}," ",{"c":3,"s":"nil","i":816},"))\n                      (",{"c":3,"s":"t","i":818}," (",{"c":3,"s":"delete-indentation","i":820},")))))))\n        (",{"c":3,"s":"paredit-delete-leading-whitespace","i":822},"))))\n\n(",{"c":5,"s":"defun","i":2258}," ",{"c":5,"s":"paredit-delete-leading-whitespace","i":2260}," ()\n  ",{"c":0,"s":";; This assumes that we're on the closing parenthesis already.\n"},"  (",{"c":5,"s":"save-excursion","i":2262},"\n    (",{"c":5,"s":"backward-char","i":2264},")\n    (",{"c":5,"s":"while","i":2266}," (",{"c":5,"s":"let","i":2268}," ((",{"c":5,"s":"syn","i":2270}," (",{"c":5,"s":"char-syntax","i":2272}," (",{"c":5,"s":"char-before","i":2274},"))))\n             (",{"c":5,"s":"and","i":2276}," (",{"c":5,"s":"or","i":2278}," (",{"c":5,"s":"eq","i":2280}," ",{"c":5,"s":"syn","i":2282}," ",{"c":5,"s":"?\\ ","i":2284},") (",{"c":5,"s":"eq","i":2286}," ",{"c":5,"s":"syn","i":2288}," ",{"c":5,"s":"?-","i":2290},"))     ",{"c":5,"s":"; whitespace syntax\n","i":2292},"                  ",{"c":5,"s":";; The above line is a perfect example of why the\n","i":2294},"                  ",{"c":5,"s":";; following test is necessary.\n","i":2296},"                  (",{"c":5,"s":"not","i":2298}," (",{"c":5,"s":"paredit-in-char-p","i":2300}," (",{"c":5,"s":"1-","i":2302}," (",{"c":5,"s":"point","i":2304},"))))))\n      (",{"c":5,"s":"backward-delete-char","i":2306}," ",{"c":5,"s":"1","i":2308},"))))\n\n(",{"c":5,"s":"defun","i":2310}," ",{"c":5,"s":"paredit-blink-paren-match","i":2312}," (",{"c":5,"s":"another-line-p","i":2314},")\n  (",{"c":5,"s":"if","i":2316}," (",{"c":5,"s":"and","i":2318}," ",{"c":5,"s":"blink-matching-paren","i":2320},"\n           (",{"c":5,"s":"or","i":2322}," (",{"c":5,"s":"not","i":2324}," ",{"c":5,"s":"show-paren-mode","i":2326},") ",{"c":5,"s":"another-line-p","i":2328},"))\n      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":2330},"\n        (",{"c":5,"s":"save-excursion","i":2332},"\n          (",{"c":5,"s":"backward-sexp","i":2334},")\n          (",{"c":5,"s":"forward-sexp","i":2336},")\n          ",{"c":5,"s":";; SHOW-PAREN-MODE inhibits any blinking, so we disable it\n","i":2338},"          ",{"c":5,"s":";; locally here.\n","i":2340},"          (",{"c":5,"s":"let","i":2342}," ((",{"c":5,"s":"show-paren-mode","i":2344}," ",{"c":5,"s":"nil","i":2346},"))\n            (",{"c":5,"s":"blink-matching-open","i":2348},"))))))\n\n(",{"c":5,"s":"defun","i":2350}," ",{"c":5,"s":"paredit-doublequote","i":2352}," (",{"c":5,"s":"&optional","i":2354}," ",{"c":5,"s":"n","i":2356},")\n  ",{"c":5,"s":"\"Insert a pair of double-quotes.\nWith a prefix argument N, wrap the following N S-expressions in\n  double-quotes, escaping intermediate characters if necessary.\nIf the region is active, `transient-mark-mode' is enabled, and the\n  region's start and end fall in the same parenthesis depth, insert a\n  pair of double-quotes around the region, again escaping intermediate\n  characters if necessary.\nInside a comment, insert a literal double-quote.\nAt the end of a string, move past the closing double-quote.\nIn the middle of a string, insert a backslash-escaped double-quote.\nIf in a character literal, do nothing.  This prevents accidentally\n  changing a what was in the character literal to become a meaningful\n  delimiter unintentionally.\"","i":2358},"\n  (",{"c":5,"s":"interactive","i":2360}," ",{"c":5,"s":"\"P\"","i":2362},")\n  (",{"c":5,"s":"cond","i":2364}," ((",{"c":5,"s":"paredit-in-string-p","i":2366},")\n         (",{"c":5,"s":"if","i":2368}," (",{"c":5,"s":"eq","i":2370}," (",{"c":5,"s":"cdr","i":2372}," (",{"c":5,"s":"paredit-string-start+end-points","i":2374},"))\n                 (",{"c":5,"s":"point","i":2376},"))\n             (",{"c":5,"s":"forward-char","i":2378},")             ",{"c":5,"s":"; We're on the closing quote.\n","i":2380},"             (",{"c":5,"s":"insert","i":2382}," ",{"c":5,"s":"?\\\\","i":2384}," ",{"c":5,"s":"?\\\"","i":2386}," )))\n        ((",{"c":5,"s":"paredit-in-comment-p","i":2388},")\n         (",{"c":5,"s":"insert","i":2390}," ",{"c":5,"s":"?\\\"","i":2392}," ))\n        ((",{"c":5,"s":"not","i":2394}," (",{"c":5,"s":"paredit-in-char-p","i":2396},"))\n         (",{"c":5,"s":"paredit-insert-pair","i":2398}," ",{"c":5,"s":"n","i":2400}," ",{"c":5,"s":"?\\\"","i":2402}," ",{"c":5,"s":"?\\\"","i":2404}," ",{"c":5,"s":"'","i":2406},{"c":5,"s":"paredit-forward-for-quote","i":2408},"))))\n\n(",{"c":5,"s":"defun","i":2410}," ",{"c":5,"s":"paredit-meta-doublequote","i":2412}," (",{"c":5,"s":"&optional","i":2414}," ",{"c":5,"s":"n","i":2416},")\n  ",{"c":5,"s":"\"Move to the end of the string, insert a newline, and indent.\nIf not in a string, act as `paredit-doublequote'; if no prefix argument\n  is specified and the region is not active or `transient-mark-mode' is\n  disabled, the default is to wrap one S-expression, however, not\n  zero.\"","i":2418},"\n  (",{"c":5,"s":"interactive","i":2420}," ",{"c":5,"s":"\"P\"","i":2422},")\n  (",{"c":5,"s":"if","i":2424}," (",{"c":5,"s":"not","i":2426}," (",{"c":5,"s":"paredit-in-string-p","i":2428},"))\n      (",{"c":5,"s":"paredit-doublequote","i":2430}," (",{"c":5,"s":"or","i":2432}," ",{"c":5,"s":"n","i":2434},"\n                               (",{"c":5,"s":"and","i":2436}," (",{"c":5,"s":"not","i":2438}," (",{"c":5,"s":"paredit-region-active-p","i":2440},"))\n                                    ",{"c":5,"s":"1","i":2442},")))\n    (",{"c":5,"s":"let","i":2444}," ((",{"c":5,"s":"start+end","i":2446}," (",{"c":5,"s":"paredit-string-start+end-points","i":2448},")))\n      (",{"c":5,"s":"goto-char","i":2450}," (",{"c":5,"s":"1+","i":2452}," (",{"c":5,"s":"cdr","i":2454}," ",{"c":5,"s":"start+end","i":2456},")))\n      (",{"c":5,"s":"newline","i":2458},")\n      (",{"c":5,"s":"lisp-indent-line","i":2460},")\n      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":2462}," (",{"c":5,"s":"indent-sexp","i":2464},")))))\n\n(",{"c":5,"s":"defun","i":2466}," ",{"c":5,"s":"paredit-forward-for-quote","i":2468}," (",{"c":5,"s":"end","i":2470},")\n  (",{"c":5,"s":"let","i":2472}," ((",{"c":5,"s":"state","i":2474}," (",{"c":5,"s":"paredit-current-parse-state","i":2476},")))\n    (",{"c":5,"s":"while","i":2478}," (",{"c":5,"s":"<","i":2480}," (",{"c":5,"s":"point","i":2482},") ",{"c":5,"s":"end","i":2484},")\n      (",{"c":5,"s":"let","i":2486}," ((",{"c":5,"s":"new-state","i":2488}," (",{"c":5,"s":"parse-partial-sexp","i":2490}," (",{"c":5,"s":"point","i":2492},") (",{"c":5,"s":"1+","i":2494}," (",{"c":5,"s":"point","i":2496},"))\n                                           ",{"c":5,"s":"nil","i":2498}," ",{"c":5,"s":"nil","i":2500}," ",{"c":5,"s":"state","i":2502},")))\n        (",{"c":5,"s":"if","i":2504}," (",{"c":5,"s":"paredit-in-string-p","i":2506}," ",{"c":5,"s":"new-state","i":2508},")\n            (",{"c":5,"s":"if","i":2510}," (",{"c":5,"s":"not","i":2512}," (",{"c":5,"s":"paredit-in-string-escape-p","i":2514},"))\n                (",{"c":5,"s":"setq","i":2516}," ",{"c":5,"s":"state","i":2518}," ",{"c":5,"s":"new-state","i":2520},")\n              ",{"c":5,"s":";; Escape character: turn it into an escaped escape\n","i":2522},"              ",{"c":5,"s":";; character by appending another backslash.\n","i":2524},"              (",{"c":5,"s":"insert","i":2526}," ",{"c":5,"s":"?\\\\","i":2528}," )\n              ",{"c":5,"s":";; Now the point is after both escapes, and we want to\n","i":2530},"              ",{"c":5,"s":";; rescan from before the first one to after the second\n","i":2532},"              ",{"c":5,"s":";; one.\n","i":2534},"              (",{"c":5,"s":"setq","i":2536}," ",{"c":5,"s":"state","i":2538},"\n                    (",{"c":5,"s":"parse-partial-sexp","i":2540}," (",{"c":5,"s":"-","i":2542}," (",{"c":5,"s":"point","i":2544},") ",{"c":5,"s":"2","i":2546},") (",{"c":5,"s":"point","i":2548},")\n                                        ",{"c":5,"s":"nil","i":2550}," ",{"c":5,"s":"nil","i":2552}," ",{"c":5,"s":"state","i":2554},"))\n              ",{"c":5,"s":";; Advance the end point, since we just inserted a new\n","i":2556},"              ",{"c":5,"s":";; character.\n","i":2558},"              (",{"c":5,"s":"setq","i":2560}," ",{"c":5,"s":"end","i":2562}," (",{"c":5,"s":"1+","i":2564}," ",{"c":5,"s":"end","i":2566},")))\n          ",{"c":5,"s":";; String: escape by inserting a backslash before the quote.\n","i":2568},"          (",{"c":5,"s":"backward-char","i":2570},")\n          (",{"c":5,"s":"insert","i":2572}," ",{"c":5,"s":"?\\\\","i":2574}," )\n          ",{"c":5,"s":";; The point is now between the escape and the quote, and we\n","i":2576},"          ",{"c":5,"s":";; want to rescan from before the escape to after the quote.\n","i":2578},"          (",{"c":5,"s":"setq","i":2580}," ",{"c":5,"s":"state","i":2582},"\n                (",{"c":5,"s":"parse-partial-sexp","i":2584}," (",{"c":5,"s":"1-","i":2586}," (",{"c":5,"s":"point","i":2588},")) (",{"c":5,"s":"1+","i":2590}," (",{"c":5,"s":"point","i":2592},"))\n                                    ",{"c":5,"s":"nil","i":2594}," ",{"c":5,"s":"nil","i":2596}," ",{"c":5,"s":"state","i":2598},"))\n          ",{"c":5,"s":";; Advance the end point for the same reason as above.\n","i":2600},"          (",{"c":5,"s":"setq","i":2602}," ",{"c":5,"s":"end","i":2604}," (",{"c":5,"s":"1+","i":2606}," ",{"c":5,"s":"end","i":2608},")))))))\n\n",{"c":5,"s":";;;; Escape Insertion\n","i":2610},"\n(",{"c":5,"s":"defun","i":2612}," ",{"c":5,"s":"paredit-backslash","i":2614}," ()\n  ",{"c":5,"s":"\"Insert a backslash followed by a character to escape.\"","i":2616},"\n  (",{"c":5,"s":"interactive","i":2618},")\n  (",{"c":5,"s":"insert","i":2620}," ",{"c":5,"s":"?\\\\","i":2622}," )\n  ",{"c":5,"s":";; This funny conditional is necessary because PAREDIT-IN-COMMENT-P\n","i":2624},"  ",{"c":5,"s":";; assumes that PAREDIT-IN-STRING-P already returned false; otherwise\n","i":2626},"  ",{"c":5,"s":";; it may give erroneous answers.\n","i":2628},"  (",{"c":5,"s":"if","i":2630}," (",{"c":5,"s":"or","i":2632}," (",{"c":5,"s":"paredit-in-string-p","i":2634},")\n          (",{"c":5,"s":"not","i":2636}," (",{"c":5,"s":"paredit-in-comment-p","i":2638},")))\n      (",{"c":5,"s":"let","i":2640}," ((",{"c":5,"s":"delp","i":2642}," ",{"c":5,"s":"t","i":2644},"))\n        (",{"c":5,"s":"unwind-protect","i":2646}," (",{"c":5,"s":"setq","i":2648}," ",{"c":5,"s":"delp","i":2650},"\n                              (",{"c":5,"s":"call-interactively","i":2652}," ",{"c":5,"s":"'","i":2654},{"c":5,"s":"paredit-escape","i":2656},"))\n          ",{"c":5,"s":";; We need this in an UNWIND-PROTECT so that the backlash is\n","i":2658},"          ",{"c":5,"s":";; left in there *only* if PAREDIT-ESCAPE return NIL normally\n","i":2660},"          ",{"c":5,"s":";; -- in any other case, such as the user hitting C-g or an\n","i":2662},"          ",{"c":5,"s":";; error occurring, we must delete the backslash to avoid\n","i":2664},"          ",{"c":5,"s":";; leaving a dangling escape.  (This control structure is a\n","i":2666},"          ",{"c":5,"s":";; crock.)\n","i":2668},"          (",{"c":5,"s":"if","i":2670}," ",{"c":5,"s":"delp","i":2672}," (",{"c":5,"s":"backward-delete-char","i":2674}," ",{"c":5,"s":"1","i":2676},"))))))\n\n",{"c":5,"s":";;; This auxiliary interactive function returns true if the backslash\n","i":2678},{"c":5,"s":";;; should be deleted and false if not.\n","i":2680},"\n(",{"c":5,"s":"defun","i":2682}," ",{"c":5,"s":"paredit-escape","i":2684}," (",{"c":5,"s":"char","i":2686},")\n  ",{"c":5,"s":";; I'm too lazy to figure out how to do this without a separate\n","i":2688},"  ",{"c":5,"s":";; interactive function.\n","i":2690},"  (",{"c":5,"s":"interactive","i":2692}," ",{"c":5,"s":"\"cEscaping character...\"","i":2694},")\n  (",{"c":5,"s":"if","i":2696}," (",{"c":5,"s":"eq","i":2698}," ",{"c":5,"s":"char","i":2700}," ",{"c":5,"s":"127","i":2702},")                     ",{"c":5,"s":"; The backslash was a typo, so\n","i":2704},"      ",{"c":5,"s":"t","i":2706},"                                 ",{"c":5,"s":"; the luser wants to delete it.\n","i":2708},"    (",{"c":5,"s":"insert","i":2710}," ",{"c":5,"s":"char","i":2712},")                       ",{"c":5,"s":"; (Is there a better way to\n","i":2714},"    ",{"c":5,"s":"nil","i":2716},"))                               ",{"c":5,"s":"; express the rubout char?\n","i":2718},"                                        ",{"c":5,"s":"; ?\\^? works, but ugh...)\n","i":2720},"\n",{"c":0,"s":";;; The placement of this function in this file is totally random.\n"},"\n(",{"c":5,"s":"defun","i":2722}," ",{"c":5,"s":"paredit-newline","i":2724}," ()\n  ",{"c":0,"s":"\"Insert a newline and indent it.\nThis is like `newline-and-indent', but it not only indents the line\n  that the point is on but also the S-expression following the point,\n  if there is one.\nMove forward one character first if on an escaped character.\nIf in a string, just insert a literal newline.\""},"\n  (",{"c":5,"s":"interactive","i":2726},")\n  ",{"c":0,"s":"(if (paredit-in-string-p)\n      (newline)\n    (if (and (not (paredit-in-comment-p)) (paredit-in-char-p))\n        (forward-char))\n    (newline-and-indent)\n    ;; Indent the following S-expression, but don't signal an error if\n    ;; there's only a closing parenthesis after the point.\n    (paredit-ignore-sexp-errors (indent-sexp)))"},")\n\n",{"c":0,"s":";;;; Comment Insertion\n"},"\n(",{"c":5,"s":"defun","i":2728}," ",{"c":5,"s":"paredit-semicolon","i":2730}," (",{"c":5,"s":"&optional","i":2732}," ",{"c":5,"s":"n","i":2734},")\n  ",{"c":0,"s":"\"Insert a semicolon, moving any code after the point to a new line.\nIf in a string, comment, or character literal, insert just a literal\n  semicolon, and do not move anything to the next line.\nWith a prefix argument N, insert N semicolons.\""},"\n  ",{"c":0,"s":"(interactive \"P\")"},"\n  (",{"c":0,"s":"if"}," (",{"c":0,"s":"not"}," (",{"c":0,"s":"or"}," ",{"c":0,"s":"(paredit-in-string-p)"},"\n               ",{"c":0,"s":"(paredit-in-comment-p)"},"\n               ",{"c":0,"s":"(paredit-in-char-p)"},"\n               ",{"c":0,"s":";; No more code on the line after the point.\n"},"               (",{"c":3,"s":"save-excursion","i":824},"\n                 (",{"c":3,"s":"paredit-skip-whitespace","i":826}," ",{"c":3,"s":"t","i":828}," (",{"c":3,"s":"point-at-eol","i":830},"))\n                 (",{"c":3,"s":"or","i":832}," (",{"c":3,"s":"eolp","i":834},")\n                     ",{"c":0,"s":";; Let the user prefix semicolons to existing\n"},"                     ",{"c":0,"s":";; comments.\n"},"                     (",{"c":3,"s":"eq","i":836}," (",{"c":3,"s":"char-after","i":838},") ",{"c":3,"s":"?\\;","i":840},")))))\n      ",{"c":0,"s":";; Don't use NEWLINE-AND-INDENT, because that will delete all of\n"},"      ",{"c":0,"s":";; the horizontal whitespace first, but we just want to move the\n"},"      ",{"c":0,"s":";; code following the point onto the next line while preserving\n"},"      ",{"c":0,"s":";; the point on this line.\n"},"      ",{"c":0,"s":";++ Why indent only the line?\n"},"      ",{"c":0,"s":"(save-excursion (newline) (lisp-indent-line))"},")\n  ",{"c":0,"s":"(insert (make-string (if n (prefix-numeric-value n) 1)\n                       ?\\; ))"},")\n\n(",{"c":5,"s":"defun","i":2736}," ",{"c":5,"s":"paredit-comment-dwim","i":2738}," ",{"c":0,"s":"(&optional arg)"},"\n  ",{"c":5,"s":"\"Call the Lisp comment command you want (Do What I Mean).\nThis is like `comment-dwim', but it is specialized for Lisp editing.\nIf transient mark mode is enabled and the mark is active, comment or\n  uncomment the selected region, depending on whether it was entirely\n  commented not not already.\nIf there is already a comment on the current line, with no prefix\n  argument, indent to that comment; with a prefix argument, kill that\n  comment.\nOtherwise, insert a comment appropriate for the context and ensure that\n  any code following the comment is moved to the next line.\nAt the top level, where indentation is calculated to be at column 0,\n  insert a triple-semicolon comment; within code, where the indentation\n  is calculated to be non-zero, and on the line there is either no code\n  at all or code after the point, insert a double-semicolon comment;\n  and if the point is after all code on the line, insert a single-\n  semicolon margin comment at `comment-column'.\"","i":2740},"\n  (",{"c":5,"s":"interactive","i":2742}," ",{"c":5,"s":"\"*P\"","i":2744},")\n  ",{"c":0,"s":"(require 'newcomment)"},"\n  ",{"c":0,"s":"(comment-normalize-vars)"},"\n  ",{"c":0,"s":"(cond ((paredit-region-active-p)\n         (comment-or-uncomment-region (region-beginning)\n                                      (region-end)\n                                      arg))\n        ((paredit-comment-on-line-p)\n         (if arg\n             (comment-kill (if (integerp arg) arg nil))\n             (comment-indent)))\n        (t (paredit-insert-comment)))"},")\n\n(",{"c":5,"s":"defun","i":2746}," ",{"c":5,"s":"paredit-comment-on-line-p","i":2748}," ()\n  (",{"c":3,"s":"save-excursion","i":842},"\n    (",{"c":3,"s":"beginning-of-line","i":844},")\n    (",{"c":3,"s":"let","i":846}," ((",{"c":3,"s":"comment-p","i":848}," ",{"c":3,"s":"nil","i":850},"))\n      ",{"c":3,"s":";; Search forward for a comment beginning.  If there is one, set\n","i":852},"      ",{"c":3,"s":";; COMMENT-P to true; if not, it will be nil.\n","i":854},"      (",{"c":3,"s":"while","i":856}," (",{"c":0,"s":"progn"}," ",{"c":0,"s":"(setq comment-p\n                          (search-forward \";\" (point-at-eol)\n                                          ;; t -> no error\n                                          t))"},"\n                    (",{"c":3,"s":"and","i":858}," ",{"c":3,"s":"comment-p","i":860},"\n                         (",{"c":3,"s":"or","i":862}," (",{"c":3,"s":"paredit-in-string-p","i":864},")\n                             (",{"c":3,"s":"paredit-in-char-p","i":866}," (",{"c":3,"s":"1-","i":868}," (",{"c":3,"s":"point","i":870},"))))))\n        (",{"c":3,"s":"forward-char","i":872},"))\n      ",{"c":3,"s":"comment-p","i":874},")))\n\n(",{"c":5,"s":"defun","i":2750}," ",{"c":5,"s":"paredit-insert-comment","i":2752}," ()\n  (",{"c":3,"s":"let","i":876}," ((",{"c":3,"s":"code-after-p","i":878},"\n         (",{"c":3,"s":"save-excursion","i":880}," (",{"c":3,"s":"paredit-skip-whitespace","i":882}," ",{"c":3,"s":"t","i":884}," (",{"c":3,"s":"point-at-eol","i":886},"))\n                         (",{"c":3,"s":"not","i":888}," (",{"c":3,"s":"eolp","i":890},"))))\n        (",{"c":3,"s":"code-before-p","i":892},"\n         (",{"c":3,"s":"save-excursion","i":894}," (",{"c":3,"s":"paredit-skip-whitespace","i":896}," ",{"c":3,"s":"nil","i":898}," (",{"c":3,"s":"point-at-bol","i":900},"))\n                         (",{"c":3,"s":"not","i":902}," (",{"c":3,"s":"bolp","i":904},")))))\n    (",{"c":0,"s":"if"}," (",{"c":3,"s":"and","i":906}," (",{"c":3,"s":"bolp","i":908},")\n             ",{"c":0,"s":";; We have to use EQ 0 here and not ZEROP because ZEROP\n"},"             ",{"c":0,"s":";; signals an error if its argument is non-numeric, but\n"},"             ",{"c":0,"s":";; CALCULATE-LISP-INDENT may return nil.\n"},"             (",{"c":0,"s":"eq"}," (",{"c":3,"s":"let","i":910}," ((",{"c":3,"s":"indent","i":912}," (",{"c":3,"s":"calculate-lisp-indent","i":914},")))\n                   (",{"c":3,"s":"if","i":916}," (",{"c":3,"s":"consp","i":918}," ",{"c":3,"s":"indent","i":920},")\n                       (",{"c":3,"s":"car","i":922}," ",{"c":3,"s":"indent","i":924},")\n                     ",{"c":3,"s":"indent","i":926},"))\n                 ",{"c":0,"s":"0"},"))\n        ",{"c":0,"s":";; Top-level comment\n"},"        ",{"c":0,"s":"(progn (if code-after-p (save-excursion (newline)))\n               (insert \";;; \"))"},"\n      ",{"c":0,"s":"(if code-after-p\n          ;; Code comment\n          (progn (if code-before-p\n                     ;++ Why NEWLINE-AND-INDENT here and not just\n                     ;++ NEWLINE, or PAREDIT-NEWLINE?\n                     (newline-and-indent))\n                 (lisp-indent-line)\n                 (insert \";; \")\n                 ;; Move the following code.  (NEWLINE-AND-INDENT will\n                 ;; delete whitespace after the comment, though, so use\n                 ;; NEWLINE & LISP-INDENT-LINE manually here.)\n                 (save-excursion (newline)\n                                 (lisp-indent-line)))\n          ;; Margin comment\n          (progn (indent-to comment-column\n                            1)          ; 1 -> force one leading space\n                 (insert ?\\; )))"},")))\n\n",{"c":5,"s":";;;; Character Deletion\n","i":2754},"\n(",{"c":5,"s":"defun","i":2756}," ",{"c":5,"s":"paredit-forward-delete","i":2758}," ",{"c":0,"s":"(&optional arg)"},"\n  ",{"c":0,"s":"\"Delete a character forward or move forward over a delimiter.\nIf on an opening S-expression delimiter, move forward into the\n  S-expression.\nIf on a closing S-expression delimiter, refuse to delete unless the\n  S-expression is empty, in which case delete the whole S-expression.\nWith a prefix argument, simply delete a character forward, without\n  regard for delimiter balancing.\""},"\n  (",{"c":5,"s":"interactive","i":2760}," ",{"c":5,"s":"\"P\"","i":2762},")\n  (",{"c":0,"s":"cond"}," ",{"c":0,"s":"((or arg (eobp))\n         (delete-char 1))"},"\n        ",{"c":0,"s":"((paredit-in-string-p)\n         (paredit-forward-delete-in-string))"},"\n        ",{"c":0,"s":"((paredit-in-comment-p)\n         ;++ What to do here?  This could move a partial S-expression\n         ;++ into a comment and thereby invalidate the file's form,\n         ;++ or move random text out of a comment.\n         (delete-char 1))"},"\n        ((",{"c":3,"s":"paredit-in-char-p","i":928},")            ",{"c":3,"s":"; Escape -- delete both chars.\n","i":930},"         (",{"c":3,"s":"backward-delete-char","i":932}," ",{"c":3,"s":"1","i":934},")\n         (",{"c":3,"s":"delete-char","i":936}," ",{"c":3,"s":"1","i":938},"))\n        ((",{"c":3,"s":"eq","i":534}," (",{"c":3,"s":"char-after","i":536},") ",{"c":3,"s":"?\\\\","i":538}," )         ",{"c":3,"s":"; ditto\n","i":540},"         (",{"c":3,"s":"delete-char","i":542}," ",{"c":3,"s":"2","i":544},"))\n        ((",{"c":3,"s":"let","i":434}," ((",{"c":3,"s":"syn","i":436}," (",{"c":3,"s":"char-syntax","i":438}," (",{"c":3,"s":"char-after","i":440},"))))\n           (",{"c":3,"s":"or","i":442}," (",{"c":3,"s":"eq","i":444}," ",{"c":3,"s":"syn","i":446}," ",{"c":3,"s":"?\\(","i":448}," )\n               (",{"c":3,"s":"eq","i":450}," ",{"c":3,"s":"syn","i":452}," ",{"c":3,"s":"?\\\"","i":454}," )))\n         ",{"c":0,"s":"(forward-char)"},")\n        ((",{"c":3,"s":"and","i":312}," (",{"c":3,"s":"not","i":314}," (",{"c":3,"s":"paredit-in-char-p","i":316}," (",{"c":3,"s":"1-","i":318}," (",{"c":3,"s":"point","i":320},"))))\n              (",{"c":3,"s":"eq","i":322}," (",{"c":3,"s":"char-syntax","i":324}," (",{"c":3,"s":"char-after","i":326},")) ",{"c":3,"s":"?\\)","i":328}," )\n              (",{"c":3,"s":"eq","i":330}," (",{"c":3,"s":"char-before","i":332},") (",{"c":3,"s":"matching-paren","i":334}," (",{"c":3,"s":"char-after","i":336},"))))\n         (",{"c":3,"s":"backward-delete-char","i":338}," ",{"c":3,"s":"1","i":340},")       ",{"c":3,"s":"; Empty list -- delete both\n","i":342},"         (",{"c":3,"s":"delete-char","i":344}," ",{"c":3,"s":"1","i":346},"))               ",{"c":0,"s":";   delimiters.\n"},"        ",{"c":0,"s":";; Just delete a single character, if it's not a closing\n"},"        ",{"c":0,"s":";; parenthesis.  (The character literal case is already\n"},"        ",{"c":0,"s":";; handled by now.)\n"},"        ((",{"c":3,"s":"not","i":260}," (",{"c":3,"s":"eq","i":262}," (",{"c":3,"s":"char-syntax","i":264}," (",{"c":3,"s":"char-after","i":266},")) ",{"c":3,"s":"?\\)","i":268}," ))\n         (",{"c":3,"s":"delete-char","i":270}," ",{"c":3,"s":"1","i":272},"))))\n\n(",{"c":5,"s":"defun","i":2764}," ",{"c":5,"s":"paredit-forward-delete-in-string","i":2766}," ()\n  (",{"c":5,"s":"let","i":2768}," ((",{"c":5,"s":"start+end","i":2770}," (",{"c":5,"s":"paredit-string-start+end-points","i":2772},")))\n    (",{"c":5,"s":"cond","i":2774}," ((",{"c":5,"s":"not","i":2776}," (",{"c":5,"s":"eq","i":2778}," (",{"c":5,"s":"point","i":2780},") (",{"c":5,"s":"cdr","i":2782}," ",{"c":5,"s":"start+end","i":2784},")))\n           ",{"c":5,"s":";; If it's not the close-quote, it's safe to delete.  But\n","i":2786},"           ",{"c":5,"s":";; first handle the case that we're in a string escape.\n","i":2788},"           (",{"c":5,"s":"cond","i":2790}," ((",{"c":5,"s":"paredit-in-string-escape-p","i":2792},")\n                  ",{"c":5,"s":";; We're right after the backslash, so backward\n","i":2794},"                  ",{"c":5,"s":";; delete it before deleting the escaped character.\n","i":2796},"                  (",{"c":5,"s":"backward-delete-char","i":2798}," ",{"c":5,"s":"1","i":2800},"))\n                 ((",{"c":5,"s":"eq","i":2802}," (",{"c":5,"s":"char-after","i":2804},") ",{"c":5,"s":"?\\\\","i":2806}," )\n                  ",{"c":5,"s":";; If we're not in a string escape, but we are on a\n","i":2808},"                  ",{"c":5,"s":";; backslash, it must start the escape for the next\n","i":2810},"                  ",{"c":5,"s":";; character, so delete the backslash before deleting\n","i":2812},"                  ",{"c":5,"s":";; the next character.\n","i":2814},"                  (",{"c":5,"s":"delete-char","i":2816}," ",{"c":5,"s":"1","i":2818},")))\n           (",{"c":5,"s":"delete-char","i":2820}," ",{"c":5,"s":"1","i":2822},"))\n          ((",{"c":5,"s":"eq","i":2824}," (",{"c":5,"s":"1-","i":2826}," (",{"c":5,"s":"point","i":2828},")) (",{"c":5,"s":"car","i":2830}," ",{"c":5,"s":"start+end","i":2832},"))\n           ",{"c":5,"s":";; If it is the close-quote, delete only if we're also right\n","i":2834},"           ",{"c":5,"s":";; past the open-quote (i.e. it's empty), and then delete\n","i":2836},"           ",{"c":5,"s":";; both quotes.  Otherwise we refuse to delete it.\n","i":2838},"           (",{"c":5,"s":"backward-delete-char","i":2840}," ",{"c":5,"s":"1","i":2842},")\n           (",{"c":5,"s":"delete-char","i":2844}," ",{"c":5,"s":"1","i":2846},")))))\n\n(",{"c":5,"s":"defun","i":2848}," ",{"c":5,"s":"paredit-backward-delete","i":2850}," ",{"c":0,"s":"(&optional arg)"},"\n  ",{"c":0,"s":"\"Delete a character backward or move backward over a delimiter.\nIf on a closing S-expression delimiter, move backward into the\n  S-expression.\nIf on an opening S-expression delimiter, refuse to delete unless the\n  S-expression is empty, in which case delete the whole S-expression.\nWith a prefix argument, simply delete a character backward, without\n  regard for delimiter balancing.\""},"\n  (",{"c":5,"s":"interactive","i":2852}," ",{"c":5,"s":"\"P\"","i":2854},")\n  (",{"c":0,"s":"cond"}," ",{"c":0,"s":"((or arg (bobp))\n         (backward-delete-char 1))"},"      ",{"c":0,"s":";++ should this untabify?\n"},"        ",{"c":0,"s":"((paredit-in-string-p)\n         (paredit-backward-delete-in-string))"},"\n        ",{"c":0,"s":"((paredit-in-comment-p)\n         (backward-delete-char 1))"},"\n        ((",{"c":3,"s":"paredit-in-char-p","i":940},")            ",{"c":3,"s":"; Escape -- delete both chars.\n","i":942},"         (",{"c":3,"s":"backward-delete-char","i":944}," ",{"c":3,"s":"1","i":946},")\n         (",{"c":3,"s":"delete-char","i":948}," ",{"c":3,"s":"1","i":950},"))\n        ((",{"c":3,"s":"paredit-in-char-p","i":546}," (",{"c":3,"s":"1-","i":548}," (",{"c":3,"s":"point","i":550},")))\n         (",{"c":3,"s":"backward-delete-char","i":552}," ",{"c":3,"s":"2","i":554},"))      ",{"c":0,"s":"; ditto\n"},"        ((",{"c":3,"s":"let","i":456}," ((",{"c":3,"s":"syn","i":458}," (",{"c":3,"s":"char-syntax","i":460}," (",{"c":3,"s":"char-before","i":462},"))))\n           (",{"c":3,"s":"or","i":464}," (",{"c":3,"s":"eq","i":466}," ",{"c":3,"s":"syn","i":468}," ",{"c":3,"s":"?\\)","i":470}," )\n               (",{"c":3,"s":"eq","i":472}," ",{"c":3,"s":"syn","i":474}," ",{"c":3,"s":"?\\\"","i":476}," )))\n         ",{"c":0,"s":"(backward-char)"},")\n        ((",{"c":3,"s":"and","i":348}," (",{"c":3,"s":"eq","i":350}," (",{"c":3,"s":"char-syntax","i":352}," (",{"c":3,"s":"char-before","i":354},")) ",{"c":3,"s":"?\\(","i":356}," )\n              (",{"c":3,"s":"eq","i":358}," (",{"c":3,"s":"char-after","i":360},") (",{"c":3,"s":"matching-paren","i":362}," (",{"c":3,"s":"char-before","i":364},"))))\n         (",{"c":3,"s":"backward-delete-char","i":366}," ",{"c":3,"s":"1","i":368},")       ",{"c":3,"s":"; Empty list -- delete both\n","i":370},"         (",{"c":3,"s":"delete-char","i":372}," ",{"c":3,"s":"1","i":374},"))               ",{"c":0,"s":";   delimiters.\n"},"        ",{"c":0,"s":";; Delete it, unless it's an opening parenthesis.  The case\n"},"        ",{"c":0,"s":";; of character literals is already handled by now.\n"},"        ((",{"c":3,"s":"not","i":274}," (",{"c":3,"s":"eq","i":276}," (",{"c":3,"s":"char-syntax","i":278}," (",{"c":3,"s":"char-before","i":280},")) ",{"c":3,"s":"?\\(","i":282}," ))\n         (",{"c":3,"s":"backward-delete-char-untabify","i":284}," ",{"c":3,"s":"1","i":286},"))))\n\n(",{"c":5,"s":"defun","i":2856}," ",{"c":5,"s":"paredit-backward-delete-in-string","i":2858}," ()\n  (",{"c":5,"s":"let","i":2860}," ((",{"c":5,"s":"start+end","i":2862}," (",{"c":5,"s":"paredit-string-start+end-points","i":2864},")))\n    (",{"c":5,"s":"cond","i":2866}," ((",{"c":5,"s":"not","i":2868}," (",{"c":5,"s":"eq","i":2870}," (",{"c":5,"s":"1-","i":2872}," (",{"c":5,"s":"point","i":2874},")) (",{"c":5,"s":"car","i":2876}," ",{"c":5,"s":"start+end","i":2878},")))\n           ",{"c":5,"s":";; If it's not the open-quote, it's safe to delete.\n","i":2880},"           (",{"c":5,"s":"if","i":2882}," (",{"c":5,"s":"paredit-in-string-escape-p","i":2884},")\n               ",{"c":5,"s":";; If we're on a string escape, since we're about to\n","i":2886},"               ",{"c":5,"s":";; delete the backslash, we must first delete the\n","i":2888},"               ",{"c":5,"s":";; escaped char.\n","i":2890},"               (",{"c":5,"s":"delete-char","i":2892}," ",{"c":5,"s":"1","i":2894},"))\n           (",{"c":5,"s":"backward-delete-char","i":2896}," ",{"c":5,"s":"1","i":2898},")\n           (",{"c":5,"s":"if","i":2900}," (",{"c":5,"s":"paredit-in-string-escape-p","i":2902},")\n               ",{"c":5,"s":";; If, after deleting a character, we find ourselves in\n","i":2904},"               ",{"c":5,"s":";; a string escape, we must have deleted the escaped\n","i":2906},"               ",{"c":5,"s":";; character, and the backslash is behind the point, so\n","i":2908},"               ",{"c":5,"s":";; backward delete it.\n","i":2910},"               (",{"c":5,"s":"backward-delete-char","i":2912}," ",{"c":5,"s":"1","i":2914},")))\n          ((",{"c":5,"s":"eq","i":2916}," (",{"c":5,"s":"point","i":2918},") (",{"c":5,"s":"cdr","i":2920}," ",{"c":5,"s":"start+end","i":2922},"))\n           ",{"c":5,"s":";; If it is the open-quote, delete only if we're also right\n","i":2924},"           ",{"c":5,"s":";; past the close-quote (i.e. it's empty), and then delete\n","i":2926},"           ",{"c":5,"s":";; both quotes.  Otherwise we refuse to delete it.\n","i":2928},"           (",{"c":5,"s":"backward-delete-char","i":2930}," ",{"c":5,"s":"1","i":2932},")\n           (",{"c":5,"s":"delete-char","i":2934}," ",{"c":5,"s":"1","i":2936},")))))\n\n",{"c":5,"s":";;;; Killing\n","i":2938},"\n(",{"c":5,"s":"defun","i":2940}," ",{"c":5,"s":"paredit-kill","i":2942}," ",{"c":0,"s":"(&optional arg)"},"\n  ",{"c":0,"s":"\"Kill a line as if with `kill-line', but respecting delimiters.\nIn a string, act exactly as `kill-line' but do not kill past the\n  closing string delimiter.\nOn a line with no S-expressions on it starting after the point or\n  within a comment, act exactly as `kill-line'.\nOtherwise, kill all S-expressions that start after the point.\""},"\n  (",{"c":5,"s":"interactive","i":2944}," ",{"c":5,"s":"\"P\"","i":2946},")\n  ",{"c":0,"s":"(cond (arg (kill-line))\n        ((paredit-in-string-p)\n         (paredit-kill-line-in-string))\n        ((or (paredit-in-comment-p)\n             (save-excursion\n               (paredit-skip-whitespace t (point-at-eol))\n               (or (eq (char-after) ?\\; )\n                   (eolp))))\n         ;** Be careful about trailing backslashes.\n         (kill-line))\n        (t (paredit-kill-sexps-on-line)))"},")\n\n(",{"c":5,"s":"defun","i":2948}," ",{"c":5,"s":"paredit-kill-line-in-string","i":2950}," ()\n  (",{"c":0,"s":"if"}," (",{"c":3,"s":"save-excursion","i":952}," (",{"c":3,"s":"paredit-skip-whitespace","i":954}," ",{"c":3,"s":"t","i":956}," (",{"c":3,"s":"point-at-eol","i":958},"))\n                      (",{"c":3,"s":"eolp","i":960},"))\n      ",{"c":0,"s":"(kill-line)"},"\n    ",{"c":0,"s":"(save-excursion\n      ;; Be careful not to split an escape sequence.\n      (if (paredit-in-string-escape-p)\n          (backward-char))\n      (let ((beginning (point)))\n        (while (not (or (eolp)\n                        (eq (char-after) ?\\\" )))\n          (forward-char)\n          ;; Skip past escaped characters.\n          (if (eq (char-before) ?\\\\ )\n              (forward-char)))\n        (kill-region beginning (point))))"},"))\n\n(",{"c":5,"s":"defun","i":2952}," ",{"c":5,"s":"paredit-kill-sexps-on-line","i":2954}," ()\n  (",{"c":5,"s":"if","i":2956}," (",{"c":5,"s":"paredit-in-char-p","i":2958},")               ",{"c":5,"s":"; Move past the \\ and prefix.\n","i":2960},"      (",{"c":5,"s":"backward-char","i":2962}," ",{"c":5,"s":"2","i":2964},"))                ",{"c":5,"s":"; (# in Scheme/CL, ? in elisp)\n","i":2966},"  (",{"c":5,"s":"let","i":2968}," ((",{"c":5,"s":"beginning","i":2970}," (",{"c":5,"s":"point","i":2972},"))\n        (",{"c":5,"s":"eol","i":2974}," (",{"c":5,"s":"point-at-eol","i":2976},")))\n    (",{"c":5,"s":"let","i":2978}," ((",{"c":5,"s":"end-of-list-p","i":2980}," (",{"c":5,"s":"paredit-forward-sexps-to-kill","i":2982}," ",{"c":5,"s":"beginning","i":2984}," ",{"c":5,"s":"eol","i":2986},")))\n      ",{"c":5,"s":";; If we got to the end of the list and it's on the same line,\n","i":2988},"      ",{"c":5,"s":";; move backward past the closing delimiter before killing.  (This\n","i":2990},"      ",{"c":5,"s":";; allows something like killing the whitespace in (    ).)\n","i":2992},"      (",{"c":5,"s":"if","i":2994}," ",{"c":5,"s":"end-of-list-p","i":2996}," (",{"c":5,"s":"progn","i":2998}," (",{"c":5,"s":"up-list","i":3000},") (",{"c":5,"s":"backward-char","i":3002},")))\n      (",{"c":5,"s":"if","i":3004}," ",{"c":5,"s":"kill-whole-line","i":3006},"\n          (",{"c":5,"s":"paredit-kill-sexps-on-whole-line","i":3008}," ",{"c":5,"s":"beginning","i":3010},")\n        (",{"c":5,"s":"kill-region","i":3012}," ",{"c":5,"s":"beginning","i":3014},"\n                     ",{"c":5,"s":";; If all of the S-expressions were on one line,\n","i":3016},"                     ",{"c":5,"s":";; i.e. we're still on that line after moving past\n","i":3018},"                     ",{"c":5,"s":";; the last one, kill the whole line, including\n","i":3020},"                     ",{"c":5,"s":";; any comments; otherwise just kill to the end of\n","i":3022},"                     ",{"c":5,"s":";; the last S-expression we found.  Be sure,\n","i":3024},"                     ",{"c":5,"s":";; though, not to kill any closing parentheses.\n","i":3026},"                     (",{"c":5,"s":"if","i":3028}," (",{"c":5,"s":"and","i":3030}," (",{"c":5,"s":"not","i":3032}," ",{"c":5,"s":"end-of-list-p","i":3034},")\n                              (",{"c":5,"s":"eq","i":3036}," (",{"c":5,"s":"point-at-eol","i":3038},") ",{"c":5,"s":"eol","i":3040},"))\n                         ",{"c":5,"s":"eol","i":3042},"\n                         (",{"c":5,"s":"point","i":3044},")))))))\n\n",{"c":5,"s":";;; Please do not try to understand this code unless you have a VERY\n","i":3046},{"c":5,"s":";;; good reason to do so.  I gave up trying to figure it out well\n","i":3048},{"c":5,"s":";;; enough to explain it, long ago.\n","i":3050},"\n(",{"c":5,"s":"defun","i":3052}," ",{"c":5,"s":"paredit-forward-sexps-to-kill","i":3054}," (",{"c":5,"s":"beginning","i":3056}," ",{"c":5,"s":"eol","i":3058},")\n  (",{"c":5,"s":"let","i":3060}," ((",{"c":5,"s":"end-of-list-p","i":3062}," ",{"c":5,"s":"nil","i":3064},")\n        (",{"c":5,"s":"firstp","i":3066}," ",{"c":5,"s":"t","i":3068},"))\n    ",{"c":5,"s":";; Move to the end of the last S-expression that started on this\n","i":3070},"    ",{"c":5,"s":";; line, or to the closing delimiter if the last S-expression in\n","i":3072},"    ",{"c":5,"s":";; this list is on the line.\n","i":3074},"    (",{"c":5,"s":"catch","i":3076}," ",{"c":5,"s":"'","i":3078},{"c":5,"s":"return","i":3080},"\n      (",{"c":5,"s":"while","i":3082}," ",{"c":5,"s":"t","i":3084},"\n        ",{"c":5,"s":";; This and the `kill-whole-line' business below fix a bug that\n","i":3086},"        ",{"c":5,"s":";; inhibited any S-expression at the very end of the buffer\n","i":3088},"        ",{"c":5,"s":";; (with no trailing newline) from being deleted.  It's a\n","i":3090},"        ",{"c":5,"s":";; bizarre fix that I ought to document at some point, but I am\n","i":3092},"        ",{"c":5,"s":";; too busy at the moment to do so.\n","i":3094},"        (",{"c":5,"s":"if","i":3096}," (",{"c":5,"s":"and","i":3098}," ",{"c":5,"s":"kill-whole-line","i":3100}," (",{"c":5,"s":"eobp","i":3102},")) (",{"c":5,"s":"throw","i":3104}," ",{"c":5,"s":"'","i":3106},{"c":5,"s":"return","i":3108}," ",{"c":5,"s":"nil","i":3110},"))\n        (",{"c":5,"s":"save-excursion","i":3112},"\n          (",{"c":5,"s":"paredit-handle-sexp-errors","i":3114}," (",{"c":5,"s":"forward-sexp","i":3116},")\n            (",{"c":5,"s":"up-list","i":3118},")\n            (",{"c":5,"s":"setq","i":3120}," ",{"c":5,"s":"end-of-list-p","i":3122}," (",{"c":5,"s":"eq","i":3124}," (",{"c":5,"s":"point-at-eol","i":3126},") ",{"c":5,"s":"eol","i":3128},"))\n            (",{"c":5,"s":"throw","i":3130}," ",{"c":5,"s":"'","i":3132},{"c":5,"s":"return","i":3134}," ",{"c":5,"s":"nil","i":3136},"))\n          (",{"c":5,"s":"if","i":3138}," (",{"c":5,"s":"or","i":3140}," (",{"c":5,"s":"and","i":3142}," (",{"c":5,"s":"not","i":3144}," ",{"c":5,"s":"firstp","i":3146},")\n                       (",{"c":5,"s":"not","i":3148}," ",{"c":5,"s":"kill-whole-line","i":3150},")\n                       (",{"c":5,"s":"eobp","i":3152},"))\n                  (",{"c":5,"s":"paredit-handle-sexp-errors","i":3154},"\n                      (",{"c":5,"s":"progn","i":3156}," (",{"c":5,"s":"backward-sexp","i":3158},") ",{"c":5,"s":"nil","i":3160},")\n                    ",{"c":5,"s":"t","i":3162},")\n                  (",{"c":5,"s":"not","i":3164}," (",{"c":5,"s":"eq","i":3166}," (",{"c":5,"s":"point-at-eol","i":3168},") ",{"c":5,"s":"eol","i":3170},")))\n              (",{"c":5,"s":"throw","i":3172}," ",{"c":5,"s":"'","i":3174},{"c":5,"s":"return","i":3176}," ",{"c":5,"s":"nil","i":3178},")))\n        (",{"c":5,"s":"forward-sexp","i":3180},")\n        (",{"c":5,"s":"if","i":3182}," (",{"c":5,"s":"and","i":3184}," ",{"c":5,"s":"firstp","i":3186},"\n                 (",{"c":5,"s":"not","i":3188}," ",{"c":5,"s":"kill-whole-line","i":3190},")\n                 (",{"c":5,"s":"eobp","i":3192},"))\n            (",{"c":5,"s":"throw","i":3194}," ",{"c":5,"s":"'","i":3196},{"c":5,"s":"return","i":3198}," ",{"c":5,"s":"nil","i":3200},"))\n        (",{"c":5,"s":"setq","i":3202}," ",{"c":5,"s":"firstp","i":3204}," ",{"c":5,"s":"nil","i":3206},")))\n    ",{"c":5,"s":"end-of-list-p","i":3208},"))\n\n(",{"c":5,"s":"defun","i":3210}," ",{"c":5,"s":"paredit-kill-sexps-on-whole-line","i":3212}," (",{"c":5,"s":"beginning","i":3214},")\n  (",{"c":5,"s":"kill-region","i":3216}," ",{"c":5,"s":"beginning","i":3218},"\n               (",{"c":5,"s":"or","i":3220}," (",{"c":5,"s":"save-excursion","i":3222},"     ",{"c":5,"s":"; Delete trailing indentation...\n","i":3224},"                     (",{"c":5,"s":"paredit-skip-whitespace","i":3226}," ",{"c":5,"s":"t","i":3228},")\n                     (",{"c":5,"s":"and","i":3230}," (",{"c":5,"s":"not","i":3232}," (",{"c":5,"s":"eq","i":3234}," (",{"c":5,"s":"char-after","i":3236},") ",{"c":5,"s":"?\\;","i":3238}," ))\n                          (",{"c":5,"s":"point","i":3240},")))\n                   ",{"c":5,"s":";; ...or just use the point past the newline, if\n","i":3242},"                   ",{"c":5,"s":";; we encounter a comment.\n","i":3244},"                   (",{"c":5,"s":"point-at-eol","i":3246},")))\n  (",{"c":5,"s":"cond","i":3248}," ((",{"c":5,"s":"save-excursion","i":3250}," (",{"c":5,"s":"paredit-skip-whitespace","i":3252}," ",{"c":5,"s":"nil","i":3254}," (",{"c":5,"s":"point-at-bol","i":3256},"))\n                         (",{"c":5,"s":"bolp","i":3258},"))\n         ",{"c":5,"s":";; Nothing but indentation before the point, so indent it.\n","i":3260},"         (",{"c":5,"s":"lisp-indent-line","i":3262},"))\n        ((",{"c":5,"s":"eobp","i":3264},") ",{"c":5,"s":"nil","i":3266},")       ",{"c":5,"s":"; Protect the CHAR-SYNTAX below against NIL.\n","i":3268},"        ",{"c":5,"s":";; Insert a space to avoid invalid joining if necessary.\n","i":3270},"        ((",{"c":5,"s":"let","i":3272}," ((",{"c":5,"s":"syn-before","i":3274}," (",{"c":5,"s":"char-syntax","i":3276}," (",{"c":5,"s":"char-before","i":3278},")))\n               (",{"c":5,"s":"syn-after","i":3280},"  (",{"c":5,"s":"char-syntax","i":3282}," (",{"c":5,"s":"char-after","i":3284},"))))\n           (",{"c":5,"s":"or","i":3286}," (",{"c":5,"s":"and","i":3288}," (",{"c":5,"s":"eq","i":3290}," ",{"c":5,"s":"syn-before","i":3292}," ",{"c":5,"s":"?\\)","i":3294}," )            ",{"c":5,"s":"; Separate opposing\n","i":3296},"                    (",{"c":5,"s":"eq","i":3298}," ",{"c":5,"s":"syn-after","i":3300},"  ",{"c":5,"s":"?\\(","i":3302}," ))           ",{"c":5,"s":";   parentheses,\n","i":3304},"               (",{"c":5,"s":"and","i":3306}," (",{"c":5,"s":"eq","i":3308}," ",{"c":5,"s":"syn-before","i":3310}," ",{"c":5,"s":"?\\\"","i":3312}," )            ",{"c":5,"s":"; string delimiter\n","i":3314},"                    (",{"c":5,"s":"eq","i":3316}," ",{"c":5,"s":"syn-after","i":3318},"  ",{"c":5,"s":"?\\\"","i":3320}," ))           ",{"c":5,"s":";   pairs,\n","i":3322},"               (",{"c":5,"s":"and","i":3324}," (",{"c":5,"s":"memq","i":3326}," ",{"c":5,"s":"syn-before","i":3328}," ",{"c":5,"s":"'","i":3330},"(",{"c":5,"s":"?_","i":3332}," ",{"c":5,"s":"?w","i":3334},"))      ",{"c":5,"s":"; or word or symbol\n","i":3336},"                    (",{"c":5,"s":"memq","i":3338}," ",{"c":5,"s":"syn-after","i":3340},"  ",{"c":5,"s":"'","i":3342},"(",{"c":5,"s":"?_","i":3344}," ",{"c":5,"s":"?w","i":3346},")))))   ",{"c":5,"s":";   constituents.\n","i":3348},"         (",{"c":5,"s":"insert","i":3350}," ",{"c":5,"s":"\" \"","i":3352},"))))\n\n",{"c":5,"s":";;;;; Killing Words\n","i":3354},"\n",{"c":5,"s":";;; This is tricky and asymmetrical because backward parsing is\n","i":3356},{"c":5,"s":";;; extraordinarily difficult or impossible, so we have to implement\n","i":3358},{"c":5,"s":";;; killing in both directions by parsing forward.\n","i":3360},"\n(",{"c":5,"s":"defun","i":3362}," ",{"c":5,"s":"paredit-forward-kill-word","i":3364}," ()\n  ",{"c":5,"s":"\"Kill a word forward, skipping over intervening delimiters.\"","i":3366},"\n  (",{"c":5,"s":"interactive","i":3368},")\n  (",{"c":5,"s":"let","i":3370}," ((",{"c":5,"s":"beginning","i":3372}," (",{"c":5,"s":"point","i":3374},")))\n    (",{"c":5,"s":"skip-syntax-forward","i":3376}," ",{"c":5,"s":"\" -\"","i":3378},")\n    (",{"c":5,"s":"let*","i":3380}," ((",{"c":5,"s":"parse-state","i":3382}," (",{"c":5,"s":"paredit-current-parse-state","i":3384},"))\n           (",{"c":5,"s":"state","i":3386}," (",{"c":5,"s":"paredit-kill-word-state","i":3388}," ",{"c":5,"s":"parse-state","i":3390}," ",{"c":5,"s":"'","i":3392},{"c":5,"s":"char-after","i":3394},")))\n      (",{"c":5,"s":"while","i":3396}," (",{"c":5,"s":"not","i":3398}," (",{"c":5,"s":"or","i":3400}," (",{"c":5,"s":"eobp","i":3402},")\n                      (",{"c":5,"s":"eq","i":3404}," ",{"c":5,"s":"?w","i":3406}," (",{"c":5,"s":"char-syntax","i":3408}," (",{"c":5,"s":"char-after","i":3410},")))))\n        (",{"c":5,"s":"setq","i":3412}," ",{"c":5,"s":"parse-state","i":3414},"\n              (",{"c":5,"s":"progn","i":3416}," (",{"c":5,"s":"forward-char","i":3418}," ",{"c":5,"s":"1","i":3420},") (",{"c":5,"s":"paredit-current-parse-state","i":3422},"))\n",{"c":5,"s":";;               (parse-partial-sexp (point) (1+ (point))\n","i":3424},{"c":5,"s":";;                                   nil nil parse-state)\n","i":3426},"              )\n        (",{"c":5,"s":"let*","i":3428}," ((",{"c":5,"s":"old-state","i":3430}," ",{"c":5,"s":"state","i":3432},")\n               (",{"c":5,"s":"new-state","i":3434},"\n                (",{"c":5,"s":"paredit-kill-word-state","i":3436}," ",{"c":5,"s":"parse-state","i":3438}," ",{"c":5,"s":"'","i":3440},{"c":5,"s":"char-after","i":3442},")))\n          (",{"c":5,"s":"cond","i":3444}," ((",{"c":5,"s":"not","i":3446}," (",{"c":5,"s":"eq","i":3448}," ",{"c":5,"s":"old-state","i":3450}," ",{"c":5,"s":"new-state","i":3452},"))\n                 (",{"c":5,"s":"setq","i":3454}," ",{"c":5,"s":"parse-state","i":3456},"\n                       (",{"c":5,"s":"paredit-kill-word-hack","i":3458}," ",{"c":5,"s":"old-state","i":3460},"\n                                               ",{"c":5,"s":"new-state","i":3462},"\n                                               ",{"c":5,"s":"parse-state","i":3464},"))\n                 (",{"c":5,"s":"setq","i":3466}," ",{"c":5,"s":"state","i":3468},"\n                       (",{"c":5,"s":"paredit-kill-word-state","i":3470}," ",{"c":5,"s":"parse-state","i":3472},"\n                                                ",{"c":5,"s":"'","i":3474},{"c":5,"s":"char-after","i":3476},"))\n                 (",{"c":5,"s":"setq","i":3478}," ",{"c":5,"s":"beginning","i":3480}," (",{"c":5,"s":"point","i":3482},")))))))\n    (",{"c":5,"s":"goto-char","i":3484}," ",{"c":5,"s":"beginning","i":3486},")\n    (",{"c":5,"s":"kill-word","i":3488}," ",{"c":5,"s":"1","i":3490},")))\n\n(",{"c":5,"s":"defun","i":3492}," ",{"c":5,"s":"paredit-backward-kill-word","i":3494}," ()\n  ",{"c":5,"s":"\"Kill a word backward, skipping over any intervening delimiters.\"","i":3496},"\n  (",{"c":5,"s":"interactive","i":3498},")\n  (",{"c":5,"s":"if","i":3500}," (",{"c":5,"s":"not","i":3502}," (",{"c":5,"s":"or","i":3504}," (",{"c":5,"s":"bobp","i":3506},")\n               (",{"c":5,"s":"eq","i":3508}," (",{"c":5,"s":"char-syntax","i":3510}," (",{"c":5,"s":"char-before","i":3512},")) ",{"c":5,"s":"?w","i":3514},")))\n      (",{"c":5,"s":"let","i":3516}," ((",{"c":5,"s":"end","i":3518}," (",{"c":5,"s":"point","i":3520},")))\n        (",{"c":5,"s":"backward-word","i":3522}," ",{"c":5,"s":"1","i":3524},")\n        (",{"c":5,"s":"forward-word","i":3526}," ",{"c":5,"s":"1","i":3528},")\n        (",{"c":5,"s":"goto-char","i":3530}," (",{"c":5,"s":"min","i":3532}," ",{"c":5,"s":"end","i":3534}," (",{"c":5,"s":"point","i":3536},")))\n        (",{"c":5,"s":"let*","i":3538}," ((",{"c":5,"s":"parse-state","i":3540}," (",{"c":5,"s":"paredit-current-parse-state","i":3542},"))\n               (",{"c":5,"s":"state","i":3544},"\n                (",{"c":5,"s":"paredit-kill-word-state","i":3546}," ",{"c":5,"s":"parse-state","i":3548}," ",{"c":5,"s":"'","i":3550},{"c":5,"s":"char-before","i":3552},")))\n          (",{"c":5,"s":"while","i":3554}," (",{"c":5,"s":"and","i":3556}," (",{"c":5,"s":"<","i":3558}," (",{"c":5,"s":"point","i":3560},") ",{"c":5,"s":"end","i":3562},")\n                      (",{"c":5,"s":"progn","i":3564},"\n                        (",{"c":5,"s":"setq","i":3566}," ",{"c":5,"s":"parse-state","i":3568},"\n                              (",{"c":5,"s":"parse-partial-sexp","i":3570}," (",{"c":5,"s":"point","i":3572},") (",{"c":5,"s":"1+","i":3574}," (",{"c":5,"s":"point","i":3576},"))\n                                                  ",{"c":5,"s":"nil","i":3578}," ",{"c":5,"s":"nil","i":3580}," ",{"c":5,"s":"parse-state","i":3582},"))\n                        (",{"c":5,"s":"or","i":3584}," (",{"c":5,"s":"eq","i":3586}," ",{"c":5,"s":"state","i":3588},"\n                                (",{"c":5,"s":"paredit-kill-word-state","i":3590}," ",{"c":5,"s":"parse-state","i":3592},"\n                                                         ",{"c":5,"s":"'","i":3594},{"c":5,"s":"char-before","i":3596},"))\n                            (",{"c":5,"s":"progn","i":3598}," (",{"c":5,"s":"backward-char","i":3600}," ",{"c":5,"s":"1","i":3602},") ",{"c":5,"s":"nil","i":3604},")))))\n          (",{"c":5,"s":"if","i":3606}," (",{"c":5,"s":"and","i":3608}," (",{"c":5,"s":"eq","i":3610}," ",{"c":5,"s":"state","i":3612}," ",{"c":5,"s":"'","i":3614},{"c":5,"s":"comment","i":3616},")\n                   (",{"c":5,"s":"eq","i":3618}," ",{"c":5,"s":"?\\#","i":3620}," (",{"c":5,"s":"char-after","i":3622}," (",{"c":5,"s":"point","i":3624},")))\n                   (",{"c":5,"s":"eq","i":3626}," ",{"c":5,"s":"?\\|","i":3628}," (",{"c":5,"s":"char-before","i":3630}," (",{"c":5,"s":"point","i":3632},"))))\n              (",{"c":5,"s":"backward-char","i":3634}," ",{"c":5,"s":"1","i":3636},")))))\n  (",{"c":5,"s":"backward-kill-word","i":3638}," ",{"c":5,"s":"1","i":3640},"))\n\n",{"c":0,"s":";;; Word-Killing Auxiliaries\n"},"\n(",{"c":5,"s":"defun","i":3642}," ",{"c":5,"s":"paredit-kill-word-state","i":3644}," (",{"c":5,"s":"parse-state","i":3646}," ",{"c":5,"s":"adjacent-char-fn","i":3648},")\n  (",{"c":5,"s":"cond","i":3650}," ((",{"c":5,"s":"paredit-in-comment-p","i":3652}," ",{"c":5,"s":"parse-state","i":3654},") ",{"c":5,"s":"'","i":3656},{"c":5,"s":"comment","i":3658},")\n        ((",{"c":5,"s":"paredit-in-string-p","i":3660},"  ",{"c":5,"s":"parse-state","i":3662},") ",{"c":5,"s":"'","i":3664},{"c":5,"s":"string","i":3666},")\n        ((",{"c":5,"s":"memq","i":3668}," (",{"c":5,"s":"char-syntax","i":3670}," (",{"c":5,"s":"funcall","i":3672}," ",{"c":5,"s":"adjacent-char-fn","i":3674},"))\n               ",{"c":5,"s":"'","i":3676},"(",{"c":5,"s":"?\\(","i":3678}," ",{"c":5,"s":"?\\)","i":3680}," ))\n         ",{"c":5,"s":"'","i":3682},{"c":5,"s":"delimiter","i":3684},")\n        (",{"c":5,"s":"t","i":3686}," ",{"c":5,"s":"'","i":3688},{"c":5,"s":"other","i":3690},")))\n\n",{"c":5,"s":";;; This optionally advances the point past any comment delimiters that\n","i":3692},{"c":5,"s":";;; should probably not be touched, based on the last state change and\n","i":3694},{"c":5,"s":";;; the characters around the point.  It returns a new parse state,\n","i":3696},{"c":5,"s":";;; starting from the PARSE-STATE parameter.\n","i":3698},"\n(",{"c":5,"s":"defun","i":3700}," ",{"c":5,"s":"paredit-kill-word-hack","i":3702}," (",{"c":5,"s":"old-state","i":3704}," ",{"c":5,"s":"new-state","i":3706}," ",{"c":5,"s":"parse-state","i":3708},")\n  (",{"c":5,"s":"cond","i":3710}," ((",{"c":5,"s":"and","i":3712}," (",{"c":5,"s":"not","i":3714}," (",{"c":5,"s":"eq","i":3716}," ",{"c":5,"s":"old-state","i":3718}," ",{"c":5,"s":"'","i":3720},{"c":5,"s":"comment","i":3722},"))\n              (",{"c":5,"s":"not","i":3724}," (",{"c":5,"s":"eq","i":3726}," ",{"c":5,"s":"new-state","i":3728}," ",{"c":5,"s":"'","i":3730},{"c":5,"s":"comment","i":3732},"))\n              (",{"c":5,"s":"not","i":3734}," (",{"c":5,"s":"paredit-in-string-escape-p","i":3736},"))\n              (",{"c":5,"s":"eq","i":3738}," ",{"c":5,"s":"?\\#","i":3740}," (",{"c":5,"s":"char-before","i":3742},"))\n              (",{"c":5,"s":"eq","i":3744}," ",{"c":5,"s":"?\\|","i":3746}," (",{"c":5,"s":"char-after","i":3748},")))\n         (",{"c":5,"s":"forward-char","i":3750}," ",{"c":5,"s":"1","i":3752},")\n         (",{"c":5,"s":"paredit-current-parse-state","i":3754},")\n",{"c":5,"s":";;          (parse-partial-sexp (point) (1+ (point))\n","i":3756},{"c":5,"s":";;                              nil nil parse-state)\n","i":3758},"         )\n        ((",{"c":5,"s":"and","i":3760}," (",{"c":5,"s":"not","i":3762}," (",{"c":5,"s":"eq","i":3764}," ",{"c":5,"s":"old-state","i":3766}," ",{"c":5,"s":"'","i":3768},{"c":5,"s":"comment","i":3770},"))\n              (",{"c":5,"s":"eq","i":3772}," ",{"c":5,"s":"new-state","i":3774}," ",{"c":5,"s":"'","i":3776},{"c":5,"s":"comment","i":3778},")\n              (",{"c":5,"s":"eq","i":3780}," ",{"c":5,"s":"?\\;","i":3782}," (",{"c":5,"s":"char-before","i":3784},")))\n         (",{"c":5,"s":"skip-chars-forward","i":3786}," ",{"c":5,"s":"\";\"","i":3788},")\n         (",{"c":5,"s":"paredit-current-parse-state","i":3790},")\n",{"c":5,"s":";;          (parse-partial-sexp (point) (save-excursion\n","i":3792},{"c":5,"s":";;                                        (skip-chars-forward \";\"))\n","i":3794},{"c":5,"s":";;                              nil nil parse-state)\n","i":3796},"         )\n        (",{"c":5,"s":"t","i":3798}," ",{"c":5,"s":"parse-state","i":3800},")))\n\n",{"c":0,"s":";;;; Cursor and Screen Movement\n"},"\n(",{"c":5,"s":"eval-and-compile","i":3802},"\n  (",{"c":5,"s":"defmacro","i":3804}," ",{"c":5,"s":"defun-saving-mark","i":3806}," (",{"c":5,"s":"name","i":3808}," ",{"c":5,"s":"bvl","i":3810}," ",{"c":5,"s":"doc","i":3812}," ",{"c":5,"s":"&rest","i":3814}," ",{"c":5,"s":"body","i":3816},")\n    ",{"c":5,"s":"`","i":3818},"(",{"c":5,"s":"defun","i":3820}," ",{"c":5,"s":",","i":3822},{"c":5,"s":"name","i":3824}," ",{"c":5,"s":",","i":3826},{"c":5,"s":"bvl","i":3828},"\n       ",{"c":5,"s":",","i":3830},{"c":5,"s":"doc","i":3832},"\n       ",{"c":5,"s":",","i":3834},"(",{"c":5,"s":"xcond","i":3836}," ((",{"c":5,"s":"paredit-xemacs-p","i":3838},")\n                ",{"c":5,"s":"'","i":3840},"(",{"c":5,"s":"interactive","i":3842}," ",{"c":5,"s":"\"_\"","i":3844},"))\n               ((",{"c":5,"s":"paredit-gnu-emacs-p","i":3846},")\n                ",{"c":5,"s":"'","i":3848},"(",{"c":5,"s":"interactive","i":3850},")))\n       ",{"c":5,"s":",","i":3852},{"c":5,"s":"@body","i":3854},")))\n\n(",{"c":5,"s":"defun-saving-mark","i":3856}," ",{"c":5,"s":"paredit-forward","i":3858}," ()\n  ",{"c":5,"s":"\"Move forward an S-expression, or up an S-expression forward.\nIf there are no more S-expressions in this one before the closing\n  delimiter, move past that closing delimiter; otherwise, move forward\n  past the S-expression following the point.\"","i":3860},"\n  (",{"c":5,"s":"paredit-handle-sexp-errors","i":3862},"\n      (",{"c":5,"s":"forward-sexp","i":3864},")\n    ",{"c":5,"s":";++ Is it necessary to use UP-LIST and not just FORWARD-CHAR?\n","i":3866},"    (",{"c":5,"s":"if","i":3868}," (",{"c":5,"s":"paredit-in-string-p","i":3870},") (",{"c":5,"s":"forward-char","i":3872},") (",{"c":5,"s":"up-list","i":3874},"))))\n\n(",{"c":5,"s":"defun-saving-mark","i":3876}," ",{"c":5,"s":"paredit-backward","i":3878}," ()\n  ",{"c":5,"s":"\"Move backward an S-expression, or up an S-expression backward.\nIf there are no more S-expressions in this one before the opening\n  delimiter, move past that opening delimiter backward; otherwise, move\n  move backward past the S-expression preceding the point.\"","i":3880},"\n  (",{"c":5,"s":"paredit-handle-sexp-errors","i":3882},"\n      (",{"c":5,"s":"backward-sexp","i":3884},")\n    (",{"c":5,"s":"if","i":3886}," (",{"c":5,"s":"paredit-in-string-p","i":3888},") (",{"c":5,"s":"backward-char","i":3890},") (",{"c":5,"s":"backward-up-list","i":3892},"))))\n\n",{"c":5,"s":";;; Why is this not in lisp.el?\n","i":3894},"\n(",{"c":5,"s":"defun","i":3896}," ",{"c":5,"s":"backward-down-list","i":3898}," (",{"c":5,"s":"&optional","i":3900}," ",{"c":5,"s":"arg","i":3902},")\n  ",{"c":5,"s":"\"Move backward and descend into one level of parentheses.\nWith ARG, do this that many times.\nA negative argument means move forward but still descend a level.\"","i":3904},"\n  (",{"c":5,"s":"interactive","i":3906}," ",{"c":5,"s":"\"p\"","i":3908},")\n  (",{"c":5,"s":"down-list","i":3910}," (",{"c":5,"s":"-","i":3912}," (",{"c":5,"s":"or","i":3914}," ",{"c":5,"s":"arg","i":3916}," ",{"c":5,"s":"1","i":3918},"))))\n\n",{"c":5,"s":";;; Thanks to Marco Baringer for suggesting & writing this function.\n","i":3920},"\n(",{"c":5,"s":"defun","i":3922}," ",{"c":5,"s":"paredit-recentre-on-sexp","i":3924}," (",{"c":5,"s":"&optional","i":3926}," ",{"c":5,"s":"n","i":3928},")\n  ",{"c":5,"s":"\"Recentre the screen on the S-expression following the point.\nWith a prefix argument N, encompass all N S-expressions forward.\"","i":3930},"\n  (",{"c":5,"s":"interactive","i":3932}," ",{"c":5,"s":"\"P\"","i":3934},")\n  (",{"c":5,"s":"save-excursion","i":3936},"\n    (",{"c":5,"s":"forward-sexp","i":3938}," ",{"c":5,"s":"n","i":3940},")\n    (",{"c":5,"s":"let","i":3942}," ((",{"c":5,"s":"end-point","i":3944}," (",{"c":5,"s":"point","i":3946},")))\n      (",{"c":5,"s":"backward-sexp","i":3948}," ",{"c":5,"s":"n","i":3950},")\n      (",{"c":5,"s":"let*","i":3952}," ((",{"c":5,"s":"start-point","i":3954}," (",{"c":5,"s":"point","i":3956},"))\n             (",{"c":5,"s":"start-line","i":3958}," (",{"c":5,"s":"count-lines","i":3960}," (",{"c":5,"s":"point-min","i":3962},") (",{"c":5,"s":"point","i":3964},")))\n             (",{"c":5,"s":"lines-on-sexps","i":3966}," (",{"c":5,"s":"count-lines","i":3968}," ",{"c":5,"s":"start-point","i":3970}," ",{"c":5,"s":"end-point","i":3972},")))\n        (",{"c":5,"s":"goto-line","i":3974}," (",{"c":5,"s":"+","i":3976}," ",{"c":5,"s":"start-line","i":3978}," (",{"c":5,"s":"/","i":3980}," ",{"c":5,"s":"lines-on-sexps","i":3982}," ",{"c":5,"s":"2","i":3984},")))\n        (",{"c":5,"s":"recenter","i":3986},")))))\n\n",{"c":0,"s":";;;; Depth-Changing Commands:  Wrapping, Splicing, & Raising\n"},"\n(",{"c":5,"s":"defun","i":3988}," ",{"c":5,"s":"paredit-wrap-sexp","i":3990}," ",{"c":0,"s":"(&optional n)"},"\n  ",{"c":0,"s":"\"Wrap the following S-expression in a list.\nIf a prefix argument N is given, wrap N S-expressions.\nAutomatically indent the newly wrapped S-expression.\nAs a special case, if the point is at the end of a list, simply insert\n  a pair of parentheses, rather than insert a lone opening parenthesis\n  and then signal an error, in the interest of preserving structure.\""},"\n  (",{"c":5,"s":"interactive","i":3992}," ",{"c":5,"s":"\"P\"","i":3994},")\n  ",{"c":0,"s":"(paredit-handle-sexp-errors\n      (paredit-insert-pair (or n\n                               (and (not (paredit-region-active-p))\n                                    1))\n                           ?\\( ?\\)\n                           'goto-char)\n    (insert ?\\) )\n    (backward-char))"},"\n  (",{"c":5,"s":"save-excursion","i":3996}," (",{"c":5,"s":"backward-up-list","i":3998},") (",{"c":5,"s":"indent-sexp","i":4000},")))\n\n",{"c":0,"s":";;; Thanks to Marco Baringer for the suggestion of a prefix argument\n"},{"c":0,"s":";;; for PAREDIT-SPLICE-SEXP.  (I, Taylor R. Campbell, however, still\n"},{"c":0,"s":";;; implemented it, in case any of you lawyer-folk get confused by the\n"},{"c":0,"s":";;; remark in the top of the file about explicitly noting code written\n"},{"c":0,"s":";;; by other people.)\n"},"\n(",{"c":5,"s":"defun","i":4002}," ",{"c":5,"s":"paredit-splice-sexp","i":4004}," ",{"c":0,"s":"(&optional arg)"},"\n  ",{"c":0,"s":"\"Splice the list that the point is on by removing its delimiters.\nWith a prefix argument as in `C-u', kill all S-expressions backward in\n  the current list before splicing all S-expressions forward into the\n  enclosing list.\nWith two prefix arguments as in `C-u C-u', kill all S-expressions\n  forward in the current list before splicing all S-expressions\n  backward into the enclosing list.\nWith a numerical prefix argument N, kill N S-expressions backward in\n  the current list before splicing the remaining S-expressions into the\n  enclosing list.  If N is negative, kill forward.\nThis always creates a new entry on the kill ring.\""},"\n  (",{"c":5,"s":"interactive","i":4006}," ",{"c":5,"s":"\"P\"","i":4008},")\n  ",{"c":0,"s":"(save-excursion\n    (paredit-kill-surrounding-sexps-for-splice arg)\n    (backward-up-list)                  ; Go up to the beginning...\n    (save-excursion\n      (forward-sexp)                    ; Go forward an expression, to\n      (backward-delete-char 1))         ;   delete the end delimiter.\n    (delete-char 1)                     ; ...to delete the open char.\n    (paredit-ignore-sexp-errors\n      (backward-up-list)                ; Reindent, now that the\n      (indent-sexp)))"},")                  ",{"c":0,"s":";   structure has changed.\n"},"\n(",{"c":5,"s":"defun","i":4010}," ",{"c":5,"s":"paredit-kill-surrounding-sexps-for-splice","i":4012}," ",{"c":0,"s":"(arg)"},"\n  ",{"c":0,"s":"(cond ((paredit-in-string-p) (error \"Splicing illegal in strings.\"))\n        ((or (not arg) (eq arg 0)) nil)\n        ((or (numberp arg) (eq arg '-))\n         ;; Kill ARG S-expressions before/after the point by saving\n         ;; the point, moving across them, and killing the region.\n         (let* ((arg (if (eq arg '-) -1 arg))\n                (saved (paredit-point-at-sexp-boundary (- arg))))\n           (paredit-ignore-sexp-errors (backward-sexp arg))\n           (kill-region-new saved (point))))\n        ((consp arg)\n         (let ((v (car arg)))\n           (if (= v 4)                  ; one prefix argument\n               ;; Move backward until we hit the open paren; then\n               ;; kill that selected region.\n               (let ((end (paredit-point-at-sexp-start)))\n                 (paredit-ignore-sexp-errors\n                   (while (not (bobp))\n                     (backward-sexp)))\n                 (kill-region-new (point) end))\n               ;; Move forward until we hit the close paren; then\n               ;; kill that selected region.\n               (let ((beginning (paredit-point-at-sexp-end)))\n                 (paredit-ignore-sexp-errors\n                   (while (not (eobp))\n                     (forward-sexp)))\n                 (kill-region-new beginning (point))))))\n        (t (error \"Bizarre prefix argument: %s\" arg)))"},")\n\n(",{"c":5,"s":"defun","i":4014}," ",{"c":5,"s":"paredit-splice-sexp-killing-backward","i":4016}," (",{"c":5,"s":"&optional","i":4018}," ",{"c":5,"s":"n","i":4020},")\n  ",{"c":5,"s":"\"Splice the list the point is on by removing its delimiters, and\n  also kill all S-expressions before the point in the current list.\nWith a prefix argument N, kill only the preceding N S-expressions.\"","i":4022},"\n  (",{"c":5,"s":"interactive","i":4024}," ",{"c":5,"s":"\"P\"","i":4026},")\n  (",{"c":5,"s":"paredit-splice-sexp","i":4028}," (",{"c":5,"s":"if","i":4030}," ",{"c":5,"s":"n","i":4032},"\n                           (",{"c":5,"s":"prefix-numeric-value","i":4034}," ",{"c":5,"s":"n","i":4036},")\n                           ",{"c":5,"s":"'","i":4038},"(",{"c":5,"s":"4","i":4040},"))))\n\n(",{"c":5,"s":"defun","i":4042}," ",{"c":5,"s":"paredit-splice-sexp-killing-forward","i":4044}," (",{"c":5,"s":"&optional","i":4046}," ",{"c":5,"s":"n","i":4048},")\n  ",{"c":5,"s":"\"Splice the list the point is on by removing its delimiters, and\n  also kill all S-expressions after the point in the current list.\nWith a prefix argument N, kill only the following N S-expressions.\"","i":4050},"\n  (",{"c":5,"s":"interactive","i":4052}," ",{"c":5,"s":"\"P\"","i":4054},")\n  (",{"c":5,"s":"paredit-splice-sexp","i":4056}," (",{"c":5,"s":"if","i":4058}," ",{"c":5,"s":"n","i":4060},"\n                           (",{"c":5,"s":"-","i":4062}," (",{"c":5,"s":"prefix-numeric-value","i":4064}," ",{"c":5,"s":"n","i":4066},"))\n                           ",{"c":5,"s":"'","i":4068},"(",{"c":5,"s":"16","i":4070},"))))\n\n(",{"c":5,"s":"defun","i":4072}," ",{"c":5,"s":"paredit-raise-sexp","i":4074}," ",{"c":0,"s":"(&optional n)"},"\n  ",{"c":0,"s":"\"Raise the following S-expression in a tree, deleting its siblings.\nWith a prefix argument N, raise the following N S-expressions.  If N\n  is negative, raise the preceding N S-expressions.\""},"\n  ",{"c":0,"s":"(interactive \"p\")"},"\n  ",{"c":0,"s":";; Select the S-expressions we want to raise in a buffer substring.\n"},"  ",{"c":0,"s":"(let* ((bound (save-excursion (forward-sexp n) (point)))\n         (sexps (save-excursion         ;++ Is this necessary?\n                  (if (and n (< n 0))\n                      (buffer-substring bound\n                                        (paredit-point-at-sexp-end))\n                      (buffer-substring (paredit-point-at-sexp-start)\n                                        bound)))))\n    ;; Move up to the list we're raising those S-expressions out of and\n    ;; delete it.\n    (backward-up-list)\n    (delete-region (point) (save-excursion (forward-sexp) (point)))\n    (save-excursion (insert sexps))     ; Insert & reindent the sexps.\n    (save-excursion (let ((n (abs (or n 1))))\n                      (while (> n 0)\n                        (paredit-forward-and-indent)\n                        (setq n (1- n))))))"},")\n\n",{"c":0,"s":";;;; Slurpage & Barfage\n"},"\n(",{"c":5,"s":"defun","i":4076}," ",{"c":5,"s":"paredit-forward-slurp-sexp","i":4078}," ()\n  ",{"c":5,"s":"\"Add the S-expression following the current list into that list\n  by moving the closing delimiter.\nAutomatically reindent the newly slurped S-expression with respect to\n  its new enclosing form.\nIf in a string, move the opening double-quote forward by one\n  S-expression and escape any intervening characters as necessary,\n  without altering any indentation or formatting.\"","i":4080},"\n  (",{"c":5,"s":"interactive","i":4082},")\n  ",{"c":0,"s":"(save-excursion\n    (cond ((or (paredit-in-comment-p)\n               (paredit-in-char-p))\n           (error \"Invalid context for slurpage\"))\n          ((paredit-in-string-p)\n           (paredit-forward-slurp-into-string))\n          (t\n           (paredit-forward-slurp-into-list))))"},")\n\n(",{"c":5,"s":"defun","i":4084}," ",{"c":5,"s":"paredit-forward-slurp-into-list","i":4086}," ()\n  (",{"c":5,"s":"up-list","i":4088},")                             ",{"c":5,"s":"; Up to the end of the list to\n","i":4090},"  (",{"c":3,"s":"let","i":962}," ((",{"c":3,"s":"close","i":964}," (",{"c":3,"s":"char-before","i":966},")))          ",{"c":3,"s":";   save and delete the closing\n","i":968},"    (",{"c":3,"s":"backward-delete-char","i":970}," ",{"c":3,"s":"1","i":972},")            ",{"c":3,"s":";   delimiter.\n","i":974},"    (",{"c":3,"s":"catch","i":976}," ",{"c":3,"s":"'","i":978},{"c":3,"s":"return","i":980},"                      ",{"c":3,"s":"; Go to the end of the desired\n","i":982},"      (",{"c":3,"s":"while","i":984}," ",{"c":3,"s":"t","i":986},"                          ",{"c":3,"s":";   S-expression, going up a\n","i":988},"        (",{"c":0,"s":"paredit-handle-sexp-errors"},"     ",{"c":0,"s":";   list if it's not in this,\n"},"            (",{"c":3,"s":"progn","i":990}," (",{"c":3,"s":"paredit-forward-and-indent","i":992},")\n                   (",{"c":3,"s":"throw","i":994}," ",{"c":3,"s":"'","i":996},{"c":3,"s":"return","i":998}," ",{"c":3,"s":"nil","i":1000},"))\n          ",{"c":0,"s":"(up-list)"},")))\n    (",{"c":3,"s":"insert","i":1002}," ",{"c":3,"s":"close","i":1004},")))                    ",{"c":5,"s":"; to insert that delimiter.\n","i":4092},"\n(",{"c":5,"s":"defun","i":4094}," ",{"c":5,"s":"paredit-forward-slurp-into-string","i":4096}," ()\n  (",{"c":5,"s":"goto-char","i":4098}," (",{"c":5,"s":"1+","i":4100}," (",{"c":5,"s":"cdr","i":4102}," (",{"c":5,"s":"paredit-string-start+end-points","i":4104},"))))\n  ",{"c":5,"s":";; Signal any errors that we might get first, before mucking with the\n","i":4106},"  ",{"c":5,"s":";; buffer's contents.\n","i":4108},"  (",{"c":5,"s":"save-excursion","i":4110}," (",{"c":5,"s":"forward-sexp","i":4112},"))\n  (",{"c":5,"s":"let","i":4114}," ((",{"c":5,"s":"close","i":4116}," (",{"c":5,"s":"char-before","i":4118},")))\n    (",{"c":5,"s":"backward-delete-char","i":4120}," ",{"c":5,"s":"1","i":4122},")\n    (",{"c":5,"s":"paredit-forward-for-quote","i":4124}," (",{"c":5,"s":"save-excursion","i":4126}," (",{"c":5,"s":"forward-sexp","i":4128},") (",{"c":5,"s":"point","i":4130},")))\n    (",{"c":5,"s":"insert","i":4132}," ",{"c":5,"s":"close","i":4134},")))\n\n(",{"c":5,"s":"defun","i":4136}," ",{"c":5,"s":"paredit-forward-barf-sexp","i":4138}," ()\n  ",{"c":5,"s":"\"Remove the last S-expression in the current list from that list\n  by moving the closing delimiter.\nAutomatically reindent the newly barfed S-expression with respect to\n  its new enclosing form.\"","i":4140},"\n  (",{"c":5,"s":"interactive","i":4142},")\n  (",{"c":5,"s":"save-excursion","i":4144},"\n    (",{"c":5,"s":"up-list","i":4146},")                           ",{"c":5,"s":"; Up to the end of the list to\n","i":4148},"    (",{"c":5,"s":"let","i":4150}," ((",{"c":5,"s":"close","i":4152}," (",{"c":5,"s":"char-before","i":4154},")))        ",{"c":5,"s":";   save and delete the closing\n","i":4156},"      (",{"c":5,"s":"backward-delete-char","i":4158}," ",{"c":5,"s":"1","i":4160},")          ",{"c":5,"s":";   delimiter.\n","i":4162},"      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":4164},"       ",{"c":5,"s":"; Go back to where we want to\n","i":4166},"        (",{"c":5,"s":"backward-sexp","i":4168},"))                ",{"c":5,"s":";   insert the delimiter.\n","i":4170},"      (",{"c":5,"s":"paredit-skip-whitespace","i":4172}," ",{"c":5,"s":"nil","i":4174},")     ",{"c":5,"s":"; Skip leading whitespace.\n","i":4176},"      (",{"c":5,"s":"cond","i":4178}," ((",{"c":5,"s":"bobp","i":4180},")\n             (",{"c":5,"s":"error","i":4182}," ",{"c":5,"s":"\"Barfing all subexpressions with no open-paren?\"","i":4184},"))\n            ((",{"c":5,"s":"paredit-in-comment-p","i":4186},")     ",{"c":5,"s":"; Don't put the close-paren in\n","i":4188},"             (",{"c":5,"s":"newline-and-indent","i":4190},")))     ",{"c":5,"s":";   a comment.\n","i":4192},"      (",{"c":5,"s":"insert","i":4194}," ",{"c":5,"s":"close","i":4196},"))\n    ",{"c":5,"s":";; Reindent all of the newly barfed S-expressions.\n","i":4198},"    (",{"c":5,"s":"paredit-forward-and-indent","i":4200},")))\n\n(",{"c":5,"s":"defun","i":4202}," ",{"c":5,"s":"paredit-backward-slurp-sexp","i":4204}," ()\n  ",{"c":5,"s":"\"Add the S-expression preceding the current list into that list\n  by moving the closing delimiter.\nAutomatically reindent the whole form into which new S-expression was\n  slurped.\nIf in a string, move the opening double-quote backward by one\n  S-expression and escape any intervening characters as necessary,\n  without altering any indentation or formatting.\"","i":4206},"\n  (",{"c":5,"s":"interactive","i":4208},")\n  ",{"c":0,"s":"(save-excursion\n    (cond ((or (paredit-in-comment-p)\n               (paredit-in-char-p))\n           (error \"Invalid context for slurpage\"))\n          ((paredit-in-string-p)\n           (paredit-backward-slurp-into-string))\n          (t\n           (paredit-backward-slurp-into-list))))"},")\n\n(",{"c":5,"s":"defun","i":4210}," ",{"c":5,"s":"paredit-backward-slurp-into-list","i":4212}," ()\n  (",{"c":5,"s":"backward-up-list","i":4214},")\n  (",{"c":3,"s":"let","i":1006}," ((",{"c":3,"s":"open","i":1008}," (",{"c":3,"s":"char-after","i":1010},")))\n    (",{"c":3,"s":"delete-char","i":1012}," ",{"c":3,"s":"1","i":1014},")\n    (",{"c":3,"s":"catch","i":1016}," ",{"c":3,"s":"'","i":1018},{"c":3,"s":"return","i":1020},"\n      (",{"c":3,"s":"while","i":1022}," ",{"c":3,"s":"t","i":1024},"\n        (",{"c":0,"s":"paredit-handle-sexp-errors"},"\n            (",{"c":3,"s":"progn","i":1026}," (",{"c":3,"s":"backward-sexp","i":1028},")\n                   (",{"c":3,"s":"throw","i":1030}," ",{"c":3,"s":"'","i":1032},{"c":3,"s":"return","i":1034}," ",{"c":3,"s":"nil","i":1036},"))\n          ",{"c":0,"s":"(backward-up-list)"},")))\n    (",{"c":3,"s":"insert","i":1038}," ",{"c":3,"s":"open","i":1040},"))\n  ",{"c":0,"s":";; Reindent the line at the beginning of wherever we inserted the\n"},"  ",{"c":0,"s":";; opening parenthesis, and then indent the whole S-expression.\n"},"  (",{"c":5,"s":"backward-up-list","i":4216},")\n  (",{"c":5,"s":"lisp-indent-line","i":4218},")\n  (",{"c":5,"s":"indent-sexp","i":4220},"))\n\n(",{"c":5,"s":"defun","i":4222}," ",{"c":5,"s":"paredit-backward-slurp-into-string","i":4224}," ()\n  (",{"c":5,"s":"goto-char","i":4226}," (",{"c":5,"s":"car","i":4228}," (",{"c":5,"s":"paredit-string-start+end-points","i":4230},")))\n  ",{"c":5,"s":";; Signal any errors that we might get first, before mucking with the\n","i":4232},"  ",{"c":5,"s":";; buffer's contents.\n","i":4234},"  (",{"c":5,"s":"save-excursion","i":4236}," (",{"c":5,"s":"backward-sexp","i":4238},"))\n  ",{"c":0,"s":"(let ((open (char-after))\n        (target (point)))\n    (message \"open = %S\" open)\n    (delete-char 1)\n    (backward-sexp)\n    (insert open)\n    (paredit-forward-for-quote target))"},")\n\n(",{"c":5,"s":"defun","i":4240}," ",{"c":5,"s":"paredit-backward-barf-sexp","i":4242}," ()\n  ",{"c":5,"s":"\"Remove the first S-expression in the current list from that list\n  by moving the closing delimiter.\nAutomatically reindent the barfed S-expression and the form from which\n  it was barfed.\"","i":4244},"\n  (",{"c":5,"s":"interactive","i":4246},")\n  (",{"c":5,"s":"save-excursion","i":4248},"\n    (",{"c":5,"s":"backward-up-list","i":4250},")\n    (",{"c":5,"s":"let","i":4252}," ((",{"c":5,"s":"open","i":4254}," (",{"c":5,"s":"char-after","i":4256},")))\n      (",{"c":5,"s":"delete-char","i":4258}," ",{"c":5,"s":"1","i":4260},")\n      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":4262},"\n        (",{"c":5,"s":"paredit-forward-and-indent","i":4264},"))\n      (",{"c":5,"s":"while","i":4266}," (",{"c":5,"s":"progn","i":4268}," (",{"c":5,"s":"paredit-skip-whitespace","i":4270}," ",{"c":5,"s":"t","i":4272},")\n                    (",{"c":5,"s":"eq","i":4274}," (",{"c":5,"s":"char-after","i":4276},") ",{"c":5,"s":"?\\;","i":4278}," ))\n        (",{"c":5,"s":"forward-line","i":4280}," ",{"c":5,"s":"1","i":4282},"))\n      (",{"c":5,"s":"if","i":4284}," (",{"c":5,"s":"eobp","i":4286},")\n          (",{"c":5,"s":"error","i":4288},"\n           ",{"c":5,"s":"\"Barfing all subexpressions with no close-paren?\"","i":4290},"))\n      ",{"c":5,"s":";** Don't use `insert' here.  Consider, e.g., barfing from\n","i":4292},"      ",{"c":5,"s":";**   (foo|)\n","i":4294},"      ",{"c":5,"s":";** and how `save-excursion' works.\n","i":4296},"      (",{"c":5,"s":"insert-before-markers","i":4298}," ",{"c":5,"s":"open","i":4300},"))\n    (",{"c":5,"s":"backward-up-list","i":4302},")\n    (",{"c":5,"s":"lisp-indent-line","i":4304},")\n    (",{"c":5,"s":"indent-sexp","i":4306},")))\n\n",{"c":5,"s":";;;; Splitting & Joining\n","i":4308},"\n(",{"c":5,"s":"defun","i":4310}," ",{"c":5,"s":"paredit-split-sexp","i":4312}," ()\n  ",{"c":5,"s":"\"Split the list or string the point is on into two.\"","i":4314},"\n  (",{"c":5,"s":"interactive","i":4316},")\n  ",{"c":0,"s":"(cond ((paredit-in-string-p)\n         (insert \"\\\"\")\n         (save-excursion (insert \" \\\"\")))\n        ((or (paredit-in-comment-p)\n             (paredit-in-char-p))\n         (error \"Invalid context for `paredit-split-sexp'\"))\n        (t (let ((open  (save-excursion (backward-up-list)\n                                        (char-after)))\n                 (close (save-excursion (up-list)\n                                        (char-before))))\n             (delete-horizontal-space)\n             (insert close)\n             (save-excursion (insert ?\\ )\n                             (insert open)\n                             (backward-char)\n                             (indent-sexp)))))"},")\n\n(",{"c":5,"s":"defun","i":4318}," ",{"c":5,"s":"paredit-join-sexps","i":4320}," ()\n  ",{"c":5,"s":"\"Join the S-expressions adjacent on either side of the point.\nBoth must be lists, strings, or atoms; error if there is a mismatch.\"","i":4322},"\n  (",{"c":5,"s":"interactive","i":4324},")\n  ",{"c":5,"s":";++ How ought this to handle comments intervening symbols or strings?\n","i":4326},"  (",{"c":3,"s":"save-excursion","i":1042},"\n    (",{"c":0,"s":"if"}," ",{"c":0,"s":"(or (paredit-in-comment-p)\n            (paredit-in-string-p)\n            (paredit-in-char-p))"},"\n        ",{"c":0,"s":"(error \"Invalid context in which to join S-expressions.\")"},"\n      (",{"c":0,"s":"let"}," ",{"c":0,"s":"((left-point  (save-excursion (paredit-point-at-sexp-end)))\n            (right-point (save-excursion\n                           (paredit-point-at-sexp-start))))"},"\n        (",{"c":3,"s":"let","i":1044}," ((",{"c":3,"s":"left-char","i":1046}," (",{"c":3,"s":"char-before","i":1048}," ",{"c":3,"s":"left-point","i":1050},"))\n              (",{"c":3,"s":"right-char","i":1052}," (",{"c":3,"s":"char-after","i":1054}," ",{"c":3,"s":"right-point","i":1056},")))\n          (",{"c":3,"s":"let","i":1058}," ((",{"c":3,"s":"left-syntax","i":1060}," (",{"c":3,"s":"char-syntax","i":1062}," ",{"c":3,"s":"left-char","i":1064},"))\n                (",{"c":3,"s":"right-syntax","i":1066}," (",{"c":3,"s":"char-syntax","i":1068}," ",{"c":3,"s":"right-char","i":1070},")))\n            (",{"c":3,"s":"cond","i":1072}," ((",{"c":3,"s":">=","i":1074}," ",{"c":3,"s":"left-point","i":1076}," ",{"c":3,"s":"right-point","i":1078},")\n                   (",{"c":3,"s":"error","i":1080}," ",{"c":3,"s":"\"Can't join a datum with itself.\"","i":1082},"))\n                  ((",{"c":3,"s":"and","i":1084}," (",{"c":3,"s":"eq","i":1086}," ",{"c":3,"s":"left-syntax","i":1088},"  ",{"c":3,"s":"?\\)","i":1090}," )\n                        (",{"c":3,"s":"eq","i":1092}," ",{"c":3,"s":"right-syntax","i":1094}," ",{"c":3,"s":"?\\(","i":1096}," )\n                        (",{"c":3,"s":"eq","i":1098}," ",{"c":3,"s":"left-char","i":1100}," (",{"c":3,"s":"matching-paren","i":1102}," ",{"c":3,"s":"right-char","i":1104},"))\n                        (",{"c":3,"s":"eq","i":1106}," ",{"c":3,"s":"right-char","i":1108}," (",{"c":3,"s":"matching-paren","i":1110}," ",{"c":3,"s":"left-char","i":1112},")))\n                   ",{"c":3,"s":";; Leave intermediate formatting alone.\n","i":1114},"                   (",{"c":3,"s":"goto-char","i":1116}," ",{"c":3,"s":"right-point","i":1118},")\n                   (",{"c":3,"s":"delete-char","i":1120}," ",{"c":3,"s":"1","i":1122},")\n                   (",{"c":3,"s":"goto-char","i":1124}," ",{"c":3,"s":"left-point","i":1126},")\n                   (",{"c":3,"s":"backward-delete-char","i":1128}," ",{"c":3,"s":"1","i":1130},")\n                   (",{"c":3,"s":"backward-up-list","i":1132},")\n                   (",{"c":3,"s":"indent-sexp","i":1134},"))\n                  ((",{"c":3,"s":"and","i":1136}," (",{"c":3,"s":"eq","i":1138}," ",{"c":3,"s":"left-syntax","i":1140},"  ",{"c":3,"s":"?\\\"","i":1142}," )\n                        (",{"c":3,"s":"eq","i":1144}," ",{"c":3,"s":"right-syntax","i":1146}," ",{"c":3,"s":"?\\\"","i":1148}," ))\n                   ",{"c":3,"s":";; Delete any intermediate formatting.\n","i":1150},"                   (",{"c":3,"s":"delete-region","i":1152}," (",{"c":3,"s":"1-","i":1154}," ",{"c":3,"s":"left-point","i":1156},")\n                                  (",{"c":3,"s":"1+","i":1158}," ",{"c":3,"s":"right-point","i":1160},")))\n                  ((",{"c":3,"s":"and","i":1162}," (",{"c":3,"s":"memq","i":1164}," ",{"c":3,"s":"left-syntax","i":1166},"  ",{"c":3,"s":"'","i":1168},"(",{"c":3,"s":"?w","i":1170}," ",{"c":3,"s":"?_","i":1172},")) ",{"c":3,"s":"; Word or symbol\n","i":1174},"                        (",{"c":3,"s":"memq","i":1176}," ",{"c":3,"s":"right-syntax","i":1178}," ",{"c":3,"s":"'","i":1180},"(",{"c":3,"s":"?w","i":1182}," ",{"c":3,"s":"?_","i":1184},")))\n                   (",{"c":3,"s":"delete-region","i":1186}," ",{"c":3,"s":"left-point","i":1188}," ",{"c":3,"s":"right-point","i":1190},"))\n                  (",{"c":3,"s":"t","i":1192},"\n                   (",{"c":3,"s":"error","i":1194}," ",{"c":3,"s":"\"Mismatched S-expressions to join.\"","i":1196},")))))))))\n\n",{"c":0,"s":";;;; Utilities\n"},"\n(",{"c":5,"s":"defun","i":4328}," ",{"c":5,"s":"paredit-in-string-escape-p","i":4330}," ()\n  ",{"c":5,"s":"\"True if the point is on a character escape of a string.\nThis is true only if the character is preceded by an odd number of\n  backslashes.\nThis assumes that `paredit-in-string-p' has already returned true.\"","i":4332},"\n  (",{"c":5,"s":"let","i":4334}," ((",{"c":5,"s":"oddp","i":4336}," ",{"c":5,"s":"nil","i":4338},"))\n    (",{"c":5,"s":"save-excursion","i":4340},"\n      (",{"c":5,"s":"while","i":4342}," (",{"c":5,"s":"eq","i":4344}," (",{"c":5,"s":"char-before","i":4346},") ",{"c":5,"s":"?\\\\","i":4348}," )\n        (",{"c":5,"s":"setq","i":4350}," ",{"c":5,"s":"oddp","i":4352}," (",{"c":5,"s":"not","i":4354}," ",{"c":5,"s":"oddp","i":4356},"))\n        (",{"c":5,"s":"backward-char","i":4358},")))\n    ",{"c":5,"s":"oddp","i":4360},"))\n\n(",{"c":5,"s":"defun","i":4362}," ",{"c":5,"s":"paredit-in-char-p","i":4364}," ",{"c":0,"s":"(&optional arg)"},"\n  ",{"c":5,"s":"\"True if the point is immediately after a character literal.\nA preceding escape character, not preceded by another escape character,\n  is considered a character literal prefix.  (This works for elisp,\n  Common Lisp, and Scheme.)\nAssumes that `paredit-in-string-p' is false, so that it need not handle\n  long sequences of preceding backslashes in string escapes.  (This\n  assumes some other leading character token -- ? in elisp, # in Scheme\n  and Common Lisp.)\"","i":4366},"\n  ",{"c":0,"s":"(let ((arg (or arg (point))))\n    (and (eq (char-before arg) ?\\\\ )\n         (not (eq (char-before (1- arg)) ?\\\\ ))))"},")\n\n(",{"c":5,"s":"defun","i":4368}," ",{"c":5,"s":"paredit-forward-and-indent","i":4370}," ()\n  ",{"c":0,"s":"\"Move forward an S-expression, indenting it fully.\nIndent with `lisp-indent-line' and then `indent-sexp'.\""},"\n  ",{"c":0,"s":"(forward-sexp)"},"                        ",{"c":0,"s":"; Go forward, and then find the\n"},"  ",{"c":0,"s":"(save-excursion                       ;   beginning of this next\n    (backward-sexp)                     ;   S-expression.\n    (lisp-indent-line)                  ; Indent its opening line, and\n    (indent-sexp))"},")                     ",{"c":0,"s":";   the rest of it.\n"},"\n(",{"c":5,"s":"defun","i":4372}," ",{"c":5,"s":"paredit-skip-whitespace","i":4374}," (",{"c":5,"s":"trailing-p","i":4376}," ",{"c":5,"s":"&optional","i":4378}," ",{"c":5,"s":"limit","i":4380},")\n  ",{"c":5,"s":"\"Skip past any whitespace, or until the point LIMIT is reached.\nIf TRAILING-P is nil, skip leading whitespace; otherwise, skip trailing\n  whitespace.\"","i":4382},"\n  (",{"c":5,"s":"funcall","i":4384}," (",{"c":5,"s":"if","i":4386}," ",{"c":5,"s":"trailing-p","i":4388}," ",{"c":5,"s":"'","i":4390},{"c":5,"s":"skip-chars-forward","i":4392}," ",{"c":5,"s":"'","i":4394},{"c":5,"s":"skip-chars-backward","i":4396},")\n           ",{"c":5,"s":"\" \\t\\n\"","i":4398},"  ",{"c":5,"s":"; This should skip using the syntax table, but LF\n","i":4400},"           ",{"c":5,"s":"limit","i":4402},"))    ",{"c":5,"s":"; is a comment end, not newline, in Lisp mode.\n","i":4404},"\n(",{"c":5,"s":"defalias","i":4406}," ",{"c":5,"s":"'","i":4408},{"c":5,"s":"paredit-region-active-p","i":4410},"\n  (",{"c":5,"s":"xcond","i":4412}," ((",{"c":5,"s":"paredit-xemacs-p","i":4414},") ",{"c":5,"s":"'","i":4416},{"c":5,"s":"region-active-p","i":4418},")\n         ((",{"c":5,"s":"paredit-gnu-emacs-p","i":4420},")\n          (",{"c":5,"s":"lambda","i":4422}," ()\n            (",{"c":5,"s":"and","i":4424}," ",{"c":5,"s":"mark-active","i":4426}," ",{"c":5,"s":"transient-mark-mode","i":4428},")))))\n\n",{"c":0,"s":"(defun kill-region-new (start end)\n  \"Kill the region between START and END.\nDo not append to any current kill, and\n do not let the next kill append to this one.\"\n  (interactive \"r\")                     ;Eh, why not?\n  ;; KILL-REGION sets THIS-COMMAND to tell the next kill that the last\n  ;; command was a kill.  It also checks LAST-COMMAND to see whether it\n  ;; should append.  If we bind these locally, any modifications to\n  ;; THIS-COMMAND will be masked, and it will not see LAST-COMMAND to\n  ;; indicate that it should append.\n  (let ((this-command nil)\n        (last-command nil))\n    (kill-region start end)))"},"\n\n",{"c":0,"s":";;;;; S-expression Parsing Utilities\n"},"\n",{"c":0,"s":";++ These routines redundantly traverse S-expressions a great deal.\n"},{"c":0,"s":";++ If performance issues arise, this whole section will probably have\n"},{"c":0,"s":";++ to be refactored to preserve the state longer, like paredit.scm\n"},{"c":0,"s":";++ does, rather than to traverse the definition N times for every key\n"},{"c":0,"s":";++ stroke as it presently does.\n"},"\n(",{"c":5,"s":"defun","i":4430}," ",{"c":5,"s":"paredit-current-parse-state","i":4432}," ()\n  ",{"c":5,"s":"\"Return parse state of point from beginning of defun.\"","i":4434},"\n  (",{"c":5,"s":"let","i":4436}," ((",{"c":5,"s":"point","i":4438}," (",{"c":5,"s":"point","i":4440},")))\n    (",{"c":5,"s":"beginning-of-defun","i":4442},")\n    ",{"c":5,"s":";; Calling PARSE-PARTIAL-SEXP will advance the point to its second\n","i":4444},"    ",{"c":5,"s":";; argument (unless parsing stops due to an error, but we assume it\n","i":4446},"    ",{"c":5,"s":";; won't in paredit-mode).\n","i":4448},"    (",{"c":5,"s":"parse-partial-sexp","i":4450}," (",{"c":5,"s":"point","i":4452},") ",{"c":5,"s":"point","i":4454},")))\n\n(",{"c":5,"s":"defun","i":4456}," ",{"c":5,"s":"paredit-in-string-p","i":4458}," (",{"c":5,"s":"&optional","i":4460}," ",{"c":5,"s":"state","i":4462},")\n  ",{"c":5,"s":"\"True if the parse state is within a double-quote-delimited string.\nIf no parse state is supplied, compute one from the beginning of the\n  defun to the point.\"","i":4464},"\n  ",{"c":5,"s":";; 3. non-nil if inside a string (the terminator character, really)\n","i":4466},"  (",{"c":5,"s":"and","i":4468}," (",{"c":5,"s":"nth","i":4470}," ",{"c":5,"s":"3","i":4472}," (",{"c":5,"s":"or","i":4474}," ",{"c":5,"s":"state","i":4476}," (",{"c":5,"s":"paredit-current-parse-state","i":4478},")))\n       ",{"c":5,"s":"t","i":4480},"))\n\n(",{"c":5,"s":"defun","i":4482}," ",{"c":5,"s":"paredit-string-start+end-points","i":4484}," (",{"c":5,"s":"&optional","i":4486}," ",{"c":5,"s":"state","i":4488},")\n  ",{"c":5,"s":"\"Return a cons of the points of open and close quotes of the string.\nThe string is determined from the parse state STATE, or the parse state\n  from the beginning of the defun to the point.\nThis assumes that `paredit-in-string-p' has already returned true, i.e.\n  that the point is already within a string.\"","i":4490},"\n  (",{"c":5,"s":"save-excursion","i":4492},"\n    ",{"c":5,"s":";; 8. character address of start of comment or string; nil if not\n","i":4494},"    ",{"c":5,"s":";;    in one\n","i":4496},"    (",{"c":5,"s":"let","i":4498}," ((",{"c":5,"s":"start","i":4500}," (",{"c":5,"s":"nth","i":4502}," ",{"c":5,"s":"8","i":4504}," (",{"c":5,"s":"or","i":4506}," ",{"c":5,"s":"state","i":4508}," (",{"c":5,"s":"paredit-current-parse-state","i":4510},")))))\n      (",{"c":5,"s":"goto-char","i":4512}," ",{"c":5,"s":"start","i":4514},")\n      (",{"c":5,"s":"forward-sexp","i":4516}," ",{"c":5,"s":"1","i":4518},")\n      (",{"c":5,"s":"cons","i":4520}," ",{"c":5,"s":"start","i":4522}," (",{"c":5,"s":"1-","i":4524}," (",{"c":5,"s":"point","i":4526},"))))))\n\n(",{"c":5,"s":"defun","i":4528}," ",{"c":5,"s":"paredit-in-comment-p","i":4530}," (",{"c":5,"s":"&optional","i":4532}," ",{"c":5,"s":"state","i":4534},")\n  ",{"c":5,"s":"\"True if parse state STATE is within a comment.\nIf no parse state is supplied, compute one from the beginning of the\n  defun to the point.\"","i":4536},"\n  ",{"c":5,"s":";; 4. nil if outside a comment, t if inside a non-nestable comment,\n","i":4538},"  ",{"c":5,"s":";;    else an integer (the current comment nesting)\n","i":4540},"  (",{"c":5,"s":"and","i":4542}," (",{"c":5,"s":"nth","i":4544}," ",{"c":5,"s":"4","i":4546}," (",{"c":5,"s":"or","i":4548}," ",{"c":5,"s":"state","i":4550}," (",{"c":5,"s":"paredit-current-parse-state","i":4552},")))\n       ",{"c":5,"s":"t","i":4554},"))\n\n(",{"c":5,"s":"defun","i":4556}," ",{"c":5,"s":"paredit-point-at-sexp-boundary","i":4558}," (",{"c":5,"s":"n","i":4560},")\n  (",{"c":5,"s":"cond","i":4562}," ((",{"c":5,"s":"<","i":4564}," ",{"c":5,"s":"n","i":4566}," ",{"c":5,"s":"0","i":4568},") (",{"c":5,"s":"paredit-point-at-sexp-start","i":4570},"))\n        ((",{"c":5,"s":"=","i":4572}," ",{"c":5,"s":"n","i":4574}," ",{"c":5,"s":"0","i":4576},") (",{"c":5,"s":"point","i":4578},"))\n        ((",{"c":5,"s":">","i":4580}," ",{"c":5,"s":"n","i":4582}," ",{"c":5,"s":"0","i":4584},") (",{"c":5,"s":"paredit-point-at-sexp-end","i":4586},"))))\n\n(",{"c":5,"s":"defun","i":4588}," ",{"c":5,"s":"paredit-point-at-sexp-start","i":4590}," ()\n  ",{"c":0,"s":"(forward-sexp)"},"\n  ",{"c":0,"s":"(backward-sexp)"},"\n  ",{"c":0,"s":"(point)"},")\n\n(",{"c":5,"s":"defun","i":4592}," ",{"c":5,"s":"paredit-point-at-sexp-end","i":4594}," ()\n  ",{"c":0,"s":"(backward-sexp)"},"\n  ",{"c":0,"s":"(forward-sexp)"},"\n  ",{"c":0,"s":"(point)"},")\n\n",{"c":0,"s":";;;; Initialization\n"},"\n(",{"c":5,"s":"paredit-define-keys","i":4596},")\n(",{"c":5,"s":"paredit-annotate-mode-with-examples","i":4598},")\n(",{"c":5,"s":"paredit-annotate-functions-with-examples","i":4600},")\n\n(",{"c":5,"s":"provide","i":4602}," ",{"c":5,"s":"'","i":4604},{"c":5,"s":"paredit","i":4606},")\n\n"],"right":["\n","\n",{"c":1,"s":";;; paredit.el --- minor mode for editing parentheses  -*- Mode: Emacs-Lisp -*-\n"},"\n",{"c":1,"s":";; Copyright (C) 2005--2010 Taylor R. Campbell\n"},"\n",{"c":1,"s":";; Author: Taylor R. Campbell\n"},{"c":1,"s":";; Version: 22\n"},{"c":1,"s":";; Created: 2005-07-31\n"},{"c":1,"s":";; Keywords: lisp\n"},"\n",{"c":1,"s":";; Paredit is free software: you can redistribute it and/or modify it\n"},{"c":1,"s":";; under the terms of the GNU General Public License as published by\n"},{"c":1,"s":";; the Free Software Foundation, either version 3 of the License, or\n"},{"c":1,"s":";; (at your option) any later version.\n"},{"c":1,"s":";;\n"},{"c":1,"s":";; Paredit is distributed in the hope that it will be useful, but\n"},{"c":1,"s":";; WITHOUT ANY WARRANTY; without even the implied warranty of\n"},{"c":1,"s":";; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"},{"c":1,"s":";; GNU General Public License for more details.\n"},{"c":1,"s":";;\n"},{"c":1,"s":";; You should have received a copy of the GNU General Public License\n"},{"c":1,"s":";; along with paredit.  If not, see <http://www.gnu.org/licenses/>.\n"},"\n",{"c":1,"s":";;; This file is permanently stored at\n"},{"c":1,"s":";;;   <http://mumble.net/~campbell/emacs/paredit-22.el>.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; The currently released version of paredit is available at\n"},{"c":1,"s":";;;   <http://mumble.net/~campbell/emacs/paredit.el>.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; The latest beta version of paredit is available at\n"},{"c":1,"s":";;;   <http://mumble.net/~campbell/emacs/paredit-beta.el>.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Release notes are available at\n"},{"c":1,"s":";;;   <http://mumble.net/~campbell/emacs/paredit.release>.\n"},"\n",{"c":1,"s":";;; Install paredit by placing `paredit.el' in `/path/to/elisp', a\n"},{"c":1,"s":";;; directory of your choice, and adding to your .emacs file:\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;;   (add-to-list 'load-path \"/path/to/elisp\")\n"},{"c":1,"s":";;;   (autoload 'enable-paredit-mode \"paredit\"\n"},{"c":1,"s":";;;     \"Turn on pseudo-structural editing of Lisp code.\"\n"},{"c":1,"s":";;;     t)\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Enable Paredit Mode on the fly with `M-x enable-paredit-mode RET',\n"},{"c":1,"s":";;; or always enable it in a major mode `M' (e.g., `lisp') with:\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;;   (add-hook M-mode-hook 'enable-paredit-mode)\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Customize paredit using `eval-after-load':\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;;   (eval-after-load 'paredit\n"},{"c":1,"s":";;;     '(progn ...redefine keys, &c....))\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Paredit should run in GNU Emacs 21 or later and XEmacs 21.5 or\n"},{"c":1,"s":";;; later.  Paredit is highly unlikely to work in earlier versions of\n"},{"c":1,"s":";;; GNU Emacs, and it may have obscure problems in earlier versions of\n"},{"c":1,"s":";;; XEmacs due to the way its syntax parser reports conditions, as a\n"},{"c":1,"s":";;; result of which the code that uses the syntax parser must mask all\n"},{"c":1,"s":";;; error conditions, not just those generated by the syntax parser.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Questions, bug reports, comments, feature suggestions, &c., may be\n"},{"c":1,"s":";;; addressed via email to the author's surname at mumble.net or via\n"},{"c":1,"s":";;; IRC to the user named Riastradh on irc.freenode.net in the #paredit\n"},{"c":1,"s":";;; channel.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Please contact the author rather than forking your own versions, to\n"},{"c":1,"s":";;; prevent the dissemination of random variants floating about the\n"},{"c":1,"s":";;; internet unbeknownst to the author.  Laziness is not an excuse:\n"},{"c":1,"s":";;; your laziness costs me confusion and time trying to support\n"},{"c":1,"s":";;; paredit, so if you fork paredit, you make the world a worse place.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; *** WARNING *** IMPORTANT *** DO NOT SUBMIT BUGS BEFORE READING ***\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; If you plan to submit a bug report, where some sequence of keys in\n"},{"c":1,"s":";;; Paredit Mode, or some sequence of paredit commands, doesn't do what\n"},{"c":1,"s":";;; you wanted, then it is helpful to isolate an example in a very\n"},{"c":1,"s":";;; small buffer, and it is **ABSOLUTELY**ESSENTIAL** that you supply,\n"},{"c":1,"s":";;; along with the sequence of keys or commands,\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;;   (1) the version of Emacs,\n"},{"c":1,"s":";;;   (2) the version of paredit.el[*], and\n"},{"c":1,"s":";;;   (3) the **COMPLETE** state of the buffer used to reproduce the\n"},{"c":1,"s":";;;       problem, including major mode, minor modes, local key\n"},{"c":1,"s":";;;       bindings, entire contents of the buffer, leading line breaks\n"},{"c":1,"s":";;;       or spaces, &c.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; It is often extremely difficult to reproduce problems, especially\n"},{"c":1,"s":";;; with commands such as `paredit-kill'.  If you do not supply **ALL**\n"},{"c":1,"s":";;; of this information, then it is highly probable that I cannot\n"},{"c":1,"s":";;; reproduce your problem no matter how hard I try, and the effect of\n"},{"c":1,"s":";;; submitting a bug without this information is only to waste your\n"},{"c":1,"s":";;; time and mine.  So, please, include all of the above information.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; [*] If you are using a beta version of paredit, be sure that you\n"},{"c":1,"s":";;;     are using the *latest* edition of the beta version, available\n"},{"c":1,"s":";;;     at <http://mumble.net/~campbell/emacs/paredit-beta.el>.  If you\n"},{"c":1,"s":";;;     are not using a beta version, then upgrade either to that or to\n"},{"c":1,"s":";;;     the latest release version; I cannot support older versions,\n"},{"c":1,"s":";;;     and I can't fathom any reason why you might be using them.  So\n"},{"c":1,"s":";;;     the answer to item (2) should be either `release' or `beta'.\n"},"\n",{"c":1,"s":";;; The paredit minor mode, Paredit Mode, binds a number of simple\n"},{"c":1,"s":";;; keys, notably `(', `)', `\"', and `\\', to commands that more\n"},{"c":1,"s":";;; carefully insert S-expression structures in the buffer.  The\n"},{"c":1,"s":";;; parenthesis delimiter keys (round or square) are defined to insert\n"},{"c":1,"s":";;; parenthesis pairs and move past the closing delimiter,\n"},{"c":1,"s":";;; respectively; the double-quote key is multiplexed to do both, and\n"},{"c":1,"s":";;; also to insert an escape if within a string; and backslashes prompt\n"},{"c":1,"s":";;; the user for the next character to input, because a lone backslash\n"},{"c":1,"s":";;; can break structure inadvertently.  These all have their ordinary\n"},{"c":1,"s":";;; behaviour when inside comments, and, outside comments, if truly\n"},{"c":1,"s":";;; necessary, you can insert them literally with `C-q'.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; The key bindings are designed so that when typing new code in\n"},{"c":1,"s":";;; Paredit Mode, you can generally use exactly the same keystrokes as\n"},{"c":1,"s":";;; you would have used without Paredit Mode.  Earlier versions of\n"},{"c":1,"s":";;; paredit.el did not conform to this, because Paredit Mode bound `)'\n"},{"c":1,"s":";;; to a command that would insert a newline.  Now `)' is bound to a\n"},{"c":1,"s":";;; command that does not insert a newline, and `M-)' is bound to the\n"},{"c":1,"s":";;; command that inserts a newline.  To revert to the former behaviour,\n"},{"c":1,"s":";;; add the following forms to an `eval-after-load' form for paredit.el\n"},{"c":1,"s":";;; in your .emacs file:\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;;   (define-key paredit-mode-map (kbd \")\")\n"},{"c":1,"s":";;;     'paredit-close-round-and-newline)\n"},{"c":1,"s":";;;   (define-key paredit-mode-map (kbd \"M-)\")\n"},{"c":1,"s":";;;     'paredit-close-round)\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Paredit Mode also binds the usual keys for deleting and killing, so\n"},{"c":1,"s":";;; that they will not destroy any S-expression structure by killing or\n"},{"c":1,"s":";;; deleting only one side of a parenthesis or quote pair.  If the\n"},{"c":1,"s":";;; point is on a closing delimiter, `DEL' will move left over it; if\n"},{"c":1,"s":";;; it is on an opening delimiter, `C-d' will move right over it.  Only\n"},{"c":1,"s":";;; if the point is between a pair of delimiters will `C-d' or `DEL'\n"},{"c":1,"s":";;; delete them, and in that case it will delete both simultaneously.\n"},{"c":1,"s":";;; `M-d' and `M-DEL' kill words, but skip over any S-expression\n"},{"c":1,"s":";;; structure.  `C-k' kills from the start of the line, either to the\n"},{"c":1,"s":";;; line's end, if it contains only balanced expressions; to the first\n"},{"c":1,"s":";;; closing delimiter, if the point is within a form that ends on the\n"},{"c":1,"s":";;; line; or up to the end of the last expression that starts on the\n"},{"c":1,"s":";;; line after the point.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; The behaviour of the commands for deleting and killing can be\n"},{"c":1,"s":";;; overridden by passing a `C-u' prefix argument: `C-u DEL' will\n"},{"c":1,"s":";;; delete a character backward, `C-u C-d' will delete a character\n"},{"c":1,"s":";;; forward, and `C-u C-k' will kill text from the point to the end of\n"},{"c":1,"s":";;; the line, irrespective of the S-expression structure in the buffer.\n"},{"c":1,"s":";;; This can be used to fix mistakes in a buffer, but should generally\n"},{"c":1,"s":";;; be avoided.\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; Paredit performs automatic reindentation as locally as possible, to\n"},{"c":1,"s":";;; avoid interfering with custom indentation used elsewhere in some\n"},{"c":1,"s":";;; S-expression.  Only the advanced S-expression manipulation commands\n"},{"c":1,"s":";;; automatically reindent, and only the forms that were immediately\n"},{"c":1,"s":";;; operated upon (and their subforms).\n"},{"c":1,"s":";;;\n"},{"c":1,"s":";;; This code is written for clarity, not efficiency.  It frequently\n"},{"c":1,"s":";;; walks over S-expressions redundantly.  If you have problems with\n"},{"c":1,"s":";;; the time it takes to execute some of the commands, let me know, but\n"},{"c":1,"s":";;; first be sure that what you're doing is reasonable: it is\n"},{"c":1,"s":";;; preferable to avoid immense S-expressions in code anyway.\n"},"\n",{"c":1,"s":";;; This assumes Unix-style LF line endings.\n"},"\n",{"c":1,"s":"(defconst paredit-version 22)"},"\n",{"c":1,"s":"(defconst paredit-beta-p nil)"},"\n\n",{"c":1,"s":"(eval-and-compile\n\n  (defun paredit-xemacs-p ()\n    ;; No idea where I got this definition from.  Edward O'Connor\n    ;; (hober in #emacs) suggested the current definition.\n    ;;   (and (boundp 'running-xemacs)\n    ;;        running-xemacs)\n    (featurep 'xemacs))\n\n  (defun paredit-gnu-emacs-p ()\n    ;++ This could probably be improved.\n    (not (paredit-xemacs-p)))\n\n  (defmacro xcond (&rest clauses)\n    \"Exhaustive COND.\nSignal an error if no clause matches.\"\n    `(cond ,@clauses\n           (t (error \"XCOND lost.\"))))\n\n  (defalias 'paredit-warn (if (fboundp 'warn) 'warn 'message))\n\n  (defvar paredit-sexp-error-type\n    (with-temp-buffer\n      (insert \"(\")\n      (condition-case condition\n          (backward-sexp)\n        (error (if (eq (car condition) 'error)\n                   (paredit-warn \"%s%s%s%s%s\"\n                                 \"Paredit is unable to discriminate\"\n                                 \" S-expression parse errors from\"\n                                 \" other errors. \"\n                                 \" This may cause obscure problems. \"\n                                 \" Please upgrade Emacs.\"))\n               (car condition)))))\n\n  (defmacro paredit-handle-sexp-errors (body &rest handler)\n    `(condition-case ()\n         ,body\n       (,paredit-sexp-error-type ,@handler)))\n\n  (put 'paredit-handle-sexp-errors 'lisp-indent-function 1)\n\n  (defmacro paredit-ignore-sexp-errors (&rest body)\n    `(paredit-handle-sexp-errors (progn ,@body)\n       nil))\n\n  (put 'paredit-ignore-sexp-errors 'lisp-indent-function 0)\n\n  nil)"},"\n\n",{"c":1,"s":";;;; Minor Mode Definition\n"},"\n(",{"c":5,"s":"defvar","i":1197}," ",{"c":5,"s":"paredit-mode-map","i":1199}," (",{"c":5,"s":"make-sparse-keymap","i":1201},")\n  ",{"c":5,"s":"\"Keymap for the paredit minor mode.\"","i":1203},")\n\n",{"c":1,"s":";;;###autoload\n"},{"c":1,"s":"(define-minor-mode paredit-mode\n  \"Minor mode for pseudo-structurally editing Lisp code.\nWith a prefix argument, enable Paredit Mode even if there are\n  imbalanced parentheses in the buffer.\nParedit behaves badly if parentheses are imbalanced, so exercise\n  caution when forcing Paredit Mode to be enabled, and consider\n  fixing imbalanced parentheses instead.\n\\\\<paredit-mode-map>\"\n  :lighter \" Paredit\"\n  ;; If we're enabling paredit-mode, the prefix to this code that\n  ;; DEFINE-MINOR-MODE inserts will have already set PAREDIT-MODE to\n  ;; true.  If this is the case, then first check the parentheses, and\n  ;; if there are any imbalanced ones we must inhibit the activation of\n  ;; paredit mode.  We skip the check, though, if the user supplied a\n  ;; prefix argument interactively.\n  (if (and paredit-mode\n           (not current-prefix-arg))\n      (if (not (fboundp 'check-parens))\n          (paredit-warn \"`check-parens' is not defined; %s\"\n                        \"be careful of malformed S-expressions.\")\n          (condition-case condition\n              (check-parens)\n            (error (setq paredit-mode nil)\n                   (signal (car condition) (cdr condition)))))))"},"\n\n(",{"c":5,"s":"defun","i":1205}," ",{"c":5,"s":"enable-paredit-mode","i":1207}," ()\n  ",{"c":1,"s":"\"Turn on pseudo-structural editing of Lisp code.\""},"\n  (",{"c":5,"s":"interactive","i":1209},")\n  (",{"c":5,"s":"paredit-mode","i":1211}," ",{"c":5,"s":"+1","i":1213},"))\n\n(",{"c":5,"s":"defun","i":1215}," ",{"c":5,"s":"disable-paredit-mode","i":1217}," ()\n  ",{"c":1,"s":"\"Turn off pseudo-structural editing of Lisp code.\""},"\n  (",{"c":5,"s":"interactive","i":1219},")\n  (",{"c":5,"s":"paredit-mode","i":1221}," ",{"c":5,"s":"-1","i":1223},"))\n\n(",{"c":5,"s":"defvar","i":1225}," ",{"c":5,"s":"paredit-backward-delete-key","i":1227},"\n  (",{"c":5,"s":"xcond","i":1229}," ((",{"c":5,"s":"paredit-xemacs-p","i":1231},")    ",{"c":5,"s":"\"BS\"","i":1233},")\n         ((",{"c":5,"s":"paredit-gnu-emacs-p","i":1235},") ",{"c":5,"s":"\"DEL\"","i":1237},")))\n\n(",{"c":5,"s":"defvar","i":1239}," ",{"c":5,"s":"paredit-forward-delete-keys","i":1241},"\n  (",{"c":5,"s":"xcond","i":1243}," ((",{"c":5,"s":"paredit-xemacs-p","i":1245},")    ",{"c":5,"s":"'","i":1247},"(",{"c":5,"s":"\"DEL\"","i":1249},"))\n         ((",{"c":5,"s":"paredit-gnu-emacs-p","i":1251},") ",{"c":5,"s":"'","i":1253},"(",{"c":5,"s":"\"<delete>\"","i":1255}," ",{"c":5,"s":"\"<deletechar>\"","i":1257},"))))\n\n",{"c":5,"s":";;;; Paredit Keys\n","i":1259},"\n",{"c":5,"s":";;; Separating the definition and initialization of this variable\n","i":1261},{"c":5,"s":";;; simplifies the development of paredit, since re-evaluating DEFVAR\n","i":1263},{"c":5,"s":";;; forms doesn't actually do anything.\n","i":1265},"\n(",{"c":5,"s":"defvar","i":1267}," ",{"c":5,"s":"paredit-commands","i":1269}," ",{"c":5,"s":"nil","i":1271},"\n  ",{"c":5,"s":"\"List of paredit commands with their keys and examples.\"","i":1273},")\n\n",{"c":5,"s":";;; Each specifier is of the form:\n","i":1275},{"c":5,"s":";;;   (key[s] function (example-input example-output) ...)\n","i":1277},{"c":5,"s":";;; where key[s] is either a single string suitable for passing to KBD\n","i":1279},{"c":5,"s":";;; or a list of such strings.  Entries in this list may also just be\n","i":1281},{"c":5,"s":";;; strings, in which case they are headings for the next entries.\n","i":1283},"\n(",{"c":3,"s":"progn","i":555}," (",{"c":3,"s":"setq","i":557}," ",{"c":3,"s":"paredit-commands","i":559},"\n ",{"c":3,"s":"`","i":561},"(\n   ",{"c":1,"s":"\"Basic Insertion Commands\""},"\n   ",{"c":1,"s":"(\"(\"         paredit-open-round\n                (\"(a b |c d)\"\n                 \"(a b (|) c d)\")\n                (\"(foo \\\"bar |baz\\\" quux)\"\n                 \"(foo \\\"bar (|baz\\\" quux)\"))"},"\n   ",{"c":1,"s":"(\")\"         paredit-close-round\n                (\"(a b |c   )\" \"(a b c)|\")\n                (\"; Hello,| world!\"\n                 \"; Hello,)| world!\"))"},"\n   ",{"c":1,"s":"(\"M-)\"       paredit-close-round-and-newline\n                (\"(defun f (x|  ))\"\n                 \"(defun f (x)\\n  |)\")\n                (\"; (Foo.|\"\n                 \"; (Foo.)|\"))"},"\n   ",{"c":1,"s":"(\"[\"         paredit-open-square\n                (\"(a b |c d)\"\n                 \"(a b [|] c d)\")\n                (\"(foo \\\"bar |baz\\\" quux)\"\n                 \"(foo \\\"bar [baz\\\" quux)\"))"},"\n   ",{"c":1,"s":"(\"]\"         paredit-close-square\n                (\"(define-key keymap [frob|  ] 'frobnicate)\"\n                 \"(define-key keymap [frob]| 'frobnicate)\")\n                (\"; [Bar.|\"\n                 \"; [Bar.]|\"))"},"\n   (",{"c":3,"s":"\"\\\"\"","i":563},"        ",{"c":3,"s":"paredit-doublequote","i":565},"\n                (",{"c":3,"s":"\"(frob grovel |full lexical)\"","i":567},"\n                 ",{"c":3,"s":"\"(frob grovel \\\"|\\\" full lexical)\"","i":569},")\n                (",{"c":3,"s":"\"(foo \\\"bar |baz\\\" quux)\"","i":571},"\n                 ",{"c":3,"s":"\"(foo \\\"bar \\\\\\\"|baz\\\" quux)\"","i":573},"))\n   (",{"c":3,"s":"\"M-\\\"\"","i":477},"      ",{"c":3,"s":"paredit-meta-doublequote","i":479},"\n                (",{"c":3,"s":"\"(foo \\\"bar |baz\\\" quux)\"","i":481},"\n                 ",{"c":3,"s":"\"(foo \\\"bar baz\\\"\\n     |quux)\"","i":483},")\n                (",{"c":3,"s":"\"(foo |(bar #\\\\x \\\"baz \\\\\\\\ quux\\\") zot)\"","i":485},"\n                 ",{"c":3,"s":",","i":487},"(",{"c":3,"s":"concat","i":489}," ",{"c":3,"s":"\"(foo \\\"|(bar #\\\\\\\\x \\\\\\\"baz \\\\\\\\\"","i":491},"\n                          ",{"c":3,"s":"\"\\\\\\\\ quux\\\\\\\")\\\" zot)\"","i":493},")))\n   (",{"c":3,"s":"\"\\\\\"","i":375},"        ",{"c":3,"s":"paredit-backslash","i":377},"\n                (",{"c":3,"s":"\"(string #|)\\n  ; Escaping character... (x)\"","i":379},"\n                 ",{"c":3,"s":"\"(string #\\\\x|)\"","i":381},")\n                (",{"c":3,"s":"\"\\\"foo|bar\\\"\\n  ; Escaping character... (\\\")\"","i":383},"\n                 ",{"c":3,"s":"\"\\\"foo\\\\\\\"|bar\\\"\"","i":385},"))\n   ",{"c":1,"s":"(\";\"         paredit-semicolon\n                (\"|(frob grovel)\"\n                 \";|(frob grovel)\")\n                (\"(frob |grovel)\"\n                 \"(frob ;grovel\\n)\")\n                (\"(frob |grovel (bloit\\n               zargh))\"\n                 \"(frob ;|grovel\\n (bloit\\n  zargh))\")\n                (\"(frob grovel)          |\"\n                 \"(frob grovel)          ;|\"))"},"\n   (",{"c":3,"s":"\"M-;\"","i":287},"       ",{"c":3,"s":"paredit-comment-dwim","i":289},"\n                (",{"c":3,"s":"\"(foo |bar)   ; baz\"","i":291},"\n                 ",{"c":3,"s":"\"(foo bar)                               ; |baz\"","i":293},")\n                (",{"c":3,"s":"\"(frob grovel)|\"","i":295},"\n                 ",{"c":3,"s":"\"(frob grovel)                           ;|\"","i":297},")\n                (",{"c":3,"s":"\"    (foo bar)\\n|\\n    (baz quux)\"","i":299},"\n                 ",{"c":3,"s":"\"    (foo bar)\\n    ;; |\\n    (baz quux)\"","i":301},")\n                (",{"c":3,"s":"\"    (foo bar) |(baz quux)\"","i":303},"\n                 ",{"c":3,"s":"\"    (foo bar)\\n    ;; |\\n    (baz quux)\"","i":305},")\n                (",{"c":3,"s":"\"|(defun hello-world ...)\"","i":307},"\n                 ",{"c":3,"s":"\";;; |\\n(defun hello-world ...)\"","i":309},"))\n\n   (",{"c":3,"s":"\"C-j\"","i":243},"       ",{"c":3,"s":"paredit-newline","i":245},"\n                (",{"c":3,"s":"\"(let ((n (frobbotz))) |(display (+ n 1)\\nport))\"","i":247},"\n                 ",{"c":3,"s":",","i":249},"(",{"c":3,"s":"concat","i":251}," ",{"c":3,"s":"\"(let ((n (frobbotz)))\"","i":253},"\n                          ",{"c":3,"s":"\"\\n  |(display (+ n 1)\"","i":255},"\n                          ",{"c":3,"s":"\"\\n            port))\"","i":257},")))\n\n   ",{"c":1,"s":"\"Deleting & Killing\""},"\n   ((",{"c":3,"s":"\"C-d\"","i":217}," ",{"c":3,"s":",","i":219},{"c":3,"s":"@paredit-forward-delete-keys","i":221},")\n                ",{"c":3,"s":"paredit-forward-delete","i":223},"\n                (",{"c":3,"s":"\"(quu|x \\\"zot\\\")\"","i":225}," ",{"c":3,"s":"\"(quu| \\\"zot\\\")\"","i":227},")\n                (",{"c":3,"s":"\"(quux |\\\"zot\\\")\"","i":229},"\n                 ",{"c":3,"s":"\"(quux \\\"|zot\\\")\"","i":231},"\n                 ",{"c":3,"s":"\"(quux \\\"|ot\\\")\"","i":233},")\n                (",{"c":3,"s":"\"(foo (|) bar)\"","i":235}," ",{"c":3,"s":"\"(foo | bar)\"","i":237},")\n                (",{"c":3,"s":"\"|(foo bar)\"","i":239}," ",{"c":3,"s":"\"(|foo bar)\"","i":241},"))\n   (",{"c":3,"s":",","i":193},{"c":3,"s":"paredit-backward-delete-key","i":195},"\n                ",{"c":3,"s":"paredit-backward-delete","i":197},"\n                (",{"c":3,"s":"\"(\\\"zot\\\" q|uux)\"","i":199}," ",{"c":3,"s":"\"(\\\"zot\\\" |uux)\"","i":201},")\n                (",{"c":3,"s":"\"(\\\"zot\\\"| quux)\"","i":203},"\n                 ",{"c":3,"s":"\"(\\\"zot|\\\" quux)\"","i":205},"\n                 ",{"c":3,"s":"\"(\\\"zo|\\\" quux)\"","i":207},")\n                (",{"c":3,"s":"\"(foo (|) bar)\"","i":209}," ",{"c":3,"s":"\"(foo | bar)\"","i":211},")\n                (",{"c":3,"s":"\"(foo bar)|\"","i":213}," ",{"c":3,"s":"\"(foo bar|)\"","i":215},"))\n   (",{"c":3,"s":"\"C-k\"","i":173},"       ",{"c":3,"s":"paredit-kill","i":175},"\n                (",{"c":3,"s":"\"(foo bar)|     ; Useless comment!\"","i":177},"\n                 ",{"c":3,"s":"\"(foo bar)|\"","i":179},")\n                (",{"c":3,"s":"\"(|foo bar)     ; Useful comment!\"","i":181},"\n                 ",{"c":3,"s":"\"(|)     ; Useful comment!\"","i":183},")\n                (",{"c":3,"s":"\"|(foo bar)     ; Useless line!\"","i":185},"\n                 ",{"c":3,"s":"\"|\"","i":187},")\n                (",{"c":3,"s":"\"(foo \\\"|bar baz\\\"\\n     quux)\"","i":189},"\n                 ",{"c":3,"s":"\"(foo \\\"|\\\"\\n     quux)\"","i":191},"))\n   (",{"c":3,"s":"\"M-d\"","i":155},"       ",{"c":3,"s":"paredit-forward-kill-word","i":157},"\n                (",{"c":3,"s":"\"|(foo bar)    ; baz\"","i":159},"\n                 ",{"c":3,"s":"\"(| bar)    ; baz\"","i":161},"\n                 ",{"c":3,"s":"\"(|)    ; baz\"","i":163},"\n                 ",{"c":3,"s":"\"()    ;|\"","i":165},")\n                (",{"c":3,"s":"\";;;| Frobnicate\\n(defun frobnicate ...)\"","i":167},"\n                 ",{"c":3,"s":"\";;;|\\n(defun frobnicate ...)\"","i":169},"\n                 ",{"c":3,"s":"\";;;\\n(| frobnicate ...)\"","i":171},"))\n   (",{"c":3,"s":",","i":135},"(",{"c":3,"s":"concat","i":137}," ",{"c":3,"s":"\"M-\"","i":139}," ",{"c":3,"s":"paredit-backward-delete-key","i":141},")\n                ",{"c":3,"s":"paredit-backward-kill-word","i":143},"\n                (",{"c":3,"s":"\"(foo bar)    ; baz\\n(quux)|\"","i":145},"\n                 ",{"c":3,"s":"\"(foo bar)    ; baz\\n(|)\"","i":147},"\n                 ",{"c":3,"s":"\"(foo bar)    ; |\\n()\"","i":149},"\n                 ",{"c":3,"s":"\"(foo |)    ; \\n()\"","i":151},"\n                 ",{"c":3,"s":"\"(|)    ; \\n()\"","i":153},"))\n\n   ",{"c":1,"s":"\"Movement & Navigation\""},"\n   (",{"c":3,"s":"\"C-M-f\"","i":123},"     ",{"c":3,"s":"paredit-forward","i":125},"\n                (",{"c":3,"s":"\"(foo |(bar baz) quux)\"","i":127},"\n                 ",{"c":3,"s":"\"(foo (bar baz)| quux)\"","i":129},")\n                (",{"c":3,"s":"\"(foo (bar)|)\"","i":131},"\n                 ",{"c":3,"s":"\"(foo (bar))|\"","i":133},"))\n   (",{"c":3,"s":"\"C-M-b\"","i":111},"     ",{"c":3,"s":"paredit-backward","i":113},"\n                (",{"c":3,"s":"\"(foo (bar baz)| quux)\"","i":115},"\n                 ",{"c":3,"s":"\"(foo |(bar baz) quux)\"","i":117},")\n                (",{"c":3,"s":"\"(|(foo) bar)\"","i":119},"\n                 ",{"c":3,"s":"\"|((foo) bar)\"","i":121},"))\n   ",{"c":1,"s":"(\"C-M-u\"     paredit-backward-up)"},"\n   ",{"c":1,"s":"(\"C-M-d\"     paredit-forward-down)"},"\n   ",{"c":1,"s":"(\"C-M-p\"     paredit-backward-down)"},"  ",{"c":1,"s":"; Built-in, these are FORWARD-\n"},"   ",{"c":1,"s":"(\"C-M-n\"     paredit-forward-up)"},"     ",{"c":1,"s":"; & BACKWARD-LIST, which have\n"},"                                        ",{"c":1,"s":"; no need given C-M-f & C-M-b.\n"},"\n   ",{"c":1,"s":"\"Depth-Changing Commands\""},"\n   ",{"c":1,"s":"(\"M-(\"       paredit-wrap-round\n                (\"(foo |bar baz)\"\n                 \"(foo (|bar) baz)\"))"},"\n   ",{"c":1,"s":"(\"M-s\"       paredit-splice-sexp\n                (\"(foo (bar| baz) quux)\"\n                 \"(foo bar| baz quux)\"))"},"\n   ((",{"c":3,"s":"\"M-<up>\"","i":101}," ",{"c":3,"s":"\"ESC <up>\"","i":103},")\n                ",{"c":3,"s":"paredit-splice-sexp-killing-backward","i":105},"\n                (",{"c":3,"s":"\"(foo (let ((x 5)) |(sqrt n)) bar)\"","i":107},"\n                 ",{"c":3,"s":"\"(foo (sqrt n) bar)\"","i":109},"))\n   ((",{"c":3,"s":"\"M-<down>\"","i":91}," ",{"c":3,"s":"\"ESC <down>\"","i":93},")\n                ",{"c":3,"s":"paredit-splice-sexp-killing-forward","i":95},"\n                (",{"c":3,"s":"\"(a (b c| d e) f)\"","i":97},"\n                 ",{"c":3,"s":"\"(a b c f)\"","i":99},"))\n   (",{"c":3,"s":"\"M-r\"","i":81},"       ",{"c":3,"s":"paredit-raise-sexp","i":83},"\n                (",{"c":3,"s":"\"(dynamic-wind in (lambda () |body) out)\"","i":85},"\n                 ",{"c":3,"s":"\"(dynamic-wind in |body out)\"","i":87},"\n                 ",{"c":3,"s":"\"|body\"","i":89},"))\n\n   ",{"c":1,"s":"\"Barfage & Slurpage\""},"\n   ((",{"c":3,"s":"\"C-)\"","i":67}," ",{"c":3,"s":"\"C-<right>\"","i":69},")\n                ",{"c":3,"s":"paredit-forward-slurp-sexp","i":71},"\n                (",{"c":3,"s":"\"(foo (bar |baz) quux zot)\"","i":73},"\n                 ",{"c":3,"s":"\"(foo (bar |baz quux) zot)\"","i":75},")\n                (",{"c":3,"s":"\"(a b ((c| d)) e f)\"","i":77},"\n                 ",{"c":3,"s":"\"(a b ((c| d) e) f)\"","i":79},"))\n   ((",{"c":3,"s":"\"C-}\"","i":57}," ",{"c":3,"s":"\"C-<left>\"","i":59},")\n                ",{"c":3,"s":"paredit-forward-barf-sexp","i":61},"\n                (",{"c":3,"s":"\"(foo (bar |baz quux) zot)\"","i":63},"\n                 ",{"c":3,"s":"\"(foo (bar |baz) quux zot)\"","i":65},"))\n   ((",{"c":3,"s":"\"C-(\"","i":41}," ",{"c":3,"s":"\"C-M-<left>\"","i":43}," ",{"c":3,"s":"\"ESC C-<left>\"","i":45},")\n                ",{"c":3,"s":"paredit-backward-slurp-sexp","i":47},"\n                (",{"c":3,"s":"\"(foo bar (baz| quux) zot)\"","i":49},"\n                 ",{"c":3,"s":"\"(foo (bar baz| quux) zot)\"","i":51},")\n                (",{"c":3,"s":"\"(a b ((c| d)) e f)\"","i":53},"\n                 ",{"c":3,"s":"\"(a (b (c| d)) e f)\"","i":55},"))\n   ((",{"c":3,"s":"\"C-{\"","i":29}," ",{"c":3,"s":"\"C-M-<right>\"","i":31}," ",{"c":3,"s":"\"ESC C-<right>\"","i":33},")\n                ",{"c":3,"s":"paredit-backward-barf-sexp","i":35},"\n                (",{"c":3,"s":"\"(foo (bar baz |quux) zot)\"","i":37},"\n                 ",{"c":3,"s":"\"(foo bar (baz |quux) zot)\"","i":39},"))\n\n   ",{"c":1,"s":"\"Miscellaneous Commands\""},"\n   (",{"c":3,"s":"\"M-S\"","i":17},"       ",{"c":3,"s":"paredit-split-sexp","i":19},"\n                (",{"c":3,"s":"\"(hello| world)\"","i":21},"\n                 ",{"c":3,"s":"\"(hello)| (world)\"","i":23},")\n                (",{"c":3,"s":"\"\\\"Hello, |world!\\\"\"","i":25},"\n                 ",{"c":3,"s":"\"\\\"Hello, \\\"| \\\"world!\\\"\"","i":27},"))\n   (",{"c":3,"s":"\"M-J\"","i":1},"       ",{"c":3,"s":"paredit-join-sexps","i":3},"\n                (",{"c":3,"s":"\"(hello)| (world)\"","i":5},"\n                 ",{"c":3,"s":"\"(hello| world)\"","i":7},")\n                (",{"c":3,"s":"\"\\\"Hello, \\\"| \\\"world!\\\"\"","i":9},"\n                 ",{"c":3,"s":"\"\\\"Hello, |world!\\\"\"","i":11},")\n                (",{"c":3,"s":"\"hello-\\n|  world\"","i":13},"\n                 ",{"c":3,"s":"\"hello-|world\"","i":15},"))\n   ",{"c":1,"s":"(\"C-c C-M-l\" paredit-recentre-on-sexp)"},"\n   ",{"c":1,"s":"(\"M-q\"       paredit-reindent-defun)"},"\n   ))\n       ",{"c":3,"s":"nil","i":575},")                             ",{"c":1,"s":"; end of PROGN\n"},"\n",{"c":1,"s":";;;;; Command Examples\n"},"\n(",{"c":5,"s":"eval-and-compile","i":1285},"\n  (",{"c":5,"s":"defmacro","i":1287}," ",{"c":5,"s":"paredit-do-commands","i":1289}," (",{"c":5,"s":"vars","i":1291}," ",{"c":5,"s":"string-case","i":1293}," ",{"c":5,"s":"&rest","i":1295}," ",{"c":5,"s":"body","i":1297},")\n    (",{"c":5,"s":"let","i":1299}," ((",{"c":5,"s":"spec","i":1301},"     (",{"c":5,"s":"nth","i":1303}," ",{"c":5,"s":"0","i":1305}," ",{"c":5,"s":"vars","i":1307},"))\n          (",{"c":5,"s":"keys","i":1309},"     (",{"c":5,"s":"nth","i":1311}," ",{"c":5,"s":"1","i":1313}," ",{"c":5,"s":"vars","i":1315},"))\n          (",{"c":5,"s":"fn","i":1317},"       (",{"c":5,"s":"nth","i":1319}," ",{"c":5,"s":"2","i":1321}," ",{"c":5,"s":"vars","i":1323},"))\n          (",{"c":5,"s":"examples","i":1325}," (",{"c":5,"s":"nth","i":1327}," ",{"c":5,"s":"3","i":1329}," ",{"c":5,"s":"vars","i":1331},")))\n      ",{"c":5,"s":"`","i":1333},"(",{"c":5,"s":"dolist","i":1335}," (",{"c":5,"s":",","i":1337},{"c":5,"s":"spec","i":1339}," ",{"c":5,"s":"paredit-commands","i":1341},")\n         (",{"c":5,"s":"if","i":1343}," (",{"c":5,"s":"stringp","i":1345}," ",{"c":5,"s":",","i":1347},{"c":5,"s":"spec","i":1349},")\n             ",{"c":5,"s":",","i":1351},{"c":5,"s":"string-case","i":1353},"\n           (",{"c":5,"s":"let","i":1355}," ((",{"c":5,"s":",","i":1357},{"c":5,"s":"keys","i":1359}," (",{"c":5,"s":"let","i":1361}," ((",{"c":5,"s":"k","i":1363}," (",{"c":5,"s":"car","i":1365}," ",{"c":5,"s":",","i":1367},{"c":5,"s":"spec","i":1369},")))\n                          (",{"c":5,"s":"cond","i":1371}," ((",{"c":5,"s":"stringp","i":1373}," ",{"c":5,"s":"k","i":1375},") (",{"c":5,"s":"list","i":1377}," ",{"c":5,"s":"k","i":1379},"))\n                                ((",{"c":5,"s":"listp","i":1381}," ",{"c":5,"s":"k","i":1383},") ",{"c":5,"s":"k","i":1385},")\n                                (",{"c":5,"s":"t","i":1387}," (",{"c":5,"s":"error","i":1389}," ",{"c":5,"s":"\"Invalid paredit command %s.\"","i":1391},"\n                                          ",{"c":5,"s":",","i":1393},{"c":5,"s":"spec","i":1395},")))))\n                 (",{"c":5,"s":",","i":1397},{"c":5,"s":"fn","i":1399}," (",{"c":5,"s":"cadr","i":1401}," ",{"c":5,"s":",","i":1403},{"c":5,"s":"spec","i":1405},"))\n                 (",{"c":5,"s":",","i":1407},{"c":5,"s":"examples","i":1409}," (",{"c":5,"s":"cddr","i":1411}," ",{"c":5,"s":",","i":1413},{"c":5,"s":"spec","i":1415},")))\n             ",{"c":5,"s":",","i":1417},{"c":5,"s":"@body","i":1419},")))))\n\n  (",{"c":5,"s":"put","i":1421}," ",{"c":5,"s":"'","i":1423},{"c":5,"s":"paredit-do-commands","i":1425}," ",{"c":5,"s":"'","i":1427},{"c":5,"s":"lisp-indent-function","i":1429}," ",{"c":5,"s":"2","i":1431},"))\n\n(",{"c":5,"s":"defun","i":1433}," ",{"c":5,"s":"paredit-define-keys","i":1435}," ()\n  (",{"c":5,"s":"paredit-do-commands","i":1437}," (",{"c":5,"s":"spec","i":1439}," ",{"c":5,"s":"keys","i":1441}," ",{"c":5,"s":"fn","i":1443}," ",{"c":5,"s":"examples","i":1445},")\n      ",{"c":5,"s":"nil","i":1447},"       ",{"c":5,"s":"; string case\n","i":1449},"    (",{"c":5,"s":"dolist","i":1451}," (",{"c":5,"s":"key","i":1453}," ",{"c":5,"s":"keys","i":1455},")\n      (",{"c":5,"s":"define-key","i":1457}," ",{"c":5,"s":"paredit-mode-map","i":1459}," (",{"c":5,"s":"read-kbd-macro","i":1461}," ",{"c":5,"s":"key","i":1463},") ",{"c":5,"s":"fn","i":1465},"))))\n\n(",{"c":5,"s":"defun","i":1467}," ",{"c":5,"s":"paredit-function-documentation","i":1469}," (",{"c":5,"s":"fn","i":1471},")\n  (",{"c":5,"s":"let","i":1473}," ((",{"c":5,"s":"original-doc","i":1475}," (",{"c":5,"s":"get","i":1477}," ",{"c":5,"s":"fn","i":1479}," ",{"c":5,"s":"'","i":1481},{"c":5,"s":"paredit-original-documentation","i":1483},"))\n        (",{"c":5,"s":"doc","i":1485}," (",{"c":5,"s":"documentation","i":1487}," ",{"c":5,"s":"fn","i":1489}," ",{"c":5,"s":"'","i":1491},{"c":5,"s":"function-documentation","i":1493},")))\n    (",{"c":5,"s":"or","i":1495}," ",{"c":5,"s":"original-doc","i":1497},"\n        (",{"c":5,"s":"progn","i":1499}," (",{"c":5,"s":"put","i":1501}," ",{"c":5,"s":"fn","i":1503}," ",{"c":5,"s":"'","i":1505},{"c":5,"s":"paredit-original-documentation","i":1507}," ",{"c":5,"s":"doc","i":1509},")\n               ",{"c":5,"s":"doc","i":1511},"))))\n\n(",{"c":5,"s":"defun","i":1513}," ",{"c":5,"s":"paredit-annotate-mode-with-examples","i":1515}," ()\n  (",{"c":5,"s":"let","i":1517}," ((",{"c":5,"s":"contents","i":1519},"\n         (",{"c":5,"s":"list","i":1521}," (",{"c":5,"s":"paredit-function-documentation","i":1523}," ",{"c":5,"s":"'","i":1525},{"c":5,"s":"paredit-mode","i":1527},"))))\n    (",{"c":5,"s":"paredit-do-commands","i":1529}," (",{"c":5,"s":"spec","i":1531}," ",{"c":5,"s":"keys","i":1533}," ",{"c":5,"s":"fn","i":1535}," ",{"c":5,"s":"examples","i":1537},")\n        (",{"c":5,"s":"push","i":1539}," (",{"c":5,"s":"concat","i":1541}," ",{"c":5,"s":"\"\\n\\n\"","i":1543}," ",{"c":5,"s":"spec","i":1545}," ",{"c":5,"s":"\"\\n\"","i":1547},")\n              ",{"c":5,"s":"contents","i":1549},")\n      (",{"c":5,"s":"let","i":1551}," ((",{"c":5,"s":"name","i":1553}," (",{"c":5,"s":"symbol-name","i":1555}," ",{"c":5,"s":"fn","i":1557},")))\n        (",{"c":5,"s":"if","i":1559}," (",{"c":5,"s":"string-match","i":1561}," (",{"c":5,"s":"symbol-name","i":1563}," ",{"c":5,"s":"'","i":1565},{"c":5,"s":"paredit-","i":1567},") ",{"c":5,"s":"name","i":1569},")\n            (",{"c":5,"s":"push","i":1571}," (",{"c":5,"s":"concat","i":1573}," ",{"c":5,"s":"\"\\n\\n\\\\[\"","i":1575}," ",{"c":5,"s":"name","i":1577}," ",{"c":5,"s":"\"]\\t\"","i":1579}," ",{"c":5,"s":"name","i":1581},"\n                          (",{"c":5,"s":"if","i":1583}," ",{"c":5,"s":"examples","i":1585},"\n                              (",{"c":5,"s":"mapconcat","i":1587}," (",{"c":5,"s":"lambda","i":1589}," (",{"c":5,"s":"example","i":1591},")\n                                           (",{"c":5,"s":"concat","i":1593},"\n                                            ",{"c":5,"s":"\"\\n\"","i":1595},"\n                                            (",{"c":5,"s":"mapconcat","i":1597}," ",{"c":5,"s":"'","i":1599},{"c":5,"s":"identity","i":1601},"\n                                                       ",{"c":5,"s":"example","i":1603},"\n                                                       ",{"c":5,"s":"\"\\n  --->\\n\"","i":1605},")\n                                            ",{"c":5,"s":"\"\\n\"","i":1607},"))\n                                         ",{"c":5,"s":"examples","i":1609},"\n                                         ",{"c":5,"s":"\"\"","i":1611},")\n                              ",{"c":5,"s":"\"\\n  (no examples)\\n\"","i":1613},"))\n                  ",{"c":5,"s":"contents","i":1615},"))))\n    (",{"c":5,"s":"put","i":1617}," ",{"c":5,"s":"'","i":1619},{"c":5,"s":"paredit-mode","i":1621}," ",{"c":5,"s":"'","i":1623},{"c":5,"s":"function-documentation","i":1625},"\n         (",{"c":5,"s":"apply","i":1627}," ",{"c":5,"s":"'","i":1629},{"c":5,"s":"concat","i":1631}," (",{"c":5,"s":"reverse","i":1633}," ",{"c":5,"s":"contents","i":1635},"))))\n  ",{"c":5,"s":";; PUT returns the huge string we just constructed, which we don't\n","i":1637},"  ",{"c":5,"s":";; want it to return.\n","i":1639},"  ",{"c":5,"s":"nil","i":1641},")\n\n(",{"c":5,"s":"defun","i":1643}," ",{"c":5,"s":"paredit-annotate-functions-with-examples","i":1645}," ()\n  (",{"c":5,"s":"paredit-do-commands","i":1647}," (",{"c":5,"s":"spec","i":1649}," ",{"c":5,"s":"keys","i":1651}," ",{"c":5,"s":"fn","i":1653}," ",{"c":5,"s":"examples","i":1655},")\n      ",{"c":5,"s":"nil","i":1657},"       ",{"c":5,"s":"; string case\n","i":1659},"    (",{"c":5,"s":"put","i":1661}," ",{"c":5,"s":"fn","i":1663}," ",{"c":5,"s":"'","i":1665},{"c":5,"s":"function-documentation","i":1667},"\n         (",{"c":5,"s":"concat","i":1669}," (",{"c":5,"s":"paredit-function-documentation","i":1671}," ",{"c":5,"s":"fn","i":1673},")\n                 ",{"c":5,"s":"\"\\n\\n\\\\<paredit-mode-map>\\\\[\"","i":1675}," (",{"c":5,"s":"symbol-name","i":1677}," ",{"c":5,"s":"fn","i":1679},") ",{"c":5,"s":"\"]\\n\"","i":1681},"\n                 (",{"c":5,"s":"mapconcat","i":1683}," (",{"c":5,"s":"lambda","i":1685}," (",{"c":5,"s":"example","i":1687},")\n                              (",{"c":5,"s":"concat","i":1689}," ",{"c":5,"s":"\"\\n\"","i":1691},"\n                                      (",{"c":5,"s":"mapconcat","i":1693}," ",{"c":5,"s":"'","i":1695},{"c":5,"s":"identity","i":1697},"\n                                                 ",{"c":5,"s":"example","i":1699},"\n                                                 ",{"c":5,"s":"\"\\n  ->\\n\"","i":1701},")\n                                      ",{"c":5,"s":"\"\\n\"","i":1703},"))\n                            ",{"c":5,"s":"examples","i":1705},"\n                            ",{"c":5,"s":"\"\"","i":1707},")))))\n\n",{"c":5,"s":";;;;; HTML Examples\n","i":1709},"\n(",{"c":5,"s":"defun","i":1711}," ",{"c":5,"s":"paredit-insert-html-examples","i":1713}," ()\n  ",{"c":5,"s":"\"Insert HTML for a paredit quick reference table.\"","i":1715},"\n  (",{"c":5,"s":"interactive","i":1717},")\n  (",{"c":5,"s":"let","i":1719}," ((",{"c":5,"s":"insert-lines","i":1721},"\n         (",{"c":5,"s":"lambda","i":1723}," (",{"c":5,"s":"&rest","i":1725}," ",{"c":5,"s":"lines","i":1727},")\n           (",{"c":5,"s":"mapc","i":1729}," (",{"c":5,"s":"lambda","i":1731}," (",{"c":5,"s":"line","i":1733},") (",{"c":5,"s":"insert","i":1735}," ",{"c":5,"s":"line","i":1737},") (",{"c":5,"s":"newline","i":1739},"))\n                 ",{"c":5,"s":"lines","i":1741},")))\n        (",{"c":5,"s":"html-keys","i":1743},"\n         (",{"c":5,"s":"lambda","i":1745}," (",{"c":5,"s":"keys","i":1747},")\n           (",{"c":5,"s":"mapconcat","i":1749}," ",{"c":5,"s":"'","i":1751},{"c":5,"s":"paredit-html-quote","i":1753}," ",{"c":5,"s":"keys","i":1755}," ",{"c":5,"s":"\", \"","i":1757},")))\n        (",{"c":5,"s":"html-example","i":1759},"\n         (",{"c":5,"s":"lambda","i":1761}," (",{"c":5,"s":"example","i":1763},")\n           (",{"c":5,"s":"concat","i":1765}," ",{"c":5,"s":"\"<table><tr><td><pre>\"","i":1767},"\n                   (",{"c":5,"s":"mapconcat","i":1769}," ",{"c":5,"s":"'","i":1771},{"c":5,"s":"paredit-html-quote","i":1773},"\n                              ",{"c":5,"s":"example","i":1775},"\n                              (",{"c":5,"s":"concat","i":1777}," ",{"c":5,"s":"\"</pre></td></tr><tr><td>\"","i":1779},"\n                                      ",{"c":5,"s":"\"    --->\"","i":1781},"\n                                      ",{"c":5,"s":"\"</td></tr><tr><td><pre>\"","i":1783},"))\n                   ",{"c":5,"s":"\"</pre></td></tr></table>\"","i":1785},")))\n        (",{"c":5,"s":"firstp","i":1787}," ",{"c":5,"s":"t","i":1789},"))\n    (",{"c":5,"s":"paredit-do-commands","i":1791}," (",{"c":5,"s":"spec","i":1793}," ",{"c":5,"s":"keys","i":1795}," ",{"c":5,"s":"fn","i":1797}," ",{"c":5,"s":"examples","i":1799},")\n        (",{"c":5,"s":"progn","i":1801}," (",{"c":5,"s":"if","i":1803}," (",{"c":5,"s":"not","i":1805}," ",{"c":5,"s":"firstp","i":1807},")\n                   (",{"c":5,"s":"insert","i":1809}," ",{"c":5,"s":"\"</table>\\n\"","i":1811},")\n                   (",{"c":5,"s":"setq","i":1813}," ",{"c":5,"s":"firstp","i":1815}," ",{"c":5,"s":"nil","i":1817},"))\n               (",{"c":5,"s":"funcall","i":1819}," ",{"c":5,"s":"insert-lines","i":1821},"\n                        (",{"c":5,"s":"concat","i":1823}," ",{"c":5,"s":"\"<h3>\"","i":1825}," ",{"c":5,"s":"spec","i":1827}," ",{"c":5,"s":"\"</h3>\"","i":1829},")\n                        ",{"c":5,"s":"\"<table border=\\\"1\\\" cellpadding=\\\"1\\\">\"","i":1831},"\n                        ",{"c":5,"s":"\"  <tr>\"","i":1833},"\n                        ",{"c":5,"s":"\"    <th>Command</th>\"","i":1835},"\n                        ",{"c":5,"s":"\"    <th>Keys</th>\"","i":1837},"\n                        ",{"c":5,"s":"\"    <th>Examples</th>\"","i":1839},"\n                        ",{"c":5,"s":"\"  </tr>\"","i":1841},"))\n      (",{"c":5,"s":"let","i":1843}," ((",{"c":5,"s":"name","i":1845}," (",{"c":5,"s":"symbol-name","i":1847}," ",{"c":5,"s":"fn","i":1849},")))\n        (",{"c":5,"s":"if","i":1851}," (",{"c":5,"s":"string-match","i":1853}," (",{"c":5,"s":"symbol-name","i":1855}," ",{"c":5,"s":"'","i":1857},{"c":5,"s":"paredit-","i":1859},") ",{"c":5,"s":"name","i":1861},")\n            (",{"c":5,"s":"funcall","i":1863}," ",{"c":5,"s":"insert-lines","i":1865},"\n                     ",{"c":5,"s":"\"  <tr>\"","i":1867},"\n                     (",{"c":5,"s":"concat","i":1869}," ",{"c":5,"s":"\"    <td><tt>\"","i":1871}," ",{"c":5,"s":"name","i":1873}," ",{"c":5,"s":"\"</tt></td>\"","i":1875},")\n                     (",{"c":5,"s":"concat","i":1877}," ",{"c":5,"s":"\"    <td align=\\\"center\\\">\"","i":1879},"\n                             (",{"c":5,"s":"funcall","i":1881}," ",{"c":5,"s":"html-keys","i":1883}," ",{"c":5,"s":"keys","i":1885},")\n                             ",{"c":5,"s":"\"</td>\"","i":1887},")\n                     (",{"c":5,"s":"concat","i":1889}," ",{"c":5,"s":"\"    <td>\"","i":1891},"\n                             (",{"c":5,"s":"if","i":1893}," ",{"c":5,"s":"examples","i":1895},"\n                                 (",{"c":5,"s":"mapconcat","i":1897}," ",{"c":5,"s":"html-example","i":1899}," ",{"c":5,"s":"examples","i":1901},"\n                                            ",{"c":5,"s":"\"<hr>\"","i":1903},")\n                                 ",{"c":5,"s":"\"(no examples)\"","i":1905},")\n                             ",{"c":5,"s":"\"</td>\"","i":1907},")\n                     ",{"c":5,"s":"\"  </tr>\"","i":1909},")))))\n  (",{"c":5,"s":"insert","i":1911}," ",{"c":5,"s":"\"</table>\\n\"","i":1913},"))\n\n(",{"c":5,"s":"defun","i":1915}," ",{"c":5,"s":"paredit-html-quote","i":1917}," (",{"c":5,"s":"string","i":1919},")\n  (",{"c":5,"s":"with-temp-buffer","i":1921},"\n    (",{"c":5,"s":"dotimes","i":1923}," (",{"c":5,"s":"i","i":1925}," (",{"c":5,"s":"length","i":1927}," ",{"c":5,"s":"string","i":1929},"))\n      (",{"c":5,"s":"insert","i":1931}," (",{"c":5,"s":"let","i":1933}," ((",{"c":5,"s":"c","i":1935}," (",{"c":5,"s":"elt","i":1937}," ",{"c":5,"s":"string","i":1939}," ",{"c":5,"s":"i","i":1941},")))\n                (",{"c":5,"s":"cond","i":1943}," ((",{"c":5,"s":"eq","i":1945}," ",{"c":5,"s":"c","i":1947}," ",{"c":5,"s":"?\\<","i":1949},") ",{"c":5,"s":"\"<\"","i":1951},")\n                      ((",{"c":5,"s":"eq","i":1953}," ",{"c":5,"s":"c","i":1955}," ",{"c":5,"s":"?\\>","i":1957},") ",{"c":5,"s":"\">\"","i":1959},")\n                      ((",{"c":5,"s":"eq","i":1961}," ",{"c":5,"s":"c","i":1963}," ",{"c":5,"s":"?\\&","i":1965},") ",{"c":5,"s":"\"&\"","i":1967},")\n                      ((",{"c":5,"s":"eq","i":1969}," ",{"c":5,"s":"c","i":1971}," ",{"c":5,"s":"?\\'","i":1973},") ",{"c":5,"s":"\"'\"","i":1975},")\n                      ((",{"c":5,"s":"eq","i":1977}," ",{"c":5,"s":"c","i":1979}," ",{"c":5,"s":"?\\\"","i":1981},") ",{"c":5,"s":"\"\"\"","i":1983},")\n                      (",{"c":5,"s":"t","i":1985}," ",{"c":5,"s":"c","i":1987},")))))\n    (",{"c":5,"s":"buffer-string","i":1989},")))\n\n",{"c":5,"s":";;;; Delimiter Insertion\n","i":1991},"\n(",{"c":3,"s":"eval-and-compile","i":577},"\n  (",{"c":3,"s":"defun","i":579}," ",{"c":3,"s":"paredit-conc-name","i":581}," (",{"c":3,"s":"&rest","i":583}," ",{"c":3,"s":"strings","i":585},")\n    (",{"c":3,"s":"intern","i":587}," (",{"c":3,"s":"apply","i":589}," ",{"c":3,"s":"'","i":591},{"c":3,"s":"concat","i":593}," ",{"c":3,"s":"strings","i":595},")))\n\n  (",{"c":3,"s":"defmacro","i":597}," ",{"c":3,"s":"define-paredit-pair","i":599}," (",{"c":3,"s":"open","i":601}," ",{"c":3,"s":"close","i":603}," ",{"c":3,"s":"name","i":605},")\n    ",{"c":3,"s":"`","i":607},"(",{"c":1,"s":"progn"},"\n       (",{"c":3,"s":"defun","i":609}," ",{"c":3,"s":",","i":611},"(",{"c":3,"s":"paredit-conc-name","i":613}," ",{"c":3,"s":"\"paredit-open-\"","i":615}," ",{"c":3,"s":"name","i":617},") (",{"c":3,"s":"&optional","i":619}," ",{"c":3,"s":"n","i":621},")\n         ",{"c":3,"s":",","i":623},"(",{"c":3,"s":"concat","i":625}," ",{"c":3,"s":"\"Insert a balanced \"","i":627}," ",{"c":3,"s":"name","i":629}," ",{"c":3,"s":"\" pair.\nWith a prefix argument N, put the closing \"","i":631}," ",{"c":3,"s":"name","i":633}," ",{"c":3,"s":"\" after N\n  S-expressions forward.\nIf the region is active, `transient-mark-mode' is enabled, and the\n  region's start and end fall in the same parenthesis depth, insert a\n  \"","i":635}," ",{"c":3,"s":"name","i":637}," ",{"c":3,"s":"\" pair around the region.\nIf in a string or a comment, insert a single \"","i":639}," ",{"c":3,"s":"name","i":641}," ",{"c":3,"s":"\".\nIf in a character literal, do nothing.  This prevents changing what was\n  in the character literal to a meaningful delimiter unintentionally.\"","i":643},")\n         (",{"c":3,"s":"interactive","i":645}," ",{"c":3,"s":"\"P\"","i":647},")\n         (",{"c":3,"s":"cond","i":649}," ((",{"c":3,"s":"or","i":651}," (",{"c":3,"s":"paredit-in-string-p","i":653},")\n                    (",{"c":3,"s":"paredit-in-comment-p","i":655},"))\n                (",{"c":3,"s":"insert","i":657}," ",{"c":3,"s":",","i":659},{"c":3,"s":"open","i":661},"))\n               ((",{"c":3,"s":"not","i":663}," (",{"c":3,"s":"paredit-in-char-p","i":665},"))\n                (",{"c":3,"s":"paredit-insert-pair","i":667}," ",{"c":3,"s":"n","i":669}," ",{"c":3,"s":",","i":671},{"c":3,"s":"open","i":673}," ",{"c":3,"s":",","i":675},{"c":3,"s":"close","i":677}," ",{"c":3,"s":"'","i":679},{"c":3,"s":"goto-char","i":681},"))))\n       (",{"c":3,"s":"defun","i":495}," ",{"c":3,"s":",","i":497},"(",{"c":3,"s":"paredit-conc-name","i":499}," ",{"c":3,"s":"\"paredit-close-\"","i":501}," ",{"c":3,"s":"name","i":503},") ()\n         ",{"c":3,"s":",","i":505},"(",{"c":3,"s":"concat","i":507}," ",{"c":3,"s":"\"Move past one closing delimiter and reindent.\n\\(Agnostic to the specific closing delimiter.)\nIf in a string or comment, insert a single closing \"","i":509}," ",{"c":3,"s":"name","i":511}," ",{"c":3,"s":"\".\nIf in a character literal, do nothing.  This prevents changing what was\n  in the character literal to a meaningful delimiter unintentionally.\"","i":513},")\n         (",{"c":3,"s":"interactive","i":515},")\n         (",{"c":3,"s":"paredit-move-past-close","i":517}," ",{"c":3,"s":",","i":519},{"c":3,"s":"close","i":521},"))\n       (",{"c":3,"s":"defun","i":387}," ",{"c":3,"s":",","i":389},"(",{"c":3,"s":"paredit-conc-name","i":391}," ",{"c":3,"s":"\"paredit-close-\"","i":393}," ",{"c":3,"s":"name","i":395}," ",{"c":3,"s":"\"-and-newline\"","i":397},") ()\n         ",{"c":3,"s":",","i":399},"(",{"c":3,"s":"concat","i":401}," ",{"c":3,"s":"\"Move past one closing delimiter, add a newline,\"","i":403},"\n                  ",{"c":3,"s":"\" and reindent.\nIf there was a margin comment after the closing delimiter, preserve it\n  on the same line.\"","i":405},")\n         (",{"c":3,"s":"interactive","i":407},")\n         (",{"c":3,"s":"paredit-move-past-close-and-newline","i":409}," ",{"c":3,"s":",","i":411},{"c":3,"s":"close","i":413},"))\n       ",{"c":1,"s":"(defun ,(paredit-conc-name \"paredit-wrap-\" name)\n           (&optional argument)\n         ,(concat \"Wrap the following S-expression.\nSee `paredit-wrap-sexp' for more details.\")\n         (interactive \"P\")\n         (paredit-wrap-sexp argument ,open ,close))"},"\n       ",{"c":1,"s":"(add-to-list 'paredit-wrap-commands\n                    ',(paredit-conc-name \"paredit-wrap-\" name))"},")))\n\n",{"c":1,"s":"(defvar paredit-wrap-commands '(paredit-wrap-sexp)\n  \"List of paredit commands that wrap S-expressions.\nUsed by `paredit-yank-pop'; for internal paredit use only.\")"},"\n\n",{"c":1,"s":"(define-paredit-pair ?\\( ?\\) \"round\")"},"\n",{"c":1,"s":"(define-paredit-pair ?\\[ ?\\] \"square\")"},"\n",{"c":1,"s":"(define-paredit-pair ?\\{ ?\\} \"curly\")"},"\n",{"c":1,"s":"(define-paredit-pair ?\\< ?\\> \"angled\")"},"\n\n",{"c":1,"s":";;; Aliases for the old names.\n"},"\n",{"c":1,"s":"(defalias 'paredit-open-parenthesis 'paredit-open-round)"},"\n",{"c":1,"s":"(defalias 'paredit-close-parenthesis 'paredit-close-round)"},"\n",{"c":1,"s":"(defalias 'paredit-close-parenthesis-and-newline\n  'paredit-close-round-and-newline)"},"\n\n",{"c":1,"s":"(defalias 'paredit-open-bracket 'paredit-open-square)"},"\n",{"c":1,"s":"(defalias 'paredit-close-bracket 'paredit-close-square)"},"\n",{"c":1,"s":"(defalias 'paredit-close-bracket-and-newline\n  'paredit-close-square-and-newline)"},"\n\n(",{"c":5,"s":"defun","i":1993}," ",{"c":5,"s":"paredit-move-past-close","i":1995}," (",{"c":5,"s":"close","i":1997},")\n  (",{"c":1,"s":"cond"}," ((",{"c":3,"s":"or","i":683}," (",{"c":3,"s":"paredit-in-string-p","i":685},")\n             (",{"c":3,"s":"paredit-in-comment-p","i":687},"))\n         (",{"c":3,"s":"insert","i":689}," ",{"c":3,"s":"close","i":691},"))\n        ",{"c":1,"s":"((not (paredit-in-char-p))\n         (paredit-move-past-close-and-reindent close)\n         (paredit-blink-paren-match nil))"},"))\n\n(",{"c":5,"s":"defun","i":1999}," ",{"c":5,"s":"paredit-move-past-close-and-newline","i":2001}," (",{"c":5,"s":"close","i":2003},")\n  ",{"c":1,"s":"(if (or (paredit-in-string-p)\n          (paredit-in-comment-p))\n      (insert close)\n    (if (paredit-in-char-p) (forward-char))\n    (paredit-move-past-close-and-reindent close)\n    (let ((comment.point (paredit-find-comment-on-line)))\n      (newline)\n      (if comment.point\n          (save-excursion\n            (forward-line -1)\n            (end-of-line)\n            (indent-to (cdr comment.point))\n            (insert (car comment.point)))))\n    (lisp-indent-line)\n    (paredit-ignore-sexp-errors (indent-sexp))\n    (paredit-blink-paren-match t))"},")\n\n(",{"c":5,"s":"defun","i":2005}," ",{"c":5,"s":"paredit-find-comment-on-line","i":2007}," ()\n  ",{"c":1,"s":"\"Find a margin comment on the current line.\nReturn nil if there is no such comment or if there is anything but\n  whitespace until such a comment.\nIf such a comment exists, delete the comment (including all leading\n  whitespace) and return a cons whose car is the comment as a string\n  and whose cdr is the point of the comment's initial semicolon,\n  relative to the start of the line.\""},"\n  (",{"c":1,"s":"save-excursion"},"\n    ",{"c":1,"s":"(paredit-skip-whitespace t (point-at-eol))"},"\n    (",{"c":1,"s":"and"}," ",{"c":1,"s":"(eq ?\\; (char-after))"},"\n         ",{"c":1,"s":"(not (eq ?\\; (char-after (1+ (point)))))"},"\n         ",{"c":1,"s":"(not (or (paredit-in-string-p)\n                  (paredit-in-char-p)))"},"\n         (",{"c":3,"s":"let*","i":693}," ((",{"c":3,"s":"start","i":695},"                  ",{"c":1,"s":";Move to before the semicolon.\n"},"                 (",{"c":3,"s":"progn","i":697}," (",{"c":3,"s":"backward-char","i":699},") (",{"c":3,"s":"point","i":701},")))\n                (",{"c":3,"s":"comment","i":703},"\n                 (",{"c":3,"s":"buffer-substring","i":705}," ",{"c":3,"s":"start","i":707}," (",{"c":3,"s":"point-at-eol","i":709},"))))\n           (",{"c":3,"s":"paredit-skip-whitespace","i":711}," ",{"c":3,"s":"nil","i":713}," (",{"c":3,"s":"point-at-bol","i":715},"))\n           (",{"c":3,"s":"delete-region","i":717}," (",{"c":3,"s":"point","i":719},") (",{"c":3,"s":"point-at-eol","i":721},"))\n           (",{"c":3,"s":"cons","i":723}," ",{"c":3,"s":"comment","i":725}," (",{"c":3,"s":"-","i":727}," ",{"c":3,"s":"start","i":729}," (",{"c":3,"s":"point-at-bol","i":731},")))))))\n\n(",{"c":5,"s":"defun","i":2009}," ",{"c":5,"s":"paredit-insert-pair","i":2011}," (",{"c":5,"s":"n","i":2013}," ",{"c":5,"s":"open","i":2015}," ",{"c":5,"s":"close","i":2017}," ",{"c":5,"s":"forward","i":2019},")\n  (",{"c":5,"s":"let*","i":2021}," ((",{"c":5,"s":"regionp","i":2023},"\n          (",{"c":5,"s":"and","i":2025}," (",{"c":5,"s":"paredit-region-active-p","i":2027},")\n               (",{"c":5,"s":"paredit-region-safe-for-insert-p","i":2029},")))\n         (",{"c":5,"s":"end","i":2031},"\n          (",{"c":5,"s":"and","i":2033}," ",{"c":5,"s":"regionp","i":2035},"\n               (",{"c":5,"s":"not","i":2037}," ",{"c":5,"s":"n","i":2039},")\n               (",{"c":5,"s":"prog1","i":2041}," (",{"c":5,"s":"region-end","i":2043},") (",{"c":5,"s":"goto-char","i":2045}," (",{"c":5,"s":"region-beginning","i":2047},"))))))\n    (",{"c":5,"s":"let","i":2049}," ((",{"c":5,"s":"spacep","i":2051}," (",{"c":5,"s":"paredit-space-for-delimiter-p","i":2053}," ",{"c":5,"s":"nil","i":2055}," ",{"c":5,"s":"open","i":2057},")))\n      (",{"c":5,"s":"if","i":2059}," ",{"c":5,"s":"spacep","i":2061}," (",{"c":5,"s":"insert","i":2063}," ",{"c":5,"s":"\" \"","i":2065},"))\n      (",{"c":5,"s":"insert","i":2067}," ",{"c":5,"s":"open","i":2069},")\n      (",{"c":5,"s":"save-excursion","i":2071},"\n        ",{"c":5,"s":";; Move past the desired region.\n","i":2073},"        (",{"c":5,"s":"cond","i":2075}," (",{"c":5,"s":"n","i":2077}," (",{"c":5,"s":"funcall","i":2079}," ",{"c":5,"s":"forward","i":2081},"\n                          (",{"c":5,"s":"save-excursion","i":2083},"\n                            (",{"c":5,"s":"forward-sexp","i":2085}," (",{"c":5,"s":"prefix-numeric-value","i":2087}," ",{"c":5,"s":"n","i":2089},"))\n                            (",{"c":5,"s":"point","i":2091},"))))\n              (",{"c":5,"s":"regionp","i":2093}," (",{"c":5,"s":"funcall","i":2095}," ",{"c":5,"s":"forward","i":2097}," (",{"c":5,"s":"+","i":2099}," ",{"c":5,"s":"end","i":2101}," (",{"c":5,"s":"if","i":2103}," ",{"c":5,"s":"spacep","i":2105}," ",{"c":5,"s":"2","i":2107}," ",{"c":5,"s":"1","i":2109},")))))\n        (",{"c":5,"s":"insert","i":2111}," ",{"c":5,"s":"close","i":2113},")\n        (",{"c":5,"s":"if","i":2115}," (",{"c":5,"s":"paredit-space-for-delimiter-p","i":2117}," ",{"c":5,"s":"t","i":2119}," ",{"c":5,"s":"close","i":2121},")\n            (",{"c":5,"s":"insert","i":2123}," ",{"c":5,"s":"\" \"","i":2125},"))))))\n\n(",{"c":5,"s":"defun","i":2127}," ",{"c":5,"s":"paredit-region-safe-for-insert-p","i":2129}," ()\n  (",{"c":5,"s":"save-excursion","i":2131},"\n    (",{"c":5,"s":"let","i":2133}," ((",{"c":5,"s":"beginning","i":2135}," (",{"c":5,"s":"region-beginning","i":2137},"))\n          (",{"c":5,"s":"end","i":2139}," (",{"c":5,"s":"region-end","i":2141},")))\n      (",{"c":5,"s":"goto-char","i":2143}," ",{"c":5,"s":"beginning","i":2145},")\n      (",{"c":5,"s":"let*","i":2147}," ((",{"c":5,"s":"beginning-state","i":2149}," (",{"c":5,"s":"paredit-current-parse-state","i":2151},"))\n             (",{"c":5,"s":"end-state","i":2153},"\n              (",{"c":5,"s":"parse-partial-sexp","i":2155}," ",{"c":5,"s":"beginning","i":2157}," ",{"c":5,"s":"end","i":2159}," ",{"c":5,"s":"nil","i":2161}," ",{"c":5,"s":"nil","i":2163}," ",{"c":5,"s":"beginning-state","i":2165},")))\n        (",{"c":5,"s":"and","i":2167}," (",{"c":5,"s":"=","i":2169},"  (",{"c":5,"s":"nth","i":2171}," ",{"c":5,"s":"0","i":2173}," ",{"c":5,"s":"beginning-state","i":2175},")   ",{"c":5,"s":"; 0. depth in parens\n","i":2177},"                 (",{"c":5,"s":"nth","i":2179}," ",{"c":5,"s":"0","i":2181}," ",{"c":5,"s":"end-state","i":2183},"))\n             (",{"c":5,"s":"eq","i":2185}," (",{"c":5,"s":"nth","i":2187}," ",{"c":5,"s":"3","i":2189}," ",{"c":5,"s":"beginning-state","i":2191},")   ",{"c":5,"s":"; 3. non-nil if inside a\n","i":2193},"                 (",{"c":5,"s":"nth","i":2195}," ",{"c":5,"s":"3","i":2197}," ",{"c":5,"s":"end-state","i":2199},"))        ",{"c":5,"s":";    string\n","i":2201},"             (",{"c":5,"s":"eq","i":2203}," (",{"c":5,"s":"nth","i":2205}," ",{"c":5,"s":"4","i":2207}," ",{"c":5,"s":"beginning-state","i":2209},")   ",{"c":5,"s":"; 4. comment status, yada\n","i":2211},"                 (",{"c":5,"s":"nth","i":2213}," ",{"c":5,"s":"4","i":2215}," ",{"c":5,"s":"end-state","i":2217},"))\n             (",{"c":5,"s":"eq","i":2219}," (",{"c":5,"s":"nth","i":2221}," ",{"c":5,"s":"5","i":2223}," ",{"c":5,"s":"beginning-state","i":2225},")   ",{"c":5,"s":"; 5. t if following char\n","i":2227},"                 (",{"c":5,"s":"nth","i":2229}," ",{"c":5,"s":"5","i":2231}," ",{"c":5,"s":"end-state","i":2233},")))))))   ",{"c":5,"s":";    quote\n","i":2235},"\n",{"c":1,"s":"(defvar paredit-space-for-delimiter-predicates nil\n  \"List of predicates for whether to put space by delimiter at point.\nEach predicate is a function that is is applied to two arguments, ENDP\n  and DELIMITER, and that returns a boolean saying whether to put a\n  space next to the delimiter -- before the delimiter if ENDP is false,\n  after the delimiter if ENDP is true.\nIf any predicate returns false, no space is inserted: every predicate\n  has veto power.\nEach predicate may assume that the point is not at the beginning of the\n  buffer, if ENDP is false, or at the end of the buffer, if ENDP is\n  true; and that the point is not preceded, if ENDP is false, or\n  followed, if ENDP is true, by a word or symbol constituent, a quote,\n  or the delimiter matching DELIMITER.\nEach predicate should examine only text before the point, if ENDP is\n  false, or only text after the point, if ENDP is true.\")"},"\n\n(",{"c":5,"s":"defun","i":2237}," ",{"c":5,"s":"paredit-space-for-delimiter-p","i":2239}," (",{"c":5,"s":"endp","i":2241}," ",{"c":5,"s":"delimiter","i":2243},")\n  ",{"c":5,"s":";; If at the buffer limit, don't insert a space.  If there is a word,\n","i":2245},"  ",{"c":5,"s":";; symbol, other quote, or non-matching parenthesis delimiter (i.e. a\n","i":2247},"  ",{"c":5,"s":";; close when want an open the string or an open when we want to\n","i":2249},"  ",{"c":5,"s":";; close the string), do insert a space.\n","i":2251},"  (",{"c":1,"s":"and"}," (",{"c":3,"s":"not","i":733}," (",{"c":3,"s":"if","i":735}," ",{"c":3,"s":"endp","i":737}," (",{"c":3,"s":"eobp","i":739},") (",{"c":3,"s":"bobp","i":741},")))\n       (",{"c":3,"s":"memq","i":415}," (",{"c":3,"s":"char-syntax","i":523}," (",{"c":3,"s":"if","i":525}," ",{"c":3,"s":"endp","i":527}," (",{"c":3,"s":"char-after","i":529},") (",{"c":3,"s":"char-before","i":531},")))\n             (",{"c":1,"s":"list"}," ",{"c":1,"s":"?w"}," ",{"c":1,"s":"?_"}," ",{"c":1,"s":"?\\\""},"\n                   (",{"c":3,"s":"let","i":417}," ((",{"c":3,"s":"matching","i":419}," (",{"c":3,"s":"matching-paren","i":421}," ",{"c":3,"s":"delimiter","i":423},")))\n                     (",{"c":3,"s":"and","i":425}," ",{"c":3,"s":"matching","i":427}," (",{"c":3,"s":"char-syntax","i":429}," ",{"c":3,"s":"matching","i":431},")))\n                   ",{"c":1,"s":"(and (not endp)\n                        (eq ?\\\" (char-syntax delimiter))\n                        ?\\) )"},"))\n       ",{"c":1,"s":"(catch 'exit\n         (dolist (predicate paredit-space-for-delimiter-predicates)\n           (if (not (funcall predicate endp delimiter))\n               (throw 'exit nil)))\n         t)"},"))\n\n(",{"c":5,"s":"defun","i":2253}," ",{"c":5,"s":"paredit-move-past-close-and-reindent","i":2255}," ",{"c":1,"s":"(close)"},"\n  ",{"c":1,"s":"(let ((open (paredit-missing-close)))\n    (if open\n        (if (eq close (matching-paren open))\n            (save-excursion\n              (message \"Missing closing delimiter: %c\" close)\n              (insert close))\n            (error \"Mismatched missing closing delimiter: %c ... %c\"\n                   open close))))"},"\n  ",{"c":1,"s":"(up-list)"},"\n  (",{"c":3,"s":"if","i":743}," (",{"c":3,"s":"catch","i":745}," ",{"c":3,"s":"'","i":747},{"c":3,"s":"return","i":749},"                    ",{"c":3,"s":"; This CATCH returns T if it\n","i":751},"        (",{"c":3,"s":"while","i":753}," ",{"c":3,"s":"t","i":755},"                        ",{"c":3,"s":"; should delete leading spaces\n","i":757},"          (",{"c":3,"s":"save-excursion","i":759},"               ",{"c":3,"s":"; and NIL if not.\n","i":761},"            (",{"c":3,"s":"let","i":763}," ((",{"c":3,"s":"before-paren","i":765}," (",{"c":3,"s":"1-","i":767}," (",{"c":3,"s":"point","i":769},"))))\n              (",{"c":3,"s":"back-to-indentation","i":771},")\n              (",{"c":3,"s":"cond","i":773}," ((",{"c":3,"s":"not","i":775}," (",{"c":3,"s":"eq","i":777}," (",{"c":3,"s":"point","i":779},") ",{"c":3,"s":"before-paren","i":781},"))\n                     ",{"c":3,"s":";; Can't call PAREDIT-DELETE-LEADING-WHITESPACE\n","i":783},"                     ",{"c":3,"s":";; here -- we must return from SAVE-EXCURSION\n","i":785},"                     ",{"c":3,"s":";; first.\n","i":787},"                     (",{"c":3,"s":"throw","i":789}," ",{"c":3,"s":"'","i":791},{"c":3,"s":"return","i":793}," ",{"c":3,"s":"t","i":795},"))\n                    ((",{"c":3,"s":"save-excursion","i":797}," (",{"c":3,"s":"forward-line","i":799}," ",{"c":3,"s":"-1","i":801},")\n                                     (",{"c":3,"s":"end-of-line","i":803},")\n                                     (",{"c":3,"s":"paredit-in-comment-p","i":805},"))\n                     ",{"c":1,"s":";; Moving the closing delimiter any further\n"},"                     ",{"c":1,"s":";; would put it into a comment, so we just\n"},"                     ",{"c":1,"s":";; indent the closing delimiter where it is and\n"},"                     ",{"c":1,"s":";; abort the loop, telling its continuation that\n"},"                     ",{"c":1,"s":";; no leading whitespace should be deleted.\n"},"                     (",{"c":3,"s":"lisp-indent-line","i":807},")\n                     (",{"c":3,"s":"throw","i":809}," ",{"c":3,"s":"'","i":811},{"c":3,"s":"return","i":813}," ",{"c":3,"s":"nil","i":815},"))\n                    (",{"c":3,"s":"t","i":817}," (",{"c":3,"s":"delete-indentation","i":819},")))))))\n      (",{"c":3,"s":"paredit-delete-leading-whitespace","i":821},")))\n\n",{"c":1,"s":"(defun paredit-missing-close ()\n  (save-excursion\n    (paredit-handle-sexp-errors (backward-up-list)\n      (error \"Not inside a list.\"))\n    (let ((open (char-after)))\n      (paredit-handle-sexp-errors (progn (forward-sexp) nil)\n        open))))"},"\n\n(",{"c":5,"s":"defun","i":2257}," ",{"c":5,"s":"paredit-delete-leading-whitespace","i":2259}," ()\n  ",{"c":1,"s":";; This assumes that we're on the closing delimiter already.\n"},"  (",{"c":5,"s":"save-excursion","i":2261},"\n    (",{"c":5,"s":"backward-char","i":2263},")\n    (",{"c":5,"s":"while","i":2265}," (",{"c":5,"s":"let","i":2267}," ((",{"c":5,"s":"syn","i":2269}," (",{"c":5,"s":"char-syntax","i":2271}," (",{"c":5,"s":"char-before","i":2273},"))))\n             (",{"c":5,"s":"and","i":2275}," (",{"c":5,"s":"or","i":2277}," (",{"c":5,"s":"eq","i":2279}," ",{"c":5,"s":"syn","i":2281}," ",{"c":5,"s":"?\\ ","i":2283},") (",{"c":5,"s":"eq","i":2285}," ",{"c":5,"s":"syn","i":2287}," ",{"c":5,"s":"?-","i":2289},"))     ",{"c":5,"s":"; whitespace syntax\n","i":2291},"                  ",{"c":5,"s":";; The above line is a perfect example of why the\n","i":2293},"                  ",{"c":5,"s":";; following test is necessary.\n","i":2295},"                  (",{"c":5,"s":"not","i":2297}," (",{"c":5,"s":"paredit-in-char-p","i":2299}," (",{"c":5,"s":"1-","i":2301}," (",{"c":5,"s":"point","i":2303},"))))))\n      (",{"c":5,"s":"backward-delete-char","i":2305}," ",{"c":5,"s":"1","i":2307},"))))\n\n(",{"c":5,"s":"defun","i":2309}," ",{"c":5,"s":"paredit-blink-paren-match","i":2311}," (",{"c":5,"s":"another-line-p","i":2313},")\n  (",{"c":5,"s":"if","i":2315}," (",{"c":5,"s":"and","i":2317}," ",{"c":5,"s":"blink-matching-paren","i":2319},"\n           (",{"c":5,"s":"or","i":2321}," (",{"c":5,"s":"not","i":2323}," ",{"c":5,"s":"show-paren-mode","i":2325},") ",{"c":5,"s":"another-line-p","i":2327},"))\n      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":2329},"\n        (",{"c":5,"s":"save-excursion","i":2331},"\n          (",{"c":5,"s":"backward-sexp","i":2333},")\n          (",{"c":5,"s":"forward-sexp","i":2335},")\n          ",{"c":5,"s":";; SHOW-PAREN-MODE inhibits any blinking, so we disable it\n","i":2337},"          ",{"c":5,"s":";; locally here.\n","i":2339},"          (",{"c":5,"s":"let","i":2341}," ((",{"c":5,"s":"show-paren-mode","i":2343}," ",{"c":5,"s":"nil","i":2345},"))\n            (",{"c":5,"s":"blink-matching-open","i":2347},"))))))\n\n(",{"c":5,"s":"defun","i":2349}," ",{"c":5,"s":"paredit-doublequote","i":2351}," (",{"c":5,"s":"&optional","i":2353}," ",{"c":5,"s":"n","i":2355},")\n  ",{"c":5,"s":"\"Insert a pair of double-quotes.\nWith a prefix argument N, wrap the following N S-expressions in\n  double-quotes, escaping intermediate characters if necessary.\nIf the region is active, `transient-mark-mode' is enabled, and the\n  region's start and end fall in the same parenthesis depth, insert a\n  pair of double-quotes around the region, again escaping intermediate\n  characters if necessary.\nInside a comment, insert a literal double-quote.\nAt the end of a string, move past the closing double-quote.\nIn the middle of a string, insert a backslash-escaped double-quote.\nIf in a character literal, do nothing.  This prevents accidentally\n  changing a what was in the character literal to become a meaningful\n  delimiter unintentionally.\"","i":2357},"\n  (",{"c":5,"s":"interactive","i":2359}," ",{"c":5,"s":"\"P\"","i":2361},")\n  (",{"c":5,"s":"cond","i":2363}," ((",{"c":5,"s":"paredit-in-string-p","i":2365},")\n         (",{"c":5,"s":"if","i":2367}," (",{"c":5,"s":"eq","i":2369}," (",{"c":5,"s":"cdr","i":2371}," (",{"c":5,"s":"paredit-string-start+end-points","i":2373},"))\n                 (",{"c":5,"s":"point","i":2375},"))\n             (",{"c":5,"s":"forward-char","i":2377},")             ",{"c":5,"s":"; We're on the closing quote.\n","i":2379},"             (",{"c":5,"s":"insert","i":2381}," ",{"c":5,"s":"?\\\\","i":2383}," ",{"c":5,"s":"?\\\"","i":2385}," )))\n        ((",{"c":5,"s":"paredit-in-comment-p","i":2387},")\n         (",{"c":5,"s":"insert","i":2389}," ",{"c":5,"s":"?\\\"","i":2391}," ))\n        ((",{"c":5,"s":"not","i":2393}," (",{"c":5,"s":"paredit-in-char-p","i":2395},"))\n         (",{"c":5,"s":"paredit-insert-pair","i":2397}," ",{"c":5,"s":"n","i":2399}," ",{"c":5,"s":"?\\\"","i":2401}," ",{"c":5,"s":"?\\\"","i":2403}," ",{"c":5,"s":"'","i":2405},{"c":5,"s":"paredit-forward-for-quote","i":2407},"))))\n\n(",{"c":5,"s":"defun","i":2409}," ",{"c":5,"s":"paredit-meta-doublequote","i":2411}," (",{"c":5,"s":"&optional","i":2413}," ",{"c":5,"s":"n","i":2415},")\n  ",{"c":5,"s":"\"Move to the end of the string, insert a newline, and indent.\nIf not in a string, act as `paredit-doublequote'; if no prefix argument\n  is specified and the region is not active or `transient-mark-mode' is\n  disabled, the default is to wrap one S-expression, however, not\n  zero.\"","i":2417},"\n  (",{"c":5,"s":"interactive","i":2419}," ",{"c":5,"s":"\"P\"","i":2421},")\n  (",{"c":5,"s":"if","i":2423}," (",{"c":5,"s":"not","i":2425}," (",{"c":5,"s":"paredit-in-string-p","i":2427},"))\n      (",{"c":5,"s":"paredit-doublequote","i":2429}," (",{"c":5,"s":"or","i":2431}," ",{"c":5,"s":"n","i":2433},"\n                               (",{"c":5,"s":"and","i":2435}," (",{"c":5,"s":"not","i":2437}," (",{"c":5,"s":"paredit-region-active-p","i":2439},"))\n                                    ",{"c":5,"s":"1","i":2441},")))\n    (",{"c":5,"s":"let","i":2443}," ((",{"c":5,"s":"start+end","i":2445}," (",{"c":5,"s":"paredit-string-start+end-points","i":2447},")))\n      (",{"c":5,"s":"goto-char","i":2449}," (",{"c":5,"s":"1+","i":2451}," (",{"c":5,"s":"cdr","i":2453}," ",{"c":5,"s":"start+end","i":2455},")))\n      (",{"c":5,"s":"newline","i":2457},")\n      (",{"c":5,"s":"lisp-indent-line","i":2459},")\n      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":2461}," (",{"c":5,"s":"indent-sexp","i":2463},")))))\n\n(",{"c":5,"s":"defun","i":2465}," ",{"c":5,"s":"paredit-forward-for-quote","i":2467}," (",{"c":5,"s":"end","i":2469},")\n  (",{"c":5,"s":"let","i":2471}," ((",{"c":5,"s":"state","i":2473}," (",{"c":5,"s":"paredit-current-parse-state","i":2475},")))\n    (",{"c":5,"s":"while","i":2477}," (",{"c":5,"s":"<","i":2479}," (",{"c":5,"s":"point","i":2481},") ",{"c":5,"s":"end","i":2483},")\n      (",{"c":5,"s":"let","i":2485}," ((",{"c":5,"s":"new-state","i":2487}," (",{"c":5,"s":"parse-partial-sexp","i":2489}," (",{"c":5,"s":"point","i":2491},") (",{"c":5,"s":"1+","i":2493}," (",{"c":5,"s":"point","i":2495},"))\n                                           ",{"c":5,"s":"nil","i":2497}," ",{"c":5,"s":"nil","i":2499}," ",{"c":5,"s":"state","i":2501},")))\n        (",{"c":5,"s":"if","i":2503}," (",{"c":5,"s":"paredit-in-string-p","i":2505}," ",{"c":5,"s":"new-state","i":2507},")\n            (",{"c":5,"s":"if","i":2509}," (",{"c":5,"s":"not","i":2511}," (",{"c":5,"s":"paredit-in-string-escape-p","i":2513},"))\n                (",{"c":5,"s":"setq","i":2515}," ",{"c":5,"s":"state","i":2517}," ",{"c":5,"s":"new-state","i":2519},")\n              ",{"c":5,"s":";; Escape character: turn it into an escaped escape\n","i":2521},"              ",{"c":5,"s":";; character by appending another backslash.\n","i":2523},"              (",{"c":5,"s":"insert","i":2525}," ",{"c":5,"s":"?\\\\","i":2527}," )\n              ",{"c":5,"s":";; Now the point is after both escapes, and we want to\n","i":2529},"              ",{"c":5,"s":";; rescan from before the first one to after the second\n","i":2531},"              ",{"c":5,"s":";; one.\n","i":2533},"              (",{"c":5,"s":"setq","i":2535}," ",{"c":5,"s":"state","i":2537},"\n                    (",{"c":5,"s":"parse-partial-sexp","i":2539}," (",{"c":5,"s":"-","i":2541}," (",{"c":5,"s":"point","i":2543},") ",{"c":5,"s":"2","i":2545},") (",{"c":5,"s":"point","i":2547},")\n                                        ",{"c":5,"s":"nil","i":2549}," ",{"c":5,"s":"nil","i":2551}," ",{"c":5,"s":"state","i":2553},"))\n              ",{"c":5,"s":";; Advance the end point, since we just inserted a new\n","i":2555},"              ",{"c":5,"s":";; character.\n","i":2557},"              (",{"c":5,"s":"setq","i":2559}," ",{"c":5,"s":"end","i":2561}," (",{"c":5,"s":"1+","i":2563}," ",{"c":5,"s":"end","i":2565},")))\n          ",{"c":5,"s":";; String: escape by inserting a backslash before the quote.\n","i":2567},"          (",{"c":5,"s":"backward-char","i":2569},")\n          (",{"c":5,"s":"insert","i":2571}," ",{"c":5,"s":"?\\\\","i":2573}," )\n          ",{"c":5,"s":";; The point is now between the escape and the quote, and we\n","i":2575},"          ",{"c":5,"s":";; want to rescan from before the escape to after the quote.\n","i":2577},"          (",{"c":5,"s":"setq","i":2579}," ",{"c":5,"s":"state","i":2581},"\n                (",{"c":5,"s":"parse-partial-sexp","i":2583}," (",{"c":5,"s":"1-","i":2585}," (",{"c":5,"s":"point","i":2587},")) (",{"c":5,"s":"1+","i":2589}," (",{"c":5,"s":"point","i":2591},"))\n                                    ",{"c":5,"s":"nil","i":2593}," ",{"c":5,"s":"nil","i":2595}," ",{"c":5,"s":"state","i":2597},"))\n          ",{"c":5,"s":";; Advance the end point for the same reason as above.\n","i":2599},"          (",{"c":5,"s":"setq","i":2601}," ",{"c":5,"s":"end","i":2603}," (",{"c":5,"s":"1+","i":2605}," ",{"c":5,"s":"end","i":2607},")))))))\n\n",{"c":5,"s":";;;; Escape Insertion\n","i":2609},"\n(",{"c":5,"s":"defun","i":2611}," ",{"c":5,"s":"paredit-backslash","i":2613}," ()\n  ",{"c":5,"s":"\"Insert a backslash followed by a character to escape.\"","i":2615},"\n  (",{"c":5,"s":"interactive","i":2617},")\n  (",{"c":5,"s":"insert","i":2619}," ",{"c":5,"s":"?\\\\","i":2621}," )\n  ",{"c":5,"s":";; This funny conditional is necessary because PAREDIT-IN-COMMENT-P\n","i":2623},"  ",{"c":5,"s":";; assumes that PAREDIT-IN-STRING-P already returned false; otherwise\n","i":2625},"  ",{"c":5,"s":";; it may give erroneous answers.\n","i":2627},"  (",{"c":5,"s":"if","i":2629}," (",{"c":5,"s":"or","i":2631}," (",{"c":5,"s":"paredit-in-string-p","i":2633},")\n          (",{"c":5,"s":"not","i":2635}," (",{"c":5,"s":"paredit-in-comment-p","i":2637},")))\n      (",{"c":5,"s":"let","i":2639}," ((",{"c":5,"s":"delp","i":2641}," ",{"c":5,"s":"t","i":2643},"))\n        (",{"c":5,"s":"unwind-protect","i":2645}," (",{"c":5,"s":"setq","i":2647}," ",{"c":5,"s":"delp","i":2649},"\n                              (",{"c":5,"s":"call-interactively","i":2651}," ",{"c":5,"s":"'","i":2653},{"c":5,"s":"paredit-escape","i":2655},"))\n          ",{"c":5,"s":";; We need this in an UNWIND-PROTECT so that the backlash is\n","i":2657},"          ",{"c":5,"s":";; left in there *only* if PAREDIT-ESCAPE return NIL normally\n","i":2659},"          ",{"c":5,"s":";; -- in any other case, such as the user hitting C-g or an\n","i":2661},"          ",{"c":5,"s":";; error occurring, we must delete the backslash to avoid\n","i":2663},"          ",{"c":5,"s":";; leaving a dangling escape.  (This control structure is a\n","i":2665},"          ",{"c":5,"s":";; crock.)\n","i":2667},"          (",{"c":5,"s":"if","i":2669}," ",{"c":5,"s":"delp","i":2671}," (",{"c":5,"s":"backward-delete-char","i":2673}," ",{"c":5,"s":"1","i":2675},"))))))\n\n",{"c":5,"s":";;; This auxiliary interactive function returns true if the backslash\n","i":2677},{"c":5,"s":";;; should be deleted and false if not.\n","i":2679},"\n(",{"c":5,"s":"defun","i":2681}," ",{"c":5,"s":"paredit-escape","i":2683}," (",{"c":5,"s":"char","i":2685},")\n  ",{"c":5,"s":";; I'm too lazy to figure out how to do this without a separate\n","i":2687},"  ",{"c":5,"s":";; interactive function.\n","i":2689},"  (",{"c":5,"s":"interactive","i":2691}," ",{"c":5,"s":"\"cEscaping character...\"","i":2693},")\n  (",{"c":5,"s":"if","i":2695}," (",{"c":5,"s":"eq","i":2697}," ",{"c":5,"s":"char","i":2699}," ",{"c":5,"s":"127","i":2701},")                     ",{"c":5,"s":"; The backslash was a typo, so\n","i":2703},"      ",{"c":5,"s":"t","i":2705},"                                 ",{"c":5,"s":"; the luser wants to delete it.\n","i":2707},"    (",{"c":5,"s":"insert","i":2709}," ",{"c":5,"s":"char","i":2711},")                       ",{"c":5,"s":"; (Is there a better way to\n","i":2713},"    ",{"c":5,"s":"nil","i":2715},"))                               ",{"c":5,"s":"; express the rubout char?\n","i":2717},"                                        ",{"c":5,"s":"; ?\\^? works, but ugh...)\n","i":2719},"\n(",{"c":5,"s":"defun","i":2721}," ",{"c":5,"s":"paredit-newline","i":2723}," ()\n  ",{"c":1,"s":"\"Insert a newline and indent it.\nThis is like `newline-and-indent', but it not only indents the line\n  that the point is on but also the S-expression following the point,\n  if there is one.\nMove forward one character first if on an escaped character.\nIf in a string, just insert a literal newline.\nIf in a comment and if followed by invalid structure, call\n  `indent-new-comment-line' to keep the invalid structure in a\n  comment.\""},"\n  (",{"c":5,"s":"interactive","i":2725},")\n  ",{"c":1,"s":"(cond ((paredit-in-string-p)\n         (newline))\n        ((paredit-in-comment-p)\n         (if (paredit-region-ok-p (point) (point-at-eol))\n             (progn (newline-and-indent) (indent-sexp))\n             (indent-new-comment-line)))\n        (t\n         (if (paredit-in-char-p)\n             (forward-char))\n         (newline-and-indent)\n         ;; Indent the following S-expression, but don't signal an\n         ;; error if there's only a closing delimiter after the point.\n         (paredit-ignore-sexp-errors (indent-sexp))))"},")\n\n",{"c":1,"s":"(defun paredit-reindent-defun (&optional argument)\n  \"Reindent the definition that the point is on.\nIf the point is in a string or a comment, fill the paragraph instead,\n  and with a prefix argument, justify as well.\"\n  (interactive \"P\")\n  (if (or (paredit-in-string-p)\n          (paredit-in-comment-p))\n      (fill-paragraph argument)\n    (save-excursion\n      (end-of-defun)\n      (beginning-of-defun)\n      (indent-sexp))))"},"\n\n",{"c":1,"s":";;;; Comment Insertion\n"},"\n(",{"c":5,"s":"defun","i":2727}," ",{"c":5,"s":"paredit-semicolon","i":2729}," (",{"c":5,"s":"&optional","i":2731}," ",{"c":5,"s":"n","i":2733},")\n  ",{"c":1,"s":"\"Insert a semicolon.\nWith a prefix argument N, insert N semicolons.\nIf in a string, do just that and nothing else.\nIf in a character literal, move to the beginning of the character\n  literal before inserting the semicolon.\nIf the enclosing list ends on the line after the point, break the line\n  after the last S-expression following the point.\nIf a list begins on the line after the point but ends on a different\n  line, break the line after the last S-expression following the point\n  before the list.\""},"\n  ",{"c":1,"s":"(interactive \"p\")"},"\n  ",{"c":1,"s":"(if (or (paredit-in-string-p) (paredit-in-comment-p))\n      (insert (make-string (or n 1) ?\\; ))\n    (if (paredit-in-char-p)\n        (backward-char 2))\n    (let ((line-break-point (paredit-semicolon-find-line-break-point)))\n      (if line-break-point\n          (paredit-semicolon-with-line-break line-break-point (or n 1))\n          (insert (make-string (or n 1) ?\\; )))))"},")\n\n(",{"c":1,"s":"defun"}," ",{"c":1,"s":"paredit-semicolon-find-line-break-point"}," ",{"c":1,"s":"()"},"\n  (",{"c":1,"s":"let"}," ",{"c":1,"s":"((line-break-point nil)\n        (eol (point-at-eol)))"},"\n    (",{"c":1,"s":"and"}," (",{"c":1,"s":"save-excursion"},"\n           (",{"c":1,"s":"paredit-handle-sexp-errors"},"\n               ",{"c":1,"s":"(progn\n                 (while\n                     (progn\n                       (setq line-break-point (point))\n                       (forward-sexp)\n                       (and (eq eol (point-at-eol))\n                            (not (eobp)))))\n                 (backward-sexp)\n                 (eq eol (point-at-eol)))"},"\n             ",{"c":1,"s":";; If we hit the end of an expression, but the closing\n"},"             ",{"c":1,"s":";; delimiter is on another line, don't break the line.\n"},"             (",{"c":3,"s":"save-excursion","i":823},"\n               (",{"c":3,"s":"paredit-skip-whitespace","i":825}," ",{"c":3,"s":"t","i":827}," (",{"c":3,"s":"point-at-eol","i":829},"))\n               (",{"c":1,"s":"not"}," (",{"c":3,"s":"or","i":831}," (",{"c":3,"s":"eolp","i":833},") (",{"c":3,"s":"eq","i":835}," (",{"c":3,"s":"char-after","i":837},") ",{"c":3,"s":"?\\;","i":839}," ))))))\n         ",{"c":1,"s":"line-break-point"},")))\n\n",{"c":1,"s":"(defun paredit-semicolon-with-line-break (line-break-point n)\n  (let ((line-break-marker (make-marker)))\n    (set-marker line-break-marker line-break-point)\n    (set-marker-insertion-type line-break-marker t)\n    (insert (make-string (or n 1) ?\\; ))\n    (save-excursion\n      (goto-char line-break-marker)\n      (set-marker line-break-marker nil)\n      (newline)\n      (lisp-indent-line)\n      ;; This step is redundant if we are inside a list, but even if we\n      ;; are at the top level, we want at least to indent whatever we\n      ;; bumped off the line.\n      (paredit-ignore-sexp-errors (indent-sexp))\n      (paredit-indent-sexps))))"},"\n\n",{"c":1,"s":";;; This is all a horrible, horrible hack, primarily for GNU Emacs 21,\n"},{"c":1,"s":";;; in which there is no `comment-or-uncomment-region'.\n"},"\n",{"c":1,"s":"(autoload 'comment-forward \"newcomment\")"},"\n",{"c":1,"s":"(autoload 'comment-normalize-vars \"newcomment\")"},"\n",{"c":1,"s":"(autoload 'comment-region \"newcomment\")"},"\n",{"c":1,"s":"(autoload 'comment-search-forward \"newcomment\")"},"\n",{"c":1,"s":"(autoload 'uncomment-region \"newcomment\")"},"\n\n",{"c":1,"s":"(defun paredit-initialize-comment-dwim ()\n  (require 'newcomment)\n  (if (not (fboundp 'comment-or-uncomment-region))\n      (defalias 'comment-or-uncomment-region\n        (lambda (beginning end &optional argument)\n          (interactive \"*r\\nP\")\n          (if (save-excursion (goto-char beginning)\n                              (comment-forward (point-max))\n                              (<= end (point)))\n              (uncomment-region beginning end argument)\n              (comment-region beginning end argument)))))\n  (defalias 'paredit-initialize-comment-dwim 'comment-normalize-vars)\n  (comment-normalize-vars))"},"\n\n(",{"c":5,"s":"defun","i":2735}," ",{"c":5,"s":"paredit-comment-dwim","i":2737}," ",{"c":1,"s":"(&optional argument)"},"\n  ",{"c":5,"s":"\"Call the Lisp comment command you want (Do What I Mean).\nThis is like `comment-dwim', but it is specialized for Lisp editing.\nIf transient mark mode is enabled and the mark is active, comment or\n  uncomment the selected region, depending on whether it was entirely\n  commented not not already.\nIf there is already a comment on the current line, with no prefix\n  argument, indent to that comment; with a prefix argument, kill that\n  comment.\nOtherwise, insert a comment appropriate for the context and ensure that\n  any code following the comment is moved to the next line.\nAt the top level, where indentation is calculated to be at column 0,\n  insert a triple-semicolon comment; within code, where the indentation\n  is calculated to be non-zero, and on the line there is either no code\n  at all or code after the point, insert a double-semicolon comment;\n  and if the point is after all code on the line, insert a single-\n  semicolon margin comment at `comment-column'.\"","i":2739},"\n  (",{"c":5,"s":"interactive","i":2741}," ",{"c":5,"s":"\"*P\"","i":2743},")\n  ",{"c":1,"s":"(paredit-initialize-comment-dwim)"},"\n  ",{"c":1,"s":"(cond ((paredit-region-active-p)\n         (comment-or-uncomment-region (region-beginning)\n                                      (region-end)\n                                      argument))\n        ((paredit-comment-on-line-p)\n         (if argument\n             (comment-kill (if (integerp argument) argument nil))\n             (comment-indent)))\n        (t (paredit-insert-comment)))"},")\n\n(",{"c":5,"s":"defun","i":2745}," ",{"c":5,"s":"paredit-comment-on-line-p","i":2747}," ()\n  ",{"c":1,"s":"\"True if there is a comment on the line following point.\nThis is expected to be called only in `paredit-comment-dwim'; do not\n  call it elsewhere.\""},"\n  (",{"c":3,"s":"save-excursion","i":841},"\n    (",{"c":3,"s":"beginning-of-line","i":843},")\n    (",{"c":3,"s":"let","i":845}," ((",{"c":3,"s":"comment-p","i":847}," ",{"c":3,"s":"nil","i":849},"))\n      ",{"c":3,"s":";; Search forward for a comment beginning.  If there is one, set\n","i":851},"      ",{"c":3,"s":";; COMMENT-P to true; if not, it will be nil.\n","i":853},"      (",{"c":3,"s":"while","i":855}," (",{"c":1,"s":"progn"},"\n               ",{"c":1,"s":"(setq comment-p          ;t -> no error\n                     (comment-search-forward (point-at-eol) t))"},"\n               (",{"c":3,"s":"and","i":857}," ",{"c":3,"s":"comment-p","i":859},"\n                    (",{"c":3,"s":"or","i":861}," (",{"c":3,"s":"paredit-in-string-p","i":863},")\n                        (",{"c":3,"s":"paredit-in-char-p","i":865}," (",{"c":3,"s":"1-","i":867}," (",{"c":3,"s":"point","i":869},"))))))\n        (",{"c":3,"s":"forward-char","i":871},"))\n      ",{"c":3,"s":"comment-p","i":873},")))\n\n(",{"c":5,"s":"defun","i":2749}," ",{"c":5,"s":"paredit-insert-comment","i":2751}," ()\n  (",{"c":3,"s":"let","i":875}," ((",{"c":3,"s":"code-after-p","i":877},"\n         (",{"c":3,"s":"save-excursion","i":879}," (",{"c":3,"s":"paredit-skip-whitespace","i":881}," ",{"c":3,"s":"t","i":883}," (",{"c":3,"s":"point-at-eol","i":885},"))\n                         (",{"c":3,"s":"not","i":887}," (",{"c":3,"s":"eolp","i":889},"))))\n        (",{"c":3,"s":"code-before-p","i":891},"\n         (",{"c":3,"s":"save-excursion","i":893}," (",{"c":3,"s":"paredit-skip-whitespace","i":895}," ",{"c":3,"s":"nil","i":897}," (",{"c":3,"s":"point-at-bol","i":899},"))\n                         (",{"c":3,"s":"not","i":901}," (",{"c":3,"s":"bolp","i":903},")))))\n    (",{"c":1,"s":"cond"}," ((",{"c":3,"s":"and","i":905}," (",{"c":3,"s":"bolp","i":907},")\n                (",{"c":1,"s":"let"}," ((",{"c":1,"s":"indent"},"\n                       (",{"c":3,"s":"let","i":909}," ((",{"c":3,"s":"indent","i":911}," (",{"c":3,"s":"calculate-lisp-indent","i":913},")))\n                         (",{"c":3,"s":"if","i":915}," (",{"c":3,"s":"consp","i":917}," ",{"c":3,"s":"indent","i":919},") (",{"c":3,"s":"car","i":921}," ",{"c":3,"s":"indent","i":923},") ",{"c":3,"s":"indent","i":925},"))))\n                  ",{"c":1,"s":"(and indent (zerop indent))"},"))\n           ",{"c":1,"s":";; Top-level comment\n"},"           ",{"c":1,"s":"(if code-after-p (save-excursion (newline)))"},"\n           ",{"c":1,"s":"(insert \";;; \")"},")\n          ",{"c":1,"s":"((or code-after-p (not code-before-p))\n           ;; Code comment\n           (if code-before-p (newline))\n           (lisp-indent-line)\n           (insert \";; \")\n           (if code-after-p\n               (save-excursion\n                 (newline)\n                 (lisp-indent-line)\n                 (paredit-indent-sexps))))"},"\n          ",{"c":1,"s":"(t\n           ;; Margin comment\n           (indent-to comment-column 1) ; 1 -> force one leading space\n           (insert ?\\; ))"},")))\n\n",{"c":5,"s":";;;; Character Deletion\n","i":2753},"\n(",{"c":5,"s":"defun","i":2755}," ",{"c":5,"s":"paredit-forward-delete","i":2757}," ",{"c":1,"s":"(&optional argument)"},"\n  ",{"c":1,"s":"\"Delete a character forward or move forward over a delimiter.\nIf on an opening S-expression delimiter, move forward into the\n  S-expression.\nIf on a closing S-expression delimiter, refuse to delete unless the\n  S-expression is empty, in which case delete the whole S-expression.\nWith a numeric prefix argument N, delete N characters forward.\nWith a `C-u' prefix argument, simply delete a character forward,\n  without regard for delimiter balancing.\""},"\n  (",{"c":5,"s":"interactive","i":2759}," ",{"c":5,"s":"\"P\"","i":2761},")\n  (",{"c":1,"s":"cond"}," ",{"c":1,"s":"((or (consp argument) (eobp))\n         (delete-char 1))"},"\n        ",{"c":1,"s":"((integerp argument)\n         (if (< argument 0)\n             (paredit-backward-delete argument)\n             (while (> argument 0)\n               (paredit-forward-delete)\n               (setq argument (- argument 1)))))"},"\n        ",{"c":1,"s":"((paredit-in-string-p)\n         (paredit-forward-delete-in-string))"},"\n        ",{"c":1,"s":"((paredit-in-comment-p)\n         ;++ What to do here?  This could move a partial S-expression\n         ;++ into a comment and thereby invalidate the file's form,\n         ;++ or move random text out of a comment.\n         (delete-char 1))"},"\n        ((",{"c":3,"s":"paredit-in-char-p","i":927},")            ",{"c":3,"s":"; Escape -- delete both chars.\n","i":929},"         (",{"c":3,"s":"backward-delete-char","i":931}," ",{"c":3,"s":"1","i":933},")\n         (",{"c":3,"s":"delete-char","i":935}," ",{"c":3,"s":"1","i":937},"))\n        ((",{"c":3,"s":"eq","i":533}," (",{"c":3,"s":"char-after","i":535},") ",{"c":3,"s":"?\\\\","i":537}," )         ",{"c":3,"s":"; ditto\n","i":539},"         (",{"c":3,"s":"delete-char","i":541}," ",{"c":3,"s":"2","i":543},"))\n        ((",{"c":3,"s":"let","i":433}," ((",{"c":3,"s":"syn","i":435}," (",{"c":3,"s":"char-syntax","i":437}," (",{"c":3,"s":"char-after","i":439},"))))\n           (",{"c":3,"s":"or","i":441}," (",{"c":3,"s":"eq","i":443}," ",{"c":3,"s":"syn","i":445}," ",{"c":3,"s":"?\\(","i":447}," )\n               (",{"c":3,"s":"eq","i":449}," ",{"c":3,"s":"syn","i":451}," ",{"c":3,"s":"?\\\"","i":453}," )))\n         ",{"c":1,"s":"(if (save-excursion\n               (paredit-handle-sexp-errors (progn (forward-sexp) t)\n                 nil))\n             (forward-char)\n           (message \"Deleting spurious opening delimiter.\")\n           (delete-char 1))"},")\n        ((",{"c":3,"s":"and","i":311}," (",{"c":3,"s":"not","i":313}," (",{"c":3,"s":"paredit-in-char-p","i":315}," (",{"c":3,"s":"1-","i":317}," (",{"c":3,"s":"point","i":319},"))))\n              (",{"c":3,"s":"eq","i":321}," (",{"c":3,"s":"char-syntax","i":323}," (",{"c":3,"s":"char-after","i":325},")) ",{"c":3,"s":"?\\)","i":327}," )\n              (",{"c":3,"s":"eq","i":329}," (",{"c":3,"s":"char-before","i":331},") (",{"c":3,"s":"matching-paren","i":333}," (",{"c":3,"s":"char-after","i":335},"))))\n         (",{"c":3,"s":"backward-delete-char","i":337}," ",{"c":3,"s":"1","i":339},")       ",{"c":3,"s":"; Empty list -- delete both\n","i":341},"         (",{"c":3,"s":"delete-char","i":343}," ",{"c":3,"s":"1","i":345},"))               ",{"c":1,"s":";   delimiters.\n"},"        ",{"c":1,"s":";; Just delete a single character, if it's not a closing\n"},"        ",{"c":1,"s":";; delimiter.  (The character literal case is already handled\n"},"        ",{"c":1,"s":";; by now.)\n"},"        ((",{"c":3,"s":"not","i":259}," (",{"c":3,"s":"eq","i":261}," (",{"c":3,"s":"char-syntax","i":263}," (",{"c":3,"s":"char-after","i":265},")) ",{"c":3,"s":"?\\)","i":267}," ))\n         (",{"c":3,"s":"delete-char","i":269}," ",{"c":3,"s":"1","i":271},"))))\n\n(",{"c":5,"s":"defun","i":2763}," ",{"c":5,"s":"paredit-forward-delete-in-string","i":2765}," ()\n  (",{"c":5,"s":"let","i":2767}," ((",{"c":5,"s":"start+end","i":2769}," (",{"c":5,"s":"paredit-string-start+end-points","i":2771},")))\n    (",{"c":5,"s":"cond","i":2773}," ((",{"c":5,"s":"not","i":2775}," (",{"c":5,"s":"eq","i":2777}," (",{"c":5,"s":"point","i":2779},") (",{"c":5,"s":"cdr","i":2781}," ",{"c":5,"s":"start+end","i":2783},")))\n           ",{"c":5,"s":";; If it's not the close-quote, it's safe to delete.  But\n","i":2785},"           ",{"c":5,"s":";; first handle the case that we're in a string escape.\n","i":2787},"           (",{"c":5,"s":"cond","i":2789}," ((",{"c":5,"s":"paredit-in-string-escape-p","i":2791},")\n                  ",{"c":5,"s":";; We're right after the backslash, so backward\n","i":2793},"                  ",{"c":5,"s":";; delete it before deleting the escaped character.\n","i":2795},"                  (",{"c":5,"s":"backward-delete-char","i":2797}," ",{"c":5,"s":"1","i":2799},"))\n                 ((",{"c":5,"s":"eq","i":2801}," (",{"c":5,"s":"char-after","i":2803},") ",{"c":5,"s":"?\\\\","i":2805}," )\n                  ",{"c":5,"s":";; If we're not in a string escape, but we are on a\n","i":2807},"                  ",{"c":5,"s":";; backslash, it must start the escape for the next\n","i":2809},"                  ",{"c":5,"s":";; character, so delete the backslash before deleting\n","i":2811},"                  ",{"c":5,"s":";; the next character.\n","i":2813},"                  (",{"c":5,"s":"delete-char","i":2815}," ",{"c":5,"s":"1","i":2817},")))\n           (",{"c":5,"s":"delete-char","i":2819}," ",{"c":5,"s":"1","i":2821},"))\n          ((",{"c":5,"s":"eq","i":2823}," (",{"c":5,"s":"1-","i":2825}," (",{"c":5,"s":"point","i":2827},")) (",{"c":5,"s":"car","i":2829}," ",{"c":5,"s":"start+end","i":2831},"))\n           ",{"c":5,"s":";; If it is the close-quote, delete only if we're also right\n","i":2833},"           ",{"c":5,"s":";; past the open-quote (i.e. it's empty), and then delete\n","i":2835},"           ",{"c":5,"s":";; both quotes.  Otherwise we refuse to delete it.\n","i":2837},"           (",{"c":5,"s":"backward-delete-char","i":2839}," ",{"c":5,"s":"1","i":2841},")\n           (",{"c":5,"s":"delete-char","i":2843}," ",{"c":5,"s":"1","i":2845},")))))\n\n(",{"c":5,"s":"defun","i":2847}," ",{"c":5,"s":"paredit-backward-delete","i":2849}," ",{"c":1,"s":"(&optional argument)"},"\n  ",{"c":1,"s":"\"Delete a character backward or move backward over a delimiter.\nIf on a closing S-expression delimiter, move backward into the\n  S-expression.\nIf on an opening S-expression delimiter, refuse to delete unless the\n  S-expression is empty, in which case delete the whole S-expression.\nWith a numeric prefix argument N, delete N characters backward.\nWith a `C-u' prefix argument, simply delete a character backward,\n  without regard for delimiter balancing.\""},"\n  (",{"c":5,"s":"interactive","i":2851}," ",{"c":5,"s":"\"P\"","i":2853},")\n  (",{"c":1,"s":"cond"}," ",{"c":1,"s":"((or (consp argument) (bobp))\n         ;++ Should this untabify?\n         (backward-delete-char 1))"},"\n        ",{"c":1,"s":"((integerp argument)\n         (if (< argument 0)\n             (paredit-forward-delete (- 0 argument))\n             (while (> argument 0)\n               (paredit-backward-delete)\n               (setq argument (- argument 1)))))"},"\n        ",{"c":1,"s":"((paredit-in-string-p)\n         (paredit-backward-delete-in-string))"},"\n        ",{"c":1,"s":"((paredit-in-comment-p)\n         (backward-delete-char 1))"},"\n        ((",{"c":3,"s":"paredit-in-char-p","i":939},")            ",{"c":3,"s":"; Escape -- delete both chars.\n","i":941},"         (",{"c":3,"s":"backward-delete-char","i":943}," ",{"c":3,"s":"1","i":945},")\n         (",{"c":3,"s":"delete-char","i":947}," ",{"c":3,"s":"1","i":949},"))\n        ((",{"c":3,"s":"paredit-in-char-p","i":545}," (",{"c":3,"s":"1-","i":547}," (",{"c":3,"s":"point","i":549},")))\n         (",{"c":3,"s":"backward-delete-char","i":551}," ",{"c":3,"s":"2","i":553},"))      ",{"c":1,"s":"; ditto\n"},"        ((",{"c":3,"s":"let","i":455}," ((",{"c":3,"s":"syn","i":457}," (",{"c":3,"s":"char-syntax","i":459}," (",{"c":3,"s":"char-before","i":461},"))))\n           (",{"c":3,"s":"or","i":463}," (",{"c":3,"s":"eq","i":465}," ",{"c":3,"s":"syn","i":467}," ",{"c":3,"s":"?\\)","i":469}," )\n               (",{"c":3,"s":"eq","i":471}," ",{"c":3,"s":"syn","i":473}," ",{"c":3,"s":"?\\\"","i":475}," )))\n         ",{"c":1,"s":"(if (save-excursion\n               (paredit-handle-sexp-errors (progn (backward-sexp) t)\n                 nil))\n             (backward-char)\n           (message \"Deleting spurious closing delimiter.\")\n           (backward-delete-char 1))"},")\n        ((",{"c":3,"s":"and","i":347}," (",{"c":3,"s":"eq","i":349}," (",{"c":3,"s":"char-syntax","i":351}," (",{"c":3,"s":"char-before","i":353},")) ",{"c":3,"s":"?\\(","i":355}," )\n              (",{"c":3,"s":"eq","i":357}," (",{"c":3,"s":"char-after","i":359},") (",{"c":3,"s":"matching-paren","i":361}," (",{"c":3,"s":"char-before","i":363},"))))\n         (",{"c":3,"s":"backward-delete-char","i":365}," ",{"c":3,"s":"1","i":367},")       ",{"c":3,"s":"; Empty list -- delete both\n","i":369},"         (",{"c":3,"s":"delete-char","i":371}," ",{"c":3,"s":"1","i":373},"))               ",{"c":1,"s":";   delimiters.\n"},"        ",{"c":1,"s":";; Delete it, unless it's an opening delimiter.  The case of\n"},"        ",{"c":1,"s":";; character literals is already handled by now.\n"},"        ((",{"c":3,"s":"not","i":273}," (",{"c":3,"s":"eq","i":275}," (",{"c":3,"s":"char-syntax","i":277}," (",{"c":3,"s":"char-before","i":279},")) ",{"c":3,"s":"?\\(","i":281}," ))\n         (",{"c":3,"s":"backward-delete-char-untabify","i":283}," ",{"c":3,"s":"1","i":285},"))))\n\n(",{"c":5,"s":"defun","i":2855}," ",{"c":5,"s":"paredit-backward-delete-in-string","i":2857}," ()\n  (",{"c":5,"s":"let","i":2859}," ((",{"c":5,"s":"start+end","i":2861}," (",{"c":5,"s":"paredit-string-start+end-points","i":2863},")))\n    (",{"c":5,"s":"cond","i":2865}," ((",{"c":5,"s":"not","i":2867}," (",{"c":5,"s":"eq","i":2869}," (",{"c":5,"s":"1-","i":2871}," (",{"c":5,"s":"point","i":2873},")) (",{"c":5,"s":"car","i":2875}," ",{"c":5,"s":"start+end","i":2877},")))\n           ",{"c":5,"s":";; If it's not the open-quote, it's safe to delete.\n","i":2879},"           (",{"c":5,"s":"if","i":2881}," (",{"c":5,"s":"paredit-in-string-escape-p","i":2883},")\n               ",{"c":5,"s":";; If we're on a string escape, since we're about to\n","i":2885},"               ",{"c":5,"s":";; delete the backslash, we must first delete the\n","i":2887},"               ",{"c":5,"s":";; escaped char.\n","i":2889},"               (",{"c":5,"s":"delete-char","i":2891}," ",{"c":5,"s":"1","i":2893},"))\n           (",{"c":5,"s":"backward-delete-char","i":2895}," ",{"c":5,"s":"1","i":2897},")\n           (",{"c":5,"s":"if","i":2899}," (",{"c":5,"s":"paredit-in-string-escape-p","i":2901},")\n               ",{"c":5,"s":";; If, after deleting a character, we find ourselves in\n","i":2903},"               ",{"c":5,"s":";; a string escape, we must have deleted the escaped\n","i":2905},"               ",{"c":5,"s":";; character, and the backslash is behind the point, so\n","i":2907},"               ",{"c":5,"s":";; backward delete it.\n","i":2909},"               (",{"c":5,"s":"backward-delete-char","i":2911}," ",{"c":5,"s":"1","i":2913},")))\n          ((",{"c":5,"s":"eq","i":2915}," (",{"c":5,"s":"point","i":2917},") (",{"c":5,"s":"cdr","i":2919}," ",{"c":5,"s":"start+end","i":2921},"))\n           ",{"c":5,"s":";; If it is the open-quote, delete only if we're also right\n","i":2923},"           ",{"c":5,"s":";; past the close-quote (i.e. it's empty), and then delete\n","i":2925},"           ",{"c":5,"s":";; both quotes.  Otherwise we refuse to delete it.\n","i":2927},"           (",{"c":5,"s":"backward-delete-char","i":2929}," ",{"c":5,"s":"1","i":2931},")\n           (",{"c":5,"s":"delete-char","i":2933}," ",{"c":5,"s":"1","i":2935},")))))\n\n",{"c":5,"s":";;;; Killing\n","i":2937},"\n(",{"c":5,"s":"defun","i":2939}," ",{"c":5,"s":"paredit-kill","i":2941}," ",{"c":1,"s":"(&optional argument)"},"\n  ",{"c":1,"s":"\"Kill a line as if with `kill-line', but respecting delimiters.\nIn a string, act exactly as `kill-line' but do not kill past the\n  closing string delimiter.\nOn a line with no S-expressions on it starting after the point or\n  within a comment, act exactly as `kill-line'.\nOtherwise, kill all S-expressions that start after the point.\nWith a `C-u' prefix argument, just do the standard `kill-line'.\nWith a numeric prefix argument N, do `kill-line' that many times.\""},"\n  (",{"c":5,"s":"interactive","i":2943}," ",{"c":5,"s":"\"P\"","i":2945},")\n  ",{"c":1,"s":"(cond (argument\n         (kill-line (if (integerp argument) argument 1)))\n        ((paredit-in-string-p)\n         (paredit-kill-line-in-string))\n        ((paredit-in-comment-p)\n         (kill-line))\n        ((save-excursion (paredit-skip-whitespace t (point-at-eol))\n                         (or (eolp) (eq (char-after) ?\\; )))\n         ;** Be careful about trailing backslashes.\n         (if (paredit-in-char-p)\n             (backward-char))\n         (kill-line))\n        (t (paredit-kill-sexps-on-line)))"},")\n\n(",{"c":5,"s":"defun","i":2947}," ",{"c":5,"s":"paredit-kill-line-in-string","i":2949}," ()\n  (",{"c":1,"s":"if"}," (",{"c":3,"s":"save-excursion","i":951}," (",{"c":3,"s":"paredit-skip-whitespace","i":953}," ",{"c":3,"s":"t","i":955}," (",{"c":3,"s":"point-at-eol","i":957},"))\n                      (",{"c":3,"s":"eolp","i":959},"))\n      ",{"c":1,"s":"(kill-line)"},"\n    ",{"c":1,"s":"(save-excursion\n      ;; Be careful not to split an escape sequence.\n      (if (paredit-in-string-escape-p)\n          (backward-char))\n      (kill-region (point)\n                   (min (point-at-eol)\n                        (cdr (paredit-string-start+end-points)))))"},"))\n\n(",{"c":5,"s":"defun","i":2951}," ",{"c":5,"s":"paredit-kill-sexps-on-line","i":2953}," ()\n  (",{"c":5,"s":"if","i":2955}," (",{"c":5,"s":"paredit-in-char-p","i":2957},")               ",{"c":5,"s":"; Move past the \\ and prefix.\n","i":2959},"      (",{"c":5,"s":"backward-char","i":2961}," ",{"c":5,"s":"2","i":2963},"))                ",{"c":5,"s":"; (# in Scheme/CL, ? in elisp)\n","i":2965},"  (",{"c":5,"s":"let","i":2967}," ((",{"c":5,"s":"beginning","i":2969}," (",{"c":5,"s":"point","i":2971},"))\n        (",{"c":5,"s":"eol","i":2973}," (",{"c":5,"s":"point-at-eol","i":2975},")))\n    (",{"c":5,"s":"let","i":2977}," ((",{"c":5,"s":"end-of-list-p","i":2979}," (",{"c":5,"s":"paredit-forward-sexps-to-kill","i":2981}," ",{"c":5,"s":"beginning","i":2983}," ",{"c":5,"s":"eol","i":2985},")))\n      ",{"c":5,"s":";; If we got to the end of the list and it's on the same line,\n","i":2987},"      ",{"c":5,"s":";; move backward past the closing delimiter before killing.  (This\n","i":2989},"      ",{"c":5,"s":";; allows something like killing the whitespace in (    ).)\n","i":2991},"      (",{"c":5,"s":"if","i":2993}," ",{"c":5,"s":"end-of-list-p","i":2995}," (",{"c":5,"s":"progn","i":2997}," (",{"c":5,"s":"up-list","i":2999},") (",{"c":5,"s":"backward-char","i":3001},")))\n      (",{"c":5,"s":"if","i":3003}," ",{"c":5,"s":"kill-whole-line","i":3005},"\n          (",{"c":5,"s":"paredit-kill-sexps-on-whole-line","i":3007}," ",{"c":5,"s":"beginning","i":3009},")\n        (",{"c":5,"s":"kill-region","i":3011}," ",{"c":5,"s":"beginning","i":3013},"\n                     ",{"c":5,"s":";; If all of the S-expressions were on one line,\n","i":3015},"                     ",{"c":5,"s":";; i.e. we're still on that line after moving past\n","i":3017},"                     ",{"c":5,"s":";; the last one, kill the whole line, including\n","i":3019},"                     ",{"c":5,"s":";; any comments; otherwise just kill to the end of\n","i":3021},"                     ",{"c":5,"s":";; the last S-expression we found.  Be sure,\n","i":3023},"                     ",{"c":5,"s":";; though, not to kill any closing parentheses.\n","i":3025},"                     (",{"c":5,"s":"if","i":3027}," (",{"c":5,"s":"and","i":3029}," (",{"c":5,"s":"not","i":3031}," ",{"c":5,"s":"end-of-list-p","i":3033},")\n                              (",{"c":5,"s":"eq","i":3035}," (",{"c":5,"s":"point-at-eol","i":3037},") ",{"c":5,"s":"eol","i":3039},"))\n                         ",{"c":5,"s":"eol","i":3041},"\n                         (",{"c":5,"s":"point","i":3043},")))))))\n\n",{"c":5,"s":";;; Please do not try to understand this code unless you have a VERY\n","i":3045},{"c":5,"s":";;; good reason to do so.  I gave up trying to figure it out well\n","i":3047},{"c":5,"s":";;; enough to explain it, long ago.\n","i":3049},"\n(",{"c":5,"s":"defun","i":3051}," ",{"c":5,"s":"paredit-forward-sexps-to-kill","i":3053}," (",{"c":5,"s":"beginning","i":3055}," ",{"c":5,"s":"eol","i":3057},")\n  (",{"c":5,"s":"let","i":3059}," ((",{"c":5,"s":"end-of-list-p","i":3061}," ",{"c":5,"s":"nil","i":3063},")\n        (",{"c":5,"s":"firstp","i":3065}," ",{"c":5,"s":"t","i":3067},"))\n    ",{"c":5,"s":";; Move to the end of the last S-expression that started on this\n","i":3069},"    ",{"c":5,"s":";; line, or to the closing delimiter if the last S-expression in\n","i":3071},"    ",{"c":5,"s":";; this list is on the line.\n","i":3073},"    (",{"c":5,"s":"catch","i":3075}," ",{"c":5,"s":"'","i":3077},{"c":5,"s":"return","i":3079},"\n      (",{"c":5,"s":"while","i":3081}," ",{"c":5,"s":"t","i":3083},"\n        ",{"c":5,"s":";; This and the `kill-whole-line' business below fix a bug that\n","i":3085},"        ",{"c":5,"s":";; inhibited any S-expression at the very end of the buffer\n","i":3087},"        ",{"c":5,"s":";; (with no trailing newline) from being deleted.  It's a\n","i":3089},"        ",{"c":5,"s":";; bizarre fix that I ought to document at some point, but I am\n","i":3091},"        ",{"c":5,"s":";; too busy at the moment to do so.\n","i":3093},"        (",{"c":5,"s":"if","i":3095}," (",{"c":5,"s":"and","i":3097}," ",{"c":5,"s":"kill-whole-line","i":3099}," (",{"c":5,"s":"eobp","i":3101},")) (",{"c":5,"s":"throw","i":3103}," ",{"c":5,"s":"'","i":3105},{"c":5,"s":"return","i":3107}," ",{"c":5,"s":"nil","i":3109},"))\n        (",{"c":5,"s":"save-excursion","i":3111},"\n          (",{"c":5,"s":"paredit-handle-sexp-errors","i":3113}," (",{"c":5,"s":"forward-sexp","i":3115},")\n            (",{"c":5,"s":"up-list","i":3117},")\n            (",{"c":5,"s":"setq","i":3119}," ",{"c":5,"s":"end-of-list-p","i":3121}," (",{"c":5,"s":"eq","i":3123}," (",{"c":5,"s":"point-at-eol","i":3125},") ",{"c":5,"s":"eol","i":3127},"))\n            (",{"c":5,"s":"throw","i":3129}," ",{"c":5,"s":"'","i":3131},{"c":5,"s":"return","i":3133}," ",{"c":5,"s":"nil","i":3135},"))\n          (",{"c":5,"s":"if","i":3137}," (",{"c":5,"s":"or","i":3139}," (",{"c":5,"s":"and","i":3141}," (",{"c":5,"s":"not","i":3143}," ",{"c":5,"s":"firstp","i":3145},")\n                       (",{"c":5,"s":"not","i":3147}," ",{"c":5,"s":"kill-whole-line","i":3149},")\n                       (",{"c":5,"s":"eobp","i":3151},"))\n                  (",{"c":5,"s":"paredit-handle-sexp-errors","i":3153},"\n                      (",{"c":5,"s":"progn","i":3155}," (",{"c":5,"s":"backward-sexp","i":3157},") ",{"c":5,"s":"nil","i":3159},")\n                    ",{"c":5,"s":"t","i":3161},")\n                  (",{"c":5,"s":"not","i":3163}," (",{"c":5,"s":"eq","i":3165}," (",{"c":5,"s":"point-at-eol","i":3167},") ",{"c":5,"s":"eol","i":3169},")))\n              (",{"c":5,"s":"throw","i":3171}," ",{"c":5,"s":"'","i":3173},{"c":5,"s":"return","i":3175}," ",{"c":5,"s":"nil","i":3177},")))\n        (",{"c":5,"s":"forward-sexp","i":3179},")\n        (",{"c":5,"s":"if","i":3181}," (",{"c":5,"s":"and","i":3183}," ",{"c":5,"s":"firstp","i":3185},"\n                 (",{"c":5,"s":"not","i":3187}," ",{"c":5,"s":"kill-whole-line","i":3189},")\n                 (",{"c":5,"s":"eobp","i":3191},"))\n            (",{"c":5,"s":"throw","i":3193}," ",{"c":5,"s":"'","i":3195},{"c":5,"s":"return","i":3197}," ",{"c":5,"s":"nil","i":3199},"))\n        (",{"c":5,"s":"setq","i":3201}," ",{"c":5,"s":"firstp","i":3203}," ",{"c":5,"s":"nil","i":3205},")))\n    ",{"c":5,"s":"end-of-list-p","i":3207},"))\n\n(",{"c":5,"s":"defun","i":3209}," ",{"c":5,"s":"paredit-kill-sexps-on-whole-line","i":3211}," (",{"c":5,"s":"beginning","i":3213},")\n  (",{"c":5,"s":"kill-region","i":3215}," ",{"c":5,"s":"beginning","i":3217},"\n               (",{"c":5,"s":"or","i":3219}," (",{"c":5,"s":"save-excursion","i":3221},"     ",{"c":5,"s":"; Delete trailing indentation...\n","i":3223},"                     (",{"c":5,"s":"paredit-skip-whitespace","i":3225}," ",{"c":5,"s":"t","i":3227},")\n                     (",{"c":5,"s":"and","i":3229}," (",{"c":5,"s":"not","i":3231}," (",{"c":5,"s":"eq","i":3233}," (",{"c":5,"s":"char-after","i":3235},") ",{"c":5,"s":"?\\;","i":3237}," ))\n                          (",{"c":5,"s":"point","i":3239},")))\n                   ",{"c":5,"s":";; ...or just use the point past the newline, if\n","i":3241},"                   ",{"c":5,"s":";; we encounter a comment.\n","i":3243},"                   (",{"c":5,"s":"point-at-eol","i":3245},")))\n  (",{"c":5,"s":"cond","i":3247}," ((",{"c":5,"s":"save-excursion","i":3249}," (",{"c":5,"s":"paredit-skip-whitespace","i":3251}," ",{"c":5,"s":"nil","i":3253}," (",{"c":5,"s":"point-at-bol","i":3255},"))\n                         (",{"c":5,"s":"bolp","i":3257},"))\n         ",{"c":5,"s":";; Nothing but indentation before the point, so indent it.\n","i":3259},"         (",{"c":5,"s":"lisp-indent-line","i":3261},"))\n        ((",{"c":5,"s":"eobp","i":3263},") ",{"c":5,"s":"nil","i":3265},")       ",{"c":5,"s":"; Protect the CHAR-SYNTAX below against NIL.\n","i":3267},"        ",{"c":5,"s":";; Insert a space to avoid invalid joining if necessary.\n","i":3269},"        ((",{"c":5,"s":"let","i":3271}," ((",{"c":5,"s":"syn-before","i":3273}," (",{"c":5,"s":"char-syntax","i":3275}," (",{"c":5,"s":"char-before","i":3277},")))\n               (",{"c":5,"s":"syn-after","i":3279},"  (",{"c":5,"s":"char-syntax","i":3281}," (",{"c":5,"s":"char-after","i":3283},"))))\n           (",{"c":5,"s":"or","i":3285}," (",{"c":5,"s":"and","i":3287}," (",{"c":5,"s":"eq","i":3289}," ",{"c":5,"s":"syn-before","i":3291}," ",{"c":5,"s":"?\\)","i":3293}," )            ",{"c":5,"s":"; Separate opposing\n","i":3295},"                    (",{"c":5,"s":"eq","i":3297}," ",{"c":5,"s":"syn-after","i":3299},"  ",{"c":5,"s":"?\\(","i":3301}," ))           ",{"c":5,"s":";   parentheses,\n","i":3303},"               (",{"c":5,"s":"and","i":3305}," (",{"c":5,"s":"eq","i":3307}," ",{"c":5,"s":"syn-before","i":3309}," ",{"c":5,"s":"?\\\"","i":3311}," )            ",{"c":5,"s":"; string delimiter\n","i":3313},"                    (",{"c":5,"s":"eq","i":3315}," ",{"c":5,"s":"syn-after","i":3317},"  ",{"c":5,"s":"?\\\"","i":3319}," ))           ",{"c":5,"s":";   pairs,\n","i":3321},"               (",{"c":5,"s":"and","i":3323}," (",{"c":5,"s":"memq","i":3325}," ",{"c":5,"s":"syn-before","i":3327}," ",{"c":5,"s":"'","i":3329},"(",{"c":5,"s":"?_","i":3331}," ",{"c":5,"s":"?w","i":3333},"))      ",{"c":5,"s":"; or word or symbol\n","i":3335},"                    (",{"c":5,"s":"memq","i":3337}," ",{"c":5,"s":"syn-after","i":3339},"  ",{"c":5,"s":"'","i":3341},"(",{"c":5,"s":"?_","i":3343}," ",{"c":5,"s":"?w","i":3345},")))))   ",{"c":5,"s":";   constituents.\n","i":3347},"         (",{"c":5,"s":"insert","i":3349}," ",{"c":5,"s":"\" \"","i":3351},"))))\n\n",{"c":5,"s":";;;;; Killing Words\n","i":3353},"\n",{"c":5,"s":";;; This is tricky and asymmetrical because backward parsing is\n","i":3355},{"c":5,"s":";;; extraordinarily difficult or impossible, so we have to implement\n","i":3357},{"c":5,"s":";;; killing in both directions by parsing forward.\n","i":3359},"\n(",{"c":5,"s":"defun","i":3361}," ",{"c":5,"s":"paredit-forward-kill-word","i":3363}," ()\n  ",{"c":5,"s":"\"Kill a word forward, skipping over intervening delimiters.\"","i":3365},"\n  (",{"c":5,"s":"interactive","i":3367},")\n  (",{"c":5,"s":"let","i":3369}," ((",{"c":5,"s":"beginning","i":3371}," (",{"c":5,"s":"point","i":3373},")))\n    (",{"c":5,"s":"skip-syntax-forward","i":3375}," ",{"c":5,"s":"\" -\"","i":3377},")\n    (",{"c":5,"s":"let*","i":3379}," ((",{"c":5,"s":"parse-state","i":3381}," (",{"c":5,"s":"paredit-current-parse-state","i":3383},"))\n           (",{"c":5,"s":"state","i":3385}," (",{"c":5,"s":"paredit-kill-word-state","i":3387}," ",{"c":5,"s":"parse-state","i":3389}," ",{"c":5,"s":"'","i":3391},{"c":5,"s":"char-after","i":3393},")))\n      (",{"c":5,"s":"while","i":3395}," (",{"c":5,"s":"not","i":3397}," (",{"c":5,"s":"or","i":3399}," (",{"c":5,"s":"eobp","i":3401},")\n                      (",{"c":5,"s":"eq","i":3403}," ",{"c":5,"s":"?w","i":3405}," (",{"c":5,"s":"char-syntax","i":3407}," (",{"c":5,"s":"char-after","i":3409},")))))\n        (",{"c":5,"s":"setq","i":3411}," ",{"c":5,"s":"parse-state","i":3413},"\n              (",{"c":5,"s":"progn","i":3415}," (",{"c":5,"s":"forward-char","i":3417}," ",{"c":5,"s":"1","i":3419},") (",{"c":5,"s":"paredit-current-parse-state","i":3421},"))\n",{"c":5,"s":";;               (parse-partial-sexp (point) (1+ (point))\n","i":3423},{"c":5,"s":";;                                   nil nil parse-state)\n","i":3425},"              )\n        (",{"c":5,"s":"let*","i":3427}," ((",{"c":5,"s":"old-state","i":3429}," ",{"c":5,"s":"state","i":3431},")\n               (",{"c":5,"s":"new-state","i":3433},"\n                (",{"c":5,"s":"paredit-kill-word-state","i":3435}," ",{"c":5,"s":"parse-state","i":3437}," ",{"c":5,"s":"'","i":3439},{"c":5,"s":"char-after","i":3441},")))\n          (",{"c":5,"s":"cond","i":3443}," ((",{"c":5,"s":"not","i":3445}," (",{"c":5,"s":"eq","i":3447}," ",{"c":5,"s":"old-state","i":3449}," ",{"c":5,"s":"new-state","i":3451},"))\n                 (",{"c":5,"s":"setq","i":3453}," ",{"c":5,"s":"parse-state","i":3455},"\n                       (",{"c":5,"s":"paredit-kill-word-hack","i":3457}," ",{"c":5,"s":"old-state","i":3459},"\n                                               ",{"c":5,"s":"new-state","i":3461},"\n                                               ",{"c":5,"s":"parse-state","i":3463},"))\n                 (",{"c":5,"s":"setq","i":3465}," ",{"c":5,"s":"state","i":3467},"\n                       (",{"c":5,"s":"paredit-kill-word-state","i":3469}," ",{"c":5,"s":"parse-state","i":3471},"\n                                                ",{"c":5,"s":"'","i":3473},{"c":5,"s":"char-after","i":3475},"))\n                 (",{"c":5,"s":"setq","i":3477}," ",{"c":5,"s":"beginning","i":3479}," (",{"c":5,"s":"point","i":3481},")))))))\n    (",{"c":5,"s":"goto-char","i":3483}," ",{"c":5,"s":"beginning","i":3485},")\n    (",{"c":5,"s":"kill-word","i":3487}," ",{"c":5,"s":"1","i":3489},")))\n\n(",{"c":5,"s":"defun","i":3491}," ",{"c":5,"s":"paredit-backward-kill-word","i":3493}," ()\n  ",{"c":5,"s":"\"Kill a word backward, skipping over any intervening delimiters.\"","i":3495},"\n  (",{"c":5,"s":"interactive","i":3497},")\n  (",{"c":5,"s":"if","i":3499}," (",{"c":5,"s":"not","i":3501}," (",{"c":5,"s":"or","i":3503}," (",{"c":5,"s":"bobp","i":3505},")\n               (",{"c":5,"s":"eq","i":3507}," (",{"c":5,"s":"char-syntax","i":3509}," (",{"c":5,"s":"char-before","i":3511},")) ",{"c":5,"s":"?w","i":3513},")))\n      (",{"c":5,"s":"let","i":3515}," ((",{"c":5,"s":"end","i":3517}," (",{"c":5,"s":"point","i":3519},")))\n        (",{"c":5,"s":"backward-word","i":3521}," ",{"c":5,"s":"1","i":3523},")\n        (",{"c":5,"s":"forward-word","i":3525}," ",{"c":5,"s":"1","i":3527},")\n        (",{"c":5,"s":"goto-char","i":3529}," (",{"c":5,"s":"min","i":3531}," ",{"c":5,"s":"end","i":3533}," (",{"c":5,"s":"point","i":3535},")))\n        (",{"c":5,"s":"let*","i":3537}," ((",{"c":5,"s":"parse-state","i":3539}," (",{"c":5,"s":"paredit-current-parse-state","i":3541},"))\n               (",{"c":5,"s":"state","i":3543},"\n                (",{"c":5,"s":"paredit-kill-word-state","i":3545}," ",{"c":5,"s":"parse-state","i":3547}," ",{"c":5,"s":"'","i":3549},{"c":5,"s":"char-before","i":3551},")))\n          (",{"c":5,"s":"while","i":3553}," (",{"c":5,"s":"and","i":3555}," (",{"c":5,"s":"<","i":3557}," (",{"c":5,"s":"point","i":3559},") ",{"c":5,"s":"end","i":3561},")\n                      (",{"c":5,"s":"progn","i":3563},"\n                        (",{"c":5,"s":"setq","i":3565}," ",{"c":5,"s":"parse-state","i":3567},"\n                              (",{"c":5,"s":"parse-partial-sexp","i":3569}," (",{"c":5,"s":"point","i":3571},") (",{"c":5,"s":"1+","i":3573}," (",{"c":5,"s":"point","i":3575},"))\n                                                  ",{"c":5,"s":"nil","i":3577}," ",{"c":5,"s":"nil","i":3579}," ",{"c":5,"s":"parse-state","i":3581},"))\n                        (",{"c":5,"s":"or","i":3583}," (",{"c":5,"s":"eq","i":3585}," ",{"c":5,"s":"state","i":3587},"\n                                (",{"c":5,"s":"paredit-kill-word-state","i":3589}," ",{"c":5,"s":"parse-state","i":3591},"\n                                                         ",{"c":5,"s":"'","i":3593},{"c":5,"s":"char-before","i":3595},"))\n                            (",{"c":5,"s":"progn","i":3597}," (",{"c":5,"s":"backward-char","i":3599}," ",{"c":5,"s":"1","i":3601},") ",{"c":5,"s":"nil","i":3603},")))))\n          (",{"c":5,"s":"if","i":3605}," (",{"c":5,"s":"and","i":3607}," (",{"c":5,"s":"eq","i":3609}," ",{"c":5,"s":"state","i":3611}," ",{"c":5,"s":"'","i":3613},{"c":5,"s":"comment","i":3615},")\n                   (",{"c":5,"s":"eq","i":3617}," ",{"c":5,"s":"?\\#","i":3619}," (",{"c":5,"s":"char-after","i":3621}," (",{"c":5,"s":"point","i":3623},")))\n                   (",{"c":5,"s":"eq","i":3625}," ",{"c":5,"s":"?\\|","i":3627}," (",{"c":5,"s":"char-before","i":3629}," (",{"c":5,"s":"point","i":3631},"))))\n              (",{"c":5,"s":"backward-char","i":3633}," ",{"c":5,"s":"1","i":3635},")))))\n  (",{"c":5,"s":"backward-kill-word","i":3637}," ",{"c":5,"s":"1","i":3639},"))\n\n",{"c":1,"s":";;;;;; Word-Killing Auxiliaries\n"},"\n(",{"c":5,"s":"defun","i":3641}," ",{"c":5,"s":"paredit-kill-word-state","i":3643}," (",{"c":5,"s":"parse-state","i":3645}," ",{"c":5,"s":"adjacent-char-fn","i":3647},")\n  (",{"c":5,"s":"cond","i":3649}," ((",{"c":5,"s":"paredit-in-comment-p","i":3651}," ",{"c":5,"s":"parse-state","i":3653},") ",{"c":5,"s":"'","i":3655},{"c":5,"s":"comment","i":3657},")\n        ((",{"c":5,"s":"paredit-in-string-p","i":3659},"  ",{"c":5,"s":"parse-state","i":3661},") ",{"c":5,"s":"'","i":3663},{"c":5,"s":"string","i":3665},")\n        ((",{"c":5,"s":"memq","i":3667}," (",{"c":5,"s":"char-syntax","i":3669}," (",{"c":5,"s":"funcall","i":3671}," ",{"c":5,"s":"adjacent-char-fn","i":3673},"))\n               ",{"c":5,"s":"'","i":3675},"(",{"c":5,"s":"?\\(","i":3677}," ",{"c":5,"s":"?\\)","i":3679}," ))\n         ",{"c":5,"s":"'","i":3681},{"c":5,"s":"delimiter","i":3683},")\n        (",{"c":5,"s":"t","i":3685}," ",{"c":5,"s":"'","i":3687},{"c":5,"s":"other","i":3689},")))\n\n",{"c":5,"s":";;; This optionally advances the point past any comment delimiters that\n","i":3691},{"c":5,"s":";;; should probably not be touched, based on the last state change and\n","i":3693},{"c":5,"s":";;; the characters around the point.  It returns a new parse state,\n","i":3695},{"c":5,"s":";;; starting from the PARSE-STATE parameter.\n","i":3697},"\n(",{"c":5,"s":"defun","i":3699}," ",{"c":5,"s":"paredit-kill-word-hack","i":3701}," (",{"c":5,"s":"old-state","i":3703}," ",{"c":5,"s":"new-state","i":3705}," ",{"c":5,"s":"parse-state","i":3707},")\n  (",{"c":5,"s":"cond","i":3709}," ((",{"c":5,"s":"and","i":3711}," (",{"c":5,"s":"not","i":3713}," (",{"c":5,"s":"eq","i":3715}," ",{"c":5,"s":"old-state","i":3717}," ",{"c":5,"s":"'","i":3719},{"c":5,"s":"comment","i":3721},"))\n              (",{"c":5,"s":"not","i":3723}," (",{"c":5,"s":"eq","i":3725}," ",{"c":5,"s":"new-state","i":3727}," ",{"c":5,"s":"'","i":3729},{"c":5,"s":"comment","i":3731},"))\n              (",{"c":5,"s":"not","i":3733}," (",{"c":5,"s":"paredit-in-string-escape-p","i":3735},"))\n              (",{"c":5,"s":"eq","i":3737}," ",{"c":5,"s":"?\\#","i":3739}," (",{"c":5,"s":"char-before","i":3741},"))\n              (",{"c":5,"s":"eq","i":3743}," ",{"c":5,"s":"?\\|","i":3745}," (",{"c":5,"s":"char-after","i":3747},")))\n         (",{"c":5,"s":"forward-char","i":3749}," ",{"c":5,"s":"1","i":3751},")\n         (",{"c":5,"s":"paredit-current-parse-state","i":3753},")\n",{"c":5,"s":";;          (parse-partial-sexp (point) (1+ (point))\n","i":3755},{"c":5,"s":";;                              nil nil parse-state)\n","i":3757},"         )\n        ((",{"c":5,"s":"and","i":3759}," (",{"c":5,"s":"not","i":3761}," (",{"c":5,"s":"eq","i":3763}," ",{"c":5,"s":"old-state","i":3765}," ",{"c":5,"s":"'","i":3767},{"c":5,"s":"comment","i":3769},"))\n              (",{"c":5,"s":"eq","i":3771}," ",{"c":5,"s":"new-state","i":3773}," ",{"c":5,"s":"'","i":3775},{"c":5,"s":"comment","i":3777},")\n              (",{"c":5,"s":"eq","i":3779}," ",{"c":5,"s":"?\\;","i":3781}," (",{"c":5,"s":"char-before","i":3783},")))\n         (",{"c":5,"s":"skip-chars-forward","i":3785}," ",{"c":5,"s":"\";\"","i":3787},")\n         (",{"c":5,"s":"paredit-current-parse-state","i":3789},")\n",{"c":5,"s":";;          (parse-partial-sexp (point) (save-excursion\n","i":3791},{"c":5,"s":";;                                        (skip-chars-forward \";\"))\n","i":3793},{"c":5,"s":";;                              nil nil parse-state)\n","i":3795},"         )\n        (",{"c":5,"s":"t","i":3797}," ",{"c":5,"s":"parse-state","i":3799},")))\n\n",{"c":1,"s":"(defun paredit-copy-as-kill ()\n  \"Save in the kill ring the region that `paredit-kill' would kill.\"\n  (interactive)\n  (cond ((paredit-in-string-p)\n         (paredit-copy-as-kill-in-string))\n        ((paredit-in-comment-p)\n         (copy-region-as-kill (point) (point-at-eol)))\n        ((save-excursion (paredit-skip-whitespace t (point-at-eol))\n                         (or (eolp) (eq (char-after) ?\\; )))\n         ;** Be careful about trailing backslashes.\n         (save-excursion\n           (if (paredit-in-char-p)\n               (backward-char))\n           (copy-region-as-kill (point) (point-at-eol))))\n        (t (paredit-copy-sexps-as-kill))))"},"\n\n",{"c":1,"s":"(defun paredit-copy-as-kill-in-string ()\n  (save-excursion\n    (if (paredit-in-string-escape-p)\n        (backward-char))\n    (copy-region-as-kill (point)\n                         (min (point-at-eol)\n                              (cdr (paredit-string-start+end-points))))))"},"\n\n",{"c":1,"s":"(defun paredit-copy-sexps-as-kill ()\n  (save-excursion\n    (if (paredit-in-char-p)\n        (backward-char 2))\n    (let ((beginning (point))\n          (eol (point-at-eol)))\n      (let ((end-of-list-p (paredit-forward-sexps-to-kill beginning eol)))\n        (if end-of-list-p (progn (up-list) (backward-char)))\n        (copy-region-as-kill beginning\n                             (cond (kill-whole-line\n                                    (or (save-excursion\n                                          (paredit-skip-whitespace t)\n                                          (and (not (eq (char-after) ?\\; ))\n                                               (point)))\n                                        (point-at-eol)))\n                                   ((and (not end-of-list-p)\n                                         (eq (point-at-eol) eol))\n                                    eol)\n                                   (t\n                                    (point))))))))"},"\n\n",{"c":1,"s":";;;; Safe Region Killing/Copying\n"},"\n",{"c":1,"s":";;; This is an experiment.  It's not enough: `paredit-kill-ring-save'\n"},{"c":1,"s":";;; is always safe; it's `yank' that's not safe, but even trickier to\n"},{"c":1,"s":";;; implement than `paredit-kill-region'.  Also, the heuristics for\n"},{"c":1,"s":";;; `paredit-kill-region' are slightly too conservative -- they will\n"},{"c":1,"s":";;; sometimes reject killing regions that would be safe to kill.\n"},{"c":1,"s":";;; (Consider, e,g., a region that starts in a comment and ends in the\n"},{"c":1,"s":";;; middle of a symbol at the end of a line: that's safe to kill, but\n"},{"c":1,"s":";;; `paredit-kill-region' won't allow it.)  I don't know whether they\n"},{"c":1,"s":";;; are too liberal: I haven't constructed a region that is unsafe to\n"},{"c":1,"s":";;; kill but which `paredit-kill-region' will kill, but I haven't ruled\n"},{"c":1,"s":";;; out the possibility either.\n"},"\n",{"c":1,"s":"(defun paredit-kill-ring-save (beginning end)\n  \"Save the balanced region, but don't kill it, like `kill-ring-save'.\nIf the text of the region is imbalanced, signal an error instead.\nWith a prefix argument, disregard any imbalance.\"\n  (interactive \"r\")\n  (if (not current-prefix-arg)\n      (paredit-check-region beginning end))\n  (setq this-command 'kill-ring-save)\n  (kill-ring-save beginning end))"},"\n\n",{"c":1,"s":"(defun paredit-kill-region (beginning end &optional yank-handler)\n  \"Kill balanced text between point and mark, like `kill-region'.\nIf that text is imbalanced, signal an error instead.\"\n  (interactive \"r\")\n  (if (and beginning end)\n      ;; Check that region begins and ends in a sufficiently similar\n      ;; state, so that deleting it will leave the buffer balanced.\n      (save-excursion\n        (goto-char beginning)\n        (let* ((state (paredit-current-parse-state))\n               (state* (parse-partial-sexp beginning end nil nil state)))\n          (paredit-check-region-state state state*))))\n  (setq this-command 'kill-region)\n  (kill-region beginning end yank-handler))"},"\n\n",{"c":1,"s":"(defun paredit-check-region-state (beginning-state end-state)\n  (paredit-check-region-state-depth beginning-state end-state)\n  (paredit-check-region-state-string beginning-state end-state)\n  (paredit-check-region-state-comment beginning-state end-state)\n  (paredit-check-region-state-char-quote beginning-state end-state))"},"\n\n",{"c":1,"s":"(defun paredit-check-region-state-depth (beginning-state end-state)\n  (let ((beginning-depth (nth 0 beginning-state))\n        (end-depth (nth 0 end-state)))\n    (if (not (= beginning-depth end-depth))\n        (error \"Mismatched parenthesis depth: %S at start, %S at end.\"\n               beginning-depth\n               end-depth))))"},"\n\n",{"c":1,"s":"(defun paredit-check-region-state-string (beginning-state end-state)\n  (let ((beginning-string-p (nth 3 beginning-state))\n        (end-string-p (nth 3 end-state)))\n    (if (not (eq beginning-string-p end-string-p))\n        (error \"Mismatched string state: start %sin string, end %sin string.\"\n               (if beginning-string-p \"\" \"not \")\n               (if end-string-p \"\" \"not \")))))"},"\n\n",{"c":1,"s":"(defun paredit-check-region-state-comment (beginning-state end-state)\n  (let ((beginning-comment-state (nth 4 beginning-state))\n        (end-comment-state (nth 4 end-state)))\n    (if (not (or (eq beginning-comment-state end-comment-state)\n                 (and (eq beginning-comment-state nil)\n                      (eq end-comment-state t)\n                      (eolp))))\n        (error \"Mismatched comment state: %s\"\n               (cond ((and (integerp beginning-comment-state)\n                           (integerp end-comment-state))\n                      (format \"depth %S at start, depth %S at end.\"\n                              beginning-comment-state\n                              end-comment-state))\n                     ((integerp beginning-comment-state)\n                      \"start in nested comment, end otherwise.\")\n                     ((integerp end-comment-state)\n                      \"end in nested comment, start otherwise.\")\n                     (beginning-comment-state\n                      \"start in comment, end not in comment.\")\n                     (end-comment-state\n                      \"end in comment, start not in comment.\")\n                     (t\n                      (format \"start %S, end %S.\"\n                              beginning-comment-state\n                              end-comment-state)))))))"},"\n\n",{"c":1,"s":"(defun paredit-check-region-state-char-quote (beginning-state end-state)\n  (let ((beginning-char-quote (nth 5 beginning-state))\n        (end-char-quote (nth 5 end-state)))\n    (if (not (eq beginning-char-quote end-char-quote))\n        (let ((phrase \"character quotation\"))\n          (error \"Mismatched %s: start %sin %s, end %sin %s.\"\n                 phrase\n                 (if beginning-char-quote \"\" \"not \")\n                 phrase\n                 (if end-char-quote \"\" \"not \")\n                 phrase)))))"},"\n\n",{"c":1,"s":";;;; Cursor and Screen Movement\n"},"\n(",{"c":5,"s":"eval-and-compile","i":3801},"\n  (",{"c":5,"s":"defmacro","i":3803}," ",{"c":5,"s":"defun-saving-mark","i":3805}," (",{"c":5,"s":"name","i":3807}," ",{"c":5,"s":"bvl","i":3809}," ",{"c":5,"s":"doc","i":3811}," ",{"c":5,"s":"&rest","i":3813}," ",{"c":5,"s":"body","i":3815},")\n    ",{"c":5,"s":"`","i":3817},"(",{"c":5,"s":"defun","i":3819}," ",{"c":5,"s":",","i":3821},{"c":5,"s":"name","i":3823}," ",{"c":5,"s":",","i":3825},{"c":5,"s":"bvl","i":3827},"\n       ",{"c":5,"s":",","i":3829},{"c":5,"s":"doc","i":3831},"\n       ",{"c":5,"s":",","i":3833},"(",{"c":5,"s":"xcond","i":3835}," ((",{"c":5,"s":"paredit-xemacs-p","i":3837},")\n                ",{"c":5,"s":"'","i":3839},"(",{"c":5,"s":"interactive","i":3841}," ",{"c":5,"s":"\"_\"","i":3843},"))\n               ((",{"c":5,"s":"paredit-gnu-emacs-p","i":3845},")\n                ",{"c":5,"s":"'","i":3847},"(",{"c":5,"s":"interactive","i":3849},")))\n       ",{"c":5,"s":",","i":3851},{"c":5,"s":"@body","i":3853},")))\n\n(",{"c":5,"s":"defun-saving-mark","i":3855}," ",{"c":5,"s":"paredit-forward","i":3857}," ()\n  ",{"c":5,"s":"\"Move forward an S-expression, or up an S-expression forward.\nIf there are no more S-expressions in this one before the closing\n  delimiter, move past that closing delimiter; otherwise, move forward\n  past the S-expression following the point.\"","i":3859},"\n  (",{"c":5,"s":"paredit-handle-sexp-errors","i":3861},"\n      (",{"c":5,"s":"forward-sexp","i":3863},")\n    ",{"c":5,"s":";++ Is it necessary to use UP-LIST and not just FORWARD-CHAR?\n","i":3865},"    (",{"c":5,"s":"if","i":3867}," (",{"c":5,"s":"paredit-in-string-p","i":3869},") (",{"c":5,"s":"forward-char","i":3871},") (",{"c":5,"s":"up-list","i":3873},"))))\n\n(",{"c":5,"s":"defun-saving-mark","i":3875}," ",{"c":5,"s":"paredit-backward","i":3877}," ()\n  ",{"c":5,"s":"\"Move backward an S-expression, or up an S-expression backward.\nIf there are no more S-expressions in this one before the opening\n  delimiter, move past that opening delimiter backward; otherwise, move\n  move backward past the S-expression preceding the point.\"","i":3879},"\n  (",{"c":5,"s":"paredit-handle-sexp-errors","i":3881},"\n      (",{"c":5,"s":"backward-sexp","i":3883},")\n    (",{"c":5,"s":"if","i":3885}," (",{"c":5,"s":"paredit-in-string-p","i":3887},") (",{"c":5,"s":"backward-char","i":3889},") (",{"c":5,"s":"backward-up-list","i":3891},"))))\n\n",{"c":5,"s":";;; Why is this not in lisp.el?\n","i":3893},"\n(",{"c":5,"s":"defun","i":3895}," ",{"c":5,"s":"backward-down-list","i":3897}," (",{"c":5,"s":"&optional","i":3899}," ",{"c":5,"s":"arg","i":3901},")\n  ",{"c":5,"s":"\"Move backward and descend into one level of parentheses.\nWith ARG, do this that many times.\nA negative argument means move forward but still descend a level.\"","i":3903},"\n  (",{"c":5,"s":"interactive","i":3905}," ",{"c":5,"s":"\"p\"","i":3907},")\n  (",{"c":5,"s":"down-list","i":3909}," (",{"c":5,"s":"-","i":3911}," (",{"c":5,"s":"or","i":3913}," ",{"c":5,"s":"arg","i":3915}," ",{"c":5,"s":"1","i":3917},"))))\n\n",{"c":5,"s":";;; Thanks to Marco Baringer for suggesting & writing this function.\n","i":3919},"\n(",{"c":5,"s":"defun","i":3921}," ",{"c":5,"s":"paredit-recentre-on-sexp","i":3923}," (",{"c":5,"s":"&optional","i":3925}," ",{"c":5,"s":"n","i":3927},")\n  ",{"c":5,"s":"\"Recentre the screen on the S-expression following the point.\nWith a prefix argument N, encompass all N S-expressions forward.\"","i":3929},"\n  (",{"c":5,"s":"interactive","i":3931}," ",{"c":5,"s":"\"P\"","i":3933},")\n  (",{"c":5,"s":"save-excursion","i":3935},"\n    (",{"c":5,"s":"forward-sexp","i":3937}," ",{"c":5,"s":"n","i":3939},")\n    (",{"c":5,"s":"let","i":3941}," ((",{"c":5,"s":"end-point","i":3943}," (",{"c":5,"s":"point","i":3945},")))\n      (",{"c":5,"s":"backward-sexp","i":3947}," ",{"c":5,"s":"n","i":3949},")\n      (",{"c":5,"s":"let*","i":3951}," ((",{"c":5,"s":"start-point","i":3953}," (",{"c":5,"s":"point","i":3955},"))\n             (",{"c":5,"s":"start-line","i":3957}," (",{"c":5,"s":"count-lines","i":3959}," (",{"c":5,"s":"point-min","i":3961},") (",{"c":5,"s":"point","i":3963},")))\n             (",{"c":5,"s":"lines-on-sexps","i":3965}," (",{"c":5,"s":"count-lines","i":3967}," ",{"c":5,"s":"start-point","i":3969}," ",{"c":5,"s":"end-point","i":3971},")))\n        (",{"c":5,"s":"goto-line","i":3973}," (",{"c":5,"s":"+","i":3975}," ",{"c":5,"s":"start-line","i":3977}," (",{"c":5,"s":"/","i":3979}," ",{"c":5,"s":"lines-on-sexps","i":3981}," ",{"c":5,"s":"2","i":3983},")))\n        (",{"c":5,"s":"recenter","i":3985},")))))\n\n",{"c":1,"s":"(defun paredit-focus-on-defun ()\n  \"Moves display to the top of the definition at point.\"\n  (interactive)\n  (beginning-of-defun)\n  (recenter 0))"},"\n\n",{"c":1,"s":";;;; Generalized Upward/Downward Motion\n"},"\n",{"c":1,"s":"(defun paredit-up/down (n vertical-direction)\n  (let ((horizontal-direction (if (< 0 n) +1 -1)))\n    (while (/= n 0)\n      (goto-char\n       (paredit-next-up/down-point horizontal-direction vertical-direction))\n      (setq n (- n horizontal-direction)))))"},"\n\n",{"c":1,"s":"(defun paredit-next-up/down-point (horizontal-direction vertical-direction)\n  (let ((state (paredit-current-parse-state))\n        (scan-lists\n         (lambda ()\n           (scan-lists (point) horizontal-direction vertical-direction))))\n    (cond ((paredit-in-string-p state)\n           (let ((start+end (paredit-string-start+end-points state)))\n             (if (< 0 vertical-direction)\n                 (if (< 0 horizontal-direction)\n                     (+ 1 (cdr start+end))\n                     (car start+end))\n                 ;; We could let the user try to descend into lists\n                 ;; within the string, but that would be asymmetric\n                 ;; with the up case, which rises out of the whole\n                 ;; string and not just out of a list within the\n                 ;; string, so this case will just be an error.\n                 (error \"Can't descend further into string.\"))))\n          ((< 0 vertical-direction)\n           ;; When moving up, just try to rise up out of the list.\n           (or (funcall scan-lists)\n               (buffer-end horizontal-direction)))\n          ((< vertical-direction 0)\n           ;; When moving down, look for a string closer than a list,\n           ;; and use that if we find it.\n           (let* ((list-start\n                   (paredit-handle-sexp-errors (funcall scan-lists) nil))\n                  (string-start\n                   (paredit-find-next-string-start horizontal-direction\n                                                   list-start)))\n             (if (and string-start list-start)\n                 (if (< 0 horizontal-direction)\n                     (min string-start list-start)\n                     (max string-start list-start))\n                 (or string-start\n                     ;; Scan again: this is a kludgey way to report the\n                     ;; error if there really was one.\n                     (funcall scan-lists)\n                     (buffer-end horizontal-direction)))))\n          (t\n           (error \"Vertical direction must be nonzero in `%s'.\"\n                  'paredit-up/down)))))"},"\n\n",{"c":1,"s":"(defun paredit-find-next-string-start (horizontal-direction limit)\n  (let ((next-char (if (< 0 horizontal-direction) 'char-after 'char-before))\n        (pastp (if (< 0 horizontal-direction) '< '>)))\n    (paredit-handle-sexp-errors\n        (save-excursion\n          (catch 'exit\n            (while t\n              (if (and limit (funcall pastp (point) limit))\n                  (throw 'exit nil))\n              (forward-sexp horizontal-direction)\n              (save-excursion\n                (backward-sexp horizontal-direction)\n                (if (eq ?\\\" (char-syntax (funcall next-char)))\n                    (throw 'exit (+ (point) horizontal-direction)))))))\n      nil)))"},"\n\n",{"c":1,"s":"(defun paredit-forward-down (&optional argument)\n  \"Move forward down into a list.\nWith a positive argument, move forward down that many levels.\nWith a negative argument, move backward down that many levels.\"\n  (interactive \"p\")\n  (paredit-up/down (or argument +1) -1))"},"\n\n",{"c":1,"s":"(defun paredit-backward-up (&optional argument)\n  \"Move backward up out of the enclosing list.\nWith a positive argument, move backward up that many levels.\nWith a negative argument, move forward up that many levels.\nIf in a string initially, that counts as one level.\"\n  (interactive \"p\")\n  (paredit-up/down (- 0 (or argument +1)) +1))"},"\n\n",{"c":1,"s":"(defun paredit-forward-up (&optional argument)\n  \"Move forward up out of the enclosing list.\nWith a positive argument, move forward up that many levels.\nWith a negative argument, move backward up that many levels.\nIf in a string initially, that counts as one level.\"\n  (interactive \"p\")\n  (paredit-up/down (or argument +1) +1))"},"\n\n",{"c":1,"s":"(defun paredit-backward-down (&optional argument)\n  \"Move backward down into a list.\nWith a positive argument, move backward down that many levels.\nWith a negative argument, move forward down that many levels.\"\n  (interactive \"p\")\n  (paredit-up/down (- 0 (or argument +1)) -1))"},"\n\n",{"c":1,"s":";;;; Depth-Changing Commands:  Wrapping, Splicing, & Raising\n"},"\n(",{"c":5,"s":"defun","i":3987}," ",{"c":5,"s":"paredit-wrap-sexp","i":3989}," ",{"c":1,"s":"(&optional argument open close)"},"\n  ",{"c":1,"s":"\"Wrap the following S-expression.\nIf a `C-u' prefix argument is given, wrap all S-expressions following\n  the point until the end of the buffer or of the enclosing list.\nIf a numeric prefix argument N is given, wrap N S-expressions.\nAutomatically indent the newly wrapped S-expression.\nAs a special case, if the point is at the end of a list, simply insert\n  a parenthesis pair, rather than inserting a lone opening delimiter\n  and then signalling an error, in the interest of preserving\n  structure.\nBy default OPEN and CLOSE are round delimiters.\""},"\n  (",{"c":5,"s":"interactive","i":3991}," ",{"c":5,"s":"\"P\"","i":3993},")\n  ",{"c":1,"s":"(paredit-lose-if-not-in-sexp 'paredit-wrap-sexp)"},"\n  ",{"c":1,"s":"(let ((open (or open ?\\( ))\n        (close (or close ?\\) )))\n    (paredit-handle-sexp-errors\n        ((lambda (n) (paredit-insert-pair n open close 'goto-char))\n         (cond ((integerp argument) argument)\n               ((consp argument) (paredit-count-sexps-forward))\n               ((paredit-region-active-p) nil)\n               (t 1)))\n      (insert close)\n      (backward-char)))"},"\n  (",{"c":5,"s":"save-excursion","i":3995}," (",{"c":5,"s":"backward-up-list","i":3997},") (",{"c":5,"s":"indent-sexp","i":3999},")))\n\n",{"c":1,"s":"(defun paredit-count-sexps-forward ()\n  (save-excursion\n    (let ((n 0))\n      (paredit-ignore-sexp-errors\n        (while (not (eobp))\n          (forward-sexp)\n          (setq n (+ n 1))))\n      n)))"},"\n\n",{"c":1,"s":"(defun paredit-yank-pop (&optional argument)\n  \"Replace just-yanked text with the next item in the kill ring.\nIf this command follows a `yank', just run `yank-pop'.\nIf this command follows a `paredit-wrap-sexp', or any other paredit\n  wrapping command (see `paredit-wrap-commands'), run `yank' and\n  reindent the enclosing S-expression.\nIf this command is repeated, run `yank-pop' and reindent the enclosing\n  S-expression.\n\nThe argument is passed on to `yank' or `yank-pop'; see their\n  documentation for details.\"\n  (interactive \"*p\")\n  (cond ((eq last-command 'yank)\n         (yank-pop argument))\n        ((memq last-command paredit-wrap-commands)\n         (yank argument)\n         ;; `yank' futzes with `this-command'.\n         (setq this-command 'paredit-yank-pop)\n         (save-excursion (backward-up-list) (indent-sexp)))\n        ((eq last-command 'paredit-yank-pop)\n         ;; Pretend we just did a `yank', so that we can use\n         ;; `yank-pop' without duplicating its definition.\n         (setq last-command 'yank)\n         (yank-pop argument)\n         ;; Return to our original state.\n         (setq last-command 'paredit-yank-pop)\n         (setq this-command 'paredit-yank-pop)\n         (save-excursion (backward-up-list) (indent-sexp)))\n        (t (error \"Last command was not a yank or a wrap: %s\" last-command))))"},"\n\n",{"c":1,"s":";;; Thanks to Marco Baringer for the suggestion of a prefix argument\n"},{"c":1,"s":";;; for PAREDIT-SPLICE-SEXP.  (I, Taylor R. Campbell, however, still\n"},{"c":1,"s":";;; implemented it, in case any of you lawyer-folk get confused by the\n"},{"c":1,"s":";;; remark in the top of the file about explicitly noting code written\n"},{"c":1,"s":";;; by other people.)\n"},"\n(",{"c":5,"s":"defun","i":4001}," ",{"c":5,"s":"paredit-splice-sexp","i":4003}," ",{"c":1,"s":"(&optional argument)"},"\n  ",{"c":1,"s":"\"Splice the list that the point is on by removing its delimiters.\nWith a prefix argument as in `C-u', kill all S-expressions backward in\n  the current list before splicing all S-expressions forward into the\n  enclosing list.\nWith two prefix arguments as in `C-u C-u', kill all S-expressions\n  forward in the current list before splicing all S-expressions\n  backward into the enclosing list.\nWith a numerical prefix argument N, kill N S-expressions backward in\n  the current list before splicing the remaining S-expressions into the\n  enclosing list.  If N is negative, kill forward.\nInside a string, unescape all backslashes, or signal an error if doing\n  so would invalidate the buffer's structure.\""},"\n  (",{"c":5,"s":"interactive","i":4005}," ",{"c":5,"s":"\"P\"","i":4007},")\n  ",{"c":1,"s":"(if (paredit-in-string-p)\n      (paredit-splice-string argument)\n      (save-excursion\n        (paredit-kill-surrounding-sexps-for-splice argument)\n        (let ((end (point)))\n          (backward-up-list)            ; Go up to the beginning...\n          (save-excursion\n            (forward-char 1)            ; (Skip over leading whitespace\n            (paredit-skip-whitespace t end)\n            (setq end (point)))         ;   for the `delete-region'.)\n          (let ((indent-start nil) (indent-end nil))\n            (save-excursion\n              (setq indent-start (point))\n              (forward-sexp)            ; Go forward an expression, to\n              (backward-delete-char 1)  ;   delete the end delimiter.\n              (setq indent-end (point)))\n            (delete-region (point) end) ; ...to delete the open char.\n            ;; Reindent only the region we preserved.\n            (indent-region indent-start indent-end)))))"},")\n\n(",{"c":5,"s":"defun","i":4009}," ",{"c":5,"s":"paredit-kill-surrounding-sexps-for-splice","i":4011}," ",{"c":1,"s":"(argument)"},"\n  ",{"c":1,"s":"(cond ((or (paredit-in-string-p)\n             (paredit-in-comment-p))\n         (error \"Invalid context for splicing S-expressions.\"))\n        ((or (not argument) (eq argument 0)) nil)\n        ((or (numberp argument) (eq argument '-))\n         ;; Kill S-expressions before/after the point by saving the\n         ;; point, moving across them, and killing the region.\n         (let* ((argument (if (eq argument '-) -1 argument))\n                (saved (paredit-point-at-sexp-boundary (- argument))))\n           (goto-char saved)\n           (paredit-ignore-sexp-errors (backward-sexp argument))\n           (paredit-hack-kill-region saved (point))))\n        ((consp argument)\n         (let ((v (car argument)))\n           (if (= v 4)                  ;One `C-u'.\n               ;; Move backward until we hit the open paren; then\n               ;; kill that selected region.\n               (let ((end (point)))\n                 (paredit-ignore-sexp-errors\n                   (while (not (bobp))\n                     (backward-sexp)))\n                 (paredit-hack-kill-region (point) end))\n               ;; Move forward until we hit the close paren; then\n               ;; kill that selected region.\n               (let ((beginning (point)))\n                 (paredit-ignore-sexp-errors\n                   (while (not (eobp))\n                     (forward-sexp)))\n                 (paredit-hack-kill-region beginning (point))))))\n        (t (error \"Bizarre prefix argument `%s'.\" argument)))"},")\n\n(",{"c":5,"s":"defun","i":4013}," ",{"c":5,"s":"paredit-splice-sexp-killing-backward","i":4015}," (",{"c":5,"s":"&optional","i":4017}," ",{"c":5,"s":"n","i":4019},")\n  ",{"c":5,"s":"\"Splice the list the point is on by removing its delimiters, and\n  also kill all S-expressions before the point in the current list.\nWith a prefix argument N, kill only the preceding N S-expressions.\"","i":4021},"\n  (",{"c":5,"s":"interactive","i":4023}," ",{"c":5,"s":"\"P\"","i":4025},")\n  (",{"c":5,"s":"paredit-splice-sexp","i":4027}," (",{"c":5,"s":"if","i":4029}," ",{"c":5,"s":"n","i":4031},"\n                           (",{"c":5,"s":"prefix-numeric-value","i":4033}," ",{"c":5,"s":"n","i":4035},")\n                           ",{"c":5,"s":"'","i":4037},"(",{"c":5,"s":"4","i":4039},"))))\n\n(",{"c":5,"s":"defun","i":4041}," ",{"c":5,"s":"paredit-splice-sexp-killing-forward","i":4043}," (",{"c":5,"s":"&optional","i":4045}," ",{"c":5,"s":"n","i":4047},")\n  ",{"c":5,"s":"\"Splice the list the point is on by removing its delimiters, and\n  also kill all S-expressions after the point in the current list.\nWith a prefix argument N, kill only the following N S-expressions.\"","i":4049},"\n  (",{"c":5,"s":"interactive","i":4051}," ",{"c":5,"s":"\"P\"","i":4053},")\n  (",{"c":5,"s":"paredit-splice-sexp","i":4055}," (",{"c":5,"s":"if","i":4057}," ",{"c":5,"s":"n","i":4059},"\n                           (",{"c":5,"s":"-","i":4061}," (",{"c":5,"s":"prefix-numeric-value","i":4063}," ",{"c":5,"s":"n","i":4065},"))\n                           ",{"c":5,"s":"'","i":4067},"(",{"c":5,"s":"16","i":4069},"))))\n\n(",{"c":5,"s":"defun","i":4071}," ",{"c":5,"s":"paredit-raise-sexp","i":4073}," ",{"c":1,"s":"(&optional argument)"},"\n  ",{"c":1,"s":"\"Raise the following S-expression in a tree, deleting its siblings.\nWith a prefix argument N, raise the following N S-expressions.  If N\n  is negative, raise the preceding N S-expressions.\nIf the point is on an S-expression, such as a string or a symbol, not\n  between them, that S-expression is considered to follow the point.\""},"\n  ",{"c":1,"s":"(interactive \"P\")"},"\n  ",{"c":1,"s":"(save-excursion\n    (cond ((paredit-in-string-p)\n           (goto-char (car (paredit-string-start+end-points))))\n          ((paredit-in-char-p)\n           (backward-sexp))\n          ((paredit-in-comment-p)\n           (error \"No S-expression to raise in comment.\")))\n    ;; Select the S-expressions we want to raise in a buffer substring.\n    (let* ((n (prefix-numeric-value argument))\n           (bound (scan-sexps (point) n))\n           (sexps\n            (if (< n 0)\n                (buffer-substring bound (paredit-point-at-sexp-end))\n                (buffer-substring (paredit-point-at-sexp-start) bound))))\n      ;; Move up to the list we're raising those S-expressions out of and\n      ;; delete it.\n      (backward-up-list)\n      (delete-region (point) (scan-sexps (point) 1))\n      (let* ((indent-start (point))\n             (indent-end (save-excursion (insert sexps) (point))))\n        (indent-region indent-start indent-end))))"},")\n\n",{"c":1,"s":"(defun paredit-convolute-sexp (&optional n)\n  \"Convolute S-expressions.\nSave the S-expressions preceding point and delete them.\nSplice the S-expressions following point.\nWrap the enclosing list in a new list prefixed by the saved text.\nWith a prefix argument N, move up N lists before wrapping.\"\n  (interactive \"p\")\n  (paredit-lose-if-not-in-sexp 'paredit-convolute-sexp)\n  (let (open close)                     ;++ Is this a good idea?\n    (let ((prefix\n           (let ((end (point)))\n             (paredit-ignore-sexp-errors\n               (while (not (bobp)) (backward-sexp)))\n             (prog1 (buffer-substring (point) end)\n               (backward-up-list)\n               (save-excursion (forward-sexp)\n                               (setq close (char-before))\n                               (backward-delete-char 1))\n               (setq open (char-after))\n               (delete-region (point) end)))))\n      (backward-up-list n)\n      (paredit-insert-pair 1 open close 'goto-char)\n      (insert prefix)\n      (backward-up-list)\n      (paredit-ignore-sexp-errors (indent-sexp)))))"},"\n\n",{"c":1,"s":"(defun paredit-splice-string (argument)\n  (let ((original-point (point))\n        (start+end (paredit-string-start+end-points)))\n    (let ((start (car start+end))\n          (end (cdr start+end)))\n      ;; START and END both lie before the respective quote\n      ;; characters, which we want to delete; thus we increment START\n      ;; by one to extract the string, and we increment END by one to\n      ;; delete the string.\n      (let* ((escaped-string\n              (cond ((not (consp argument))\n                     (buffer-substring (1+ start) end))\n                    ((= 4 (car argument))\n                     (buffer-substring original-point end))\n                    (t\n                     (buffer-substring (1+ start) original-point))))\n             (unescaped-string\n              (paredit-unescape-string escaped-string)))\n        (if (not unescaped-string)\n            (error \"Unspliceable string.\")\n          (save-excursion\n            (goto-char start)\n            (delete-region start (1+ end))\n            (insert unescaped-string))\n          (if (not (and (consp argument)\n                        (= 4 (car argument))))\n              (goto-char (- original-point 1))))))))"},"\n\n",{"c":1,"s":"(defun paredit-unescape-string (string)\n  (with-temp-buffer\n    (insert string)\n    (goto-char (point-min))\n    (while (and (not (eobp))\n                ;; nil -> no bound; t -> no errors.\n                (search-forward \"\\\\\" nil t))\n      (delete-char -1)\n      (forward-char))\n    (condition-case condition\n        (progn (check-parens) (buffer-string))\n      (error nil))))"},"\n\n",{"c":1,"s":";;;; Slurpage & Barfage\n"},"\n(",{"c":5,"s":"defun","i":4075}," ",{"c":5,"s":"paredit-forward-slurp-sexp","i":4077}," ()\n  ",{"c":5,"s":"\"Add the S-expression following the current list into that list\n  by moving the closing delimiter.\nAutomatically reindent the newly slurped S-expression with respect to\n  its new enclosing form.\nIf in a string, move the opening double-quote forward by one\n  S-expression and escape any intervening characters as necessary,\n  without altering any indentation or formatting.\"","i":4079},"\n  (",{"c":5,"s":"interactive","i":4081},")\n  ",{"c":1,"s":"(save-excursion\n    (cond ((or (paredit-in-comment-p)\n               (paredit-in-char-p))\n           (error \"Invalid context for slurping S-expressions.\"))\n          ((paredit-in-string-p)\n           (paredit-forward-slurp-into-string))\n          (t\n           (paredit-forward-slurp-into-list))))"},")\n\n(",{"c":5,"s":"defun","i":4083}," ",{"c":5,"s":"paredit-forward-slurp-into-list","i":4085}," ()\n  (",{"c":5,"s":"up-list","i":4087},")                             ",{"c":5,"s":"; Up to the end of the list to\n","i":4089},"  (",{"c":3,"s":"let","i":961}," ((",{"c":3,"s":"close","i":963}," (",{"c":3,"s":"char-before","i":965},")))          ",{"c":3,"s":";   save and delete the closing\n","i":967},"    (",{"c":3,"s":"backward-delete-char","i":969}," ",{"c":3,"s":"1","i":971},")            ",{"c":3,"s":";   delimiter.\n","i":973},"    (",{"c":3,"s":"catch","i":975}," ",{"c":3,"s":"'","i":977},{"c":3,"s":"return","i":979},"                      ",{"c":3,"s":"; Go to the end of the desired\n","i":981},"      (",{"c":3,"s":"while","i":983}," ",{"c":3,"s":"t","i":985},"                          ",{"c":3,"s":";   S-expression, going up a\n","i":987},"        (",{"c":1,"s":"paredit-handle-sexp-errors"},"     ",{"c":1,"s":";   list if it's not in this,\n"},"            (",{"c":3,"s":"progn","i":989}," (",{"c":3,"s":"paredit-forward-and-indent","i":991},")\n                   (",{"c":3,"s":"throw","i":993}," ",{"c":3,"s":"'","i":995},{"c":3,"s":"return","i":997}," ",{"c":3,"s":"nil","i":999},"))\n          ",{"c":1,"s":"(up-list)"},"\n          ",{"c":1,"s":"(setq close                   ; adjusting for mixed\n                (prog1 (char-before)    ;   delimiters as necessary,\n                  (backward-delete-char 1)\n                  (insert close)))"},")))\n    (",{"c":3,"s":"insert","i":1001}," ",{"c":3,"s":"close","i":1003},")))                    ",{"c":5,"s":"; to insert that delimiter.\n","i":4091},"\n(",{"c":5,"s":"defun","i":4093}," ",{"c":5,"s":"paredit-forward-slurp-into-string","i":4095}," ()\n  (",{"c":5,"s":"goto-char","i":4097}," (",{"c":5,"s":"1+","i":4099}," (",{"c":5,"s":"cdr","i":4101}," (",{"c":5,"s":"paredit-string-start+end-points","i":4103},"))))\n  ",{"c":5,"s":";; Signal any errors that we might get first, before mucking with the\n","i":4105},"  ",{"c":5,"s":";; buffer's contents.\n","i":4107},"  (",{"c":5,"s":"save-excursion","i":4109}," (",{"c":5,"s":"forward-sexp","i":4111},"))\n  (",{"c":5,"s":"let","i":4113}," ((",{"c":5,"s":"close","i":4115}," (",{"c":5,"s":"char-before","i":4117},")))\n    (",{"c":5,"s":"backward-delete-char","i":4119}," ",{"c":5,"s":"1","i":4121},")\n    (",{"c":5,"s":"paredit-forward-for-quote","i":4123}," (",{"c":5,"s":"save-excursion","i":4125}," (",{"c":5,"s":"forward-sexp","i":4127},") (",{"c":5,"s":"point","i":4129},")))\n    (",{"c":5,"s":"insert","i":4131}," ",{"c":5,"s":"close","i":4133},")))\n\n(",{"c":5,"s":"defun","i":4135}," ",{"c":5,"s":"paredit-forward-barf-sexp","i":4137}," ()\n  ",{"c":5,"s":"\"Remove the last S-expression in the current list from that list\n  by moving the closing delimiter.\nAutomatically reindent the newly barfed S-expression with respect to\n  its new enclosing form.\"","i":4139},"\n  (",{"c":5,"s":"interactive","i":4141},")\n  ",{"c":1,"s":"(paredit-lose-if-not-in-sexp 'paredit-forward-barf-sexp)"},"\n  (",{"c":5,"s":"save-excursion","i":4143},"\n    (",{"c":5,"s":"up-list","i":4145},")                           ",{"c":5,"s":"; Up to the end of the list to\n","i":4147},"    (",{"c":5,"s":"let","i":4149}," ((",{"c":5,"s":"close","i":4151}," (",{"c":5,"s":"char-before","i":4153},")))        ",{"c":5,"s":";   save and delete the closing\n","i":4155},"      (",{"c":5,"s":"backward-delete-char","i":4157}," ",{"c":5,"s":"1","i":4159},")          ",{"c":5,"s":";   delimiter.\n","i":4161},"      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":4163},"       ",{"c":5,"s":"; Go back to where we want to\n","i":4165},"        (",{"c":5,"s":"backward-sexp","i":4167},"))                ",{"c":5,"s":";   insert the delimiter.\n","i":4169},"      (",{"c":5,"s":"paredit-skip-whitespace","i":4171}," ",{"c":5,"s":"nil","i":4173},")     ",{"c":5,"s":"; Skip leading whitespace.\n","i":4175},"      (",{"c":5,"s":"cond","i":4177}," ((",{"c":5,"s":"bobp","i":4179},")\n             (",{"c":5,"s":"error","i":4181}," ",{"c":5,"s":"\"Barfing all subexpressions with no open-paren?\"","i":4183},"))\n            ((",{"c":5,"s":"paredit-in-comment-p","i":4185},")     ",{"c":5,"s":"; Don't put the close-paren in\n","i":4187},"             (",{"c":5,"s":"newline-and-indent","i":4189},")))     ",{"c":5,"s":";   a comment.\n","i":4191},"      (",{"c":5,"s":"insert","i":4193}," ",{"c":5,"s":"close","i":4195},"))\n    ",{"c":5,"s":";; Reindent all of the newly barfed S-expressions.\n","i":4197},"    (",{"c":5,"s":"paredit-forward-and-indent","i":4199},")))\n\n(",{"c":5,"s":"defun","i":4201}," ",{"c":5,"s":"paredit-backward-slurp-sexp","i":4203}," ()\n  ",{"c":5,"s":"\"Add the S-expression preceding the current list into that list\n  by moving the closing delimiter.\nAutomatically reindent the whole form into which new S-expression was\n  slurped.\nIf in a string, move the opening double-quote backward by one\n  S-expression and escape any intervening characters as necessary,\n  without altering any indentation or formatting.\"","i":4205},"\n  (",{"c":5,"s":"interactive","i":4207},")\n  ",{"c":1,"s":"(save-excursion\n    (cond ((or (paredit-in-comment-p)\n               (paredit-in-char-p))\n           (error \"Invalid context for slurping S-expressions.\"))\n          ((paredit-in-string-p)\n           (paredit-backward-slurp-into-string))\n          (t\n           (paredit-backward-slurp-into-list))))"},")\n\n(",{"c":5,"s":"defun","i":4209}," ",{"c":5,"s":"paredit-backward-slurp-into-list","i":4211}," ()\n  (",{"c":5,"s":"backward-up-list","i":4213},")\n  (",{"c":3,"s":"let","i":1005}," ((",{"c":3,"s":"open","i":1007}," (",{"c":3,"s":"char-after","i":1009},")))\n    (",{"c":3,"s":"delete-char","i":1011}," ",{"c":3,"s":"1","i":1013},")\n    (",{"c":3,"s":"catch","i":1015}," ",{"c":3,"s":"'","i":1017},{"c":3,"s":"return","i":1019},"\n      (",{"c":3,"s":"while","i":1021}," ",{"c":3,"s":"t","i":1023},"\n        (",{"c":1,"s":"paredit-handle-sexp-errors"},"\n            (",{"c":3,"s":"progn","i":1025}," (",{"c":3,"s":"backward-sexp","i":1027},") (",{"c":3,"s":"throw","i":1029}," ",{"c":3,"s":"'","i":1031},{"c":3,"s":"return","i":1033}," ",{"c":3,"s":"nil","i":1035},"))\n          ",{"c":1,"s":"(backward-up-list)"},"\n          ",{"c":1,"s":"(setq open\n                (prog1 (char-after)\n                  (save-excursion (insert open) (delete-char 1))))"},")))\n    (",{"c":3,"s":"insert","i":1037}," ",{"c":3,"s":"open","i":1039},"))\n  ",{"c":1,"s":";; Reindent the line at the beginning of wherever we inserted the\n"},"  ",{"c":1,"s":";; opening delimiter, and then indent the whole S-expression.\n"},"  (",{"c":5,"s":"backward-up-list","i":4215},")\n  (",{"c":5,"s":"lisp-indent-line","i":4217},")\n  (",{"c":5,"s":"indent-sexp","i":4219},"))\n\n(",{"c":5,"s":"defun","i":4221}," ",{"c":5,"s":"paredit-backward-slurp-into-string","i":4223}," ()\n  (",{"c":5,"s":"goto-char","i":4225}," (",{"c":5,"s":"car","i":4227}," (",{"c":5,"s":"paredit-string-start+end-points","i":4229},")))\n  ",{"c":5,"s":";; Signal any errors that we might get first, before mucking with the\n","i":4231},"  ",{"c":5,"s":";; buffer's contents.\n","i":4233},"  (",{"c":5,"s":"save-excursion","i":4235}," (",{"c":5,"s":"backward-sexp","i":4237},"))\n  ",{"c":1,"s":"(let ((open (char-after))\n        (target (point)))\n    (delete-char 1)\n    (backward-sexp)\n    (insert open)\n    (paredit-forward-for-quote target))"},")\n\n(",{"c":5,"s":"defun","i":4239}," ",{"c":5,"s":"paredit-backward-barf-sexp","i":4241}," ()\n  ",{"c":5,"s":"\"Remove the first S-expression in the current list from that list\n  by moving the closing delimiter.\nAutomatically reindent the barfed S-expression and the form from which\n  it was barfed.\"","i":4243},"\n  (",{"c":5,"s":"interactive","i":4245},")\n  ",{"c":1,"s":"(paredit-lose-if-not-in-sexp 'paredit-backward-barf-sexp)"},"\n  (",{"c":5,"s":"save-excursion","i":4247},"\n    (",{"c":5,"s":"backward-up-list","i":4249},")\n    (",{"c":5,"s":"let","i":4251}," ((",{"c":5,"s":"open","i":4253}," (",{"c":5,"s":"char-after","i":4255},")))\n      (",{"c":5,"s":"delete-char","i":4257}," ",{"c":5,"s":"1","i":4259},")\n      (",{"c":5,"s":"paredit-ignore-sexp-errors","i":4261},"\n        (",{"c":5,"s":"paredit-forward-and-indent","i":4263},"))\n      (",{"c":5,"s":"while","i":4265}," (",{"c":5,"s":"progn","i":4267}," (",{"c":5,"s":"paredit-skip-whitespace","i":4269}," ",{"c":5,"s":"t","i":4271},")\n                    (",{"c":5,"s":"eq","i":4273}," (",{"c":5,"s":"char-after","i":4275},") ",{"c":5,"s":"?\\;","i":4277}," ))\n        (",{"c":5,"s":"forward-line","i":4279}," ",{"c":5,"s":"1","i":4281},"))\n      (",{"c":5,"s":"if","i":4283}," (",{"c":5,"s":"eobp","i":4285},")\n          (",{"c":5,"s":"error","i":4287}," ",{"c":5,"s":"\"Barfing all subexpressions with no close-paren?\"","i":4289},"))\n      ",{"c":5,"s":";** Don't use `insert' here.  Consider, e.g., barfing from\n","i":4291},"      ",{"c":5,"s":";**   (foo|)\n","i":4293},"      ",{"c":5,"s":";** and how `save-excursion' works.\n","i":4295},"      (",{"c":5,"s":"insert-before-markers","i":4297}," ",{"c":5,"s":"open","i":4299},"))\n    (",{"c":5,"s":"backward-up-list","i":4301},")\n    (",{"c":5,"s":"lisp-indent-line","i":4303},")\n    (",{"c":5,"s":"indent-sexp","i":4305},")))\n\n",{"c":5,"s":";;;; Splitting & Joining\n","i":4307},"\n(",{"c":5,"s":"defun","i":4309}," ",{"c":5,"s":"paredit-split-sexp","i":4311}," ()\n  ",{"c":5,"s":"\"Split the list or string the point is on into two.\"","i":4313},"\n  (",{"c":5,"s":"interactive","i":4315},")\n  ",{"c":1,"s":"(cond ((paredit-in-string-p)\n         (insert \"\\\"\")\n         (save-excursion (insert \" \\\"\")))\n        ((or (paredit-in-comment-p)\n             (paredit-in-char-p))\n         (error \"Invalid context for splitting S-expression.\"))\n        (t (let ((open  (save-excursion (backward-up-list)\n                                        (char-after)))\n                 (close (save-excursion (up-list)\n                                        (char-before))))\n             (delete-horizontal-space)\n             (insert close)\n             (save-excursion (insert ?\\ )\n                             (insert open)\n                             (backward-char)\n                             (indent-sexp)))))"},")\n\n(",{"c":5,"s":"defun","i":4317}," ",{"c":5,"s":"paredit-join-sexps","i":4319}," ()\n  ",{"c":5,"s":"\"Join the S-expressions adjacent on either side of the point.\nBoth must be lists, strings, or atoms; error if there is a mismatch.\"","i":4321},"\n  (",{"c":5,"s":"interactive","i":4323},")\n  ",{"c":5,"s":";++ How ought this to handle comments intervening symbols or strings?\n","i":4325},"  (",{"c":3,"s":"save-excursion","i":1041},"\n    (",{"c":1,"s":"if"}," ",{"c":1,"s":"(or (paredit-in-comment-p)\n            (paredit-in-string-p)\n            (paredit-in-char-p))"},"\n        ",{"c":1,"s":"(error \"Invalid context for joining S-expressions.\")"},"\n      (",{"c":1,"s":"let"}," ",{"c":1,"s":"((left-point  (paredit-point-at-sexp-end))\n            (right-point (paredit-point-at-sexp-start)))"},"\n        (",{"c":3,"s":"let","i":1043}," ((",{"c":3,"s":"left-char","i":1045}," (",{"c":3,"s":"char-before","i":1047}," ",{"c":3,"s":"left-point","i":1049},"))\n              (",{"c":3,"s":"right-char","i":1051}," (",{"c":3,"s":"char-after","i":1053}," ",{"c":3,"s":"right-point","i":1055},")))\n          (",{"c":3,"s":"let","i":1057}," ((",{"c":3,"s":"left-syntax","i":1059}," (",{"c":3,"s":"char-syntax","i":1061}," ",{"c":3,"s":"left-char","i":1063},"))\n                (",{"c":3,"s":"right-syntax","i":1065}," (",{"c":3,"s":"char-syntax","i":1067}," ",{"c":3,"s":"right-char","i":1069},")))\n            (",{"c":3,"s":"cond","i":1071}," ((",{"c":3,"s":">=","i":1073}," ",{"c":3,"s":"left-point","i":1075}," ",{"c":3,"s":"right-point","i":1077},")\n                   (",{"c":3,"s":"error","i":1079}," ",{"c":3,"s":"\"Can't join a datum with itself.\"","i":1081},"))\n                  ((",{"c":3,"s":"and","i":1083}," (",{"c":3,"s":"eq","i":1085}," ",{"c":3,"s":"left-syntax","i":1087},"  ",{"c":3,"s":"?\\)","i":1089}," )\n                        (",{"c":3,"s":"eq","i":1091}," ",{"c":3,"s":"right-syntax","i":1093}," ",{"c":3,"s":"?\\(","i":1095}," )\n                        (",{"c":3,"s":"eq","i":1097}," ",{"c":3,"s":"left-char","i":1099}," (",{"c":3,"s":"matching-paren","i":1101}," ",{"c":3,"s":"right-char","i":1103},"))\n                        (",{"c":3,"s":"eq","i":1105}," ",{"c":3,"s":"right-char","i":1107}," (",{"c":3,"s":"matching-paren","i":1109}," ",{"c":3,"s":"left-char","i":1111},")))\n                   ",{"c":3,"s":";; Leave intermediate formatting alone.\n","i":1113},"                   (",{"c":3,"s":"goto-char","i":1115}," ",{"c":3,"s":"right-point","i":1117},")\n                   (",{"c":3,"s":"delete-char","i":1119}," ",{"c":3,"s":"1","i":1121},")\n                   (",{"c":3,"s":"goto-char","i":1123}," ",{"c":3,"s":"left-point","i":1125},")\n                   (",{"c":3,"s":"backward-delete-char","i":1127}," ",{"c":3,"s":"1","i":1129},")\n                   (",{"c":3,"s":"backward-up-list","i":1131},")\n                   (",{"c":3,"s":"indent-sexp","i":1133},"))\n                  ((",{"c":3,"s":"and","i":1135}," (",{"c":3,"s":"eq","i":1137}," ",{"c":3,"s":"left-syntax","i":1139},"  ",{"c":3,"s":"?\\\"","i":1141}," )\n                        (",{"c":3,"s":"eq","i":1143}," ",{"c":3,"s":"right-syntax","i":1145}," ",{"c":3,"s":"?\\\"","i":1147}," ))\n                   ",{"c":3,"s":";; Delete any intermediate formatting.\n","i":1149},"                   (",{"c":3,"s":"delete-region","i":1151}," (",{"c":3,"s":"1-","i":1153}," ",{"c":3,"s":"left-point","i":1155},")\n                                  (",{"c":3,"s":"1+","i":1157}," ",{"c":3,"s":"right-point","i":1159},")))\n                  ((",{"c":3,"s":"and","i":1161}," (",{"c":3,"s":"memq","i":1163}," ",{"c":3,"s":"left-syntax","i":1165},"  ",{"c":3,"s":"'","i":1167},"(",{"c":3,"s":"?w","i":1169}," ",{"c":3,"s":"?_","i":1171},")) ",{"c":3,"s":"; Word or symbol\n","i":1173},"                        (",{"c":3,"s":"memq","i":1175}," ",{"c":3,"s":"right-syntax","i":1177}," ",{"c":3,"s":"'","i":1179},"(",{"c":3,"s":"?w","i":1181}," ",{"c":3,"s":"?_","i":1183},")))\n                   (",{"c":3,"s":"delete-region","i":1185}," ",{"c":3,"s":"left-point","i":1187}," ",{"c":3,"s":"right-point","i":1189},"))\n                  (",{"c":3,"s":"t","i":1191},"\n                   (",{"c":3,"s":"error","i":1193}," ",{"c":3,"s":"\"Mismatched S-expressions to join.\"","i":1195},")))))))))\n\n",{"c":1,"s":";;;; Variations on the Lurid Theme\n"},"\n",{"c":1,"s":";;; I haven't the imagination to concoct clever names for these.\n"},"\n",{"c":1,"s":"(defun paredit-add-to-previous-list ()\n  \"Add the S-expression following point to the list preceding point.\"\n  (interactive)\n  (paredit-lose-if-not-in-sexp 'paredit-add-to-previous-list)\n  (save-excursion\n    (backward-down-list)\n    (paredit-forward-slurp-sexp)))"},"\n\n",{"c":1,"s":"(defun paredit-add-to-next-list ()\n  \"Add the S-expression preceding point to the list following point.\nIf no S-expression precedes point, move up the tree until one does.\"\n  (interactive)\n  (paredit-lose-if-not-in-sexp 'paredit-add-to-next-list)\n  (save-excursion\n    (down-list)\n    (paredit-backward-slurp-sexp)))"},"\n\n",{"c":1,"s":"(defun paredit-join-with-previous-list ()\n  \"Join the list the point is on with the previous list in the buffer.\"\n  (interactive)\n  (paredit-lose-if-not-in-sexp 'paredit-join-with-previous-list)\n  (save-excursion\n    (while (paredit-handle-sexp-errors (save-excursion (backward-sexp) nil)\n             (backward-up-list)\n             t))\n    (paredit-join-sexps)))"},"\n\n",{"c":1,"s":"(defun paredit-join-with-next-list ()\n  \"Join the list the point is on with the next list in the buffer.\"\n  (interactive)\n  (paredit-lose-if-not-in-sexp 'paredit-join-with-next-list)\n  (save-excursion\n    (while (paredit-handle-sexp-errors (save-excursion (forward-sexp) nil)\n             (up-list)\n             t))\n    (paredit-join-sexps)))"},"\n\n",{"c":1,"s":";;;; Utilities\n"},"\n(",{"c":5,"s":"defun","i":4327}," ",{"c":5,"s":"paredit-in-string-escape-p","i":4329}," ()\n  ",{"c":5,"s":"\"True if the point is on a character escape of a string.\nThis is true only if the character is preceded by an odd number of\n  backslashes.\nThis assumes that `paredit-in-string-p' has already returned true.\"","i":4331},"\n  (",{"c":5,"s":"let","i":4333}," ((",{"c":5,"s":"oddp","i":4335}," ",{"c":5,"s":"nil","i":4337},"))\n    (",{"c":5,"s":"save-excursion","i":4339},"\n      (",{"c":5,"s":"while","i":4341}," (",{"c":5,"s":"eq","i":4343}," (",{"c":5,"s":"char-before","i":4345},") ",{"c":5,"s":"?\\\\","i":4347}," )\n        (",{"c":5,"s":"setq","i":4349}," ",{"c":5,"s":"oddp","i":4351}," (",{"c":5,"s":"not","i":4353}," ",{"c":5,"s":"oddp","i":4355},"))\n        (",{"c":5,"s":"backward-char","i":4357},")))\n    ",{"c":5,"s":"oddp","i":4359},"))\n\n(",{"c":5,"s":"defun","i":4361}," ",{"c":5,"s":"paredit-in-char-p","i":4363}," ",{"c":1,"s":"(&optional argument)"},"\n  ",{"c":5,"s":"\"True if the point is immediately after a character literal.\nA preceding escape character, not preceded by another escape character,\n  is considered a character literal prefix.  (This works for elisp,\n  Common Lisp, and Scheme.)\nAssumes that `paredit-in-string-p' is false, so that it need not handle\n  long sequences of preceding backslashes in string escapes.  (This\n  assumes some other leading character token -- ? in elisp, # in Scheme\n  and Common Lisp.)\"","i":4365},"\n  ",{"c":1,"s":"(let ((argument (or argument (point))))\n    (and (eq (char-before argument) ?\\\\ )\n         (not (eq (char-before (1- argument)) ?\\\\ ))))"},")\n\n",{"c":1,"s":"(defun paredit-indent-sexps ()\n  \"If in a list, indent all following S-expressions in the list.\"\n  (let ((start (point))\n        (end (paredit-handle-sexp-errors (progn (up-list) (point)) nil)))\n    (if end\n        (indent-region start end))))"},"\n\n(",{"c":5,"s":"defun","i":4367}," ",{"c":5,"s":"paredit-forward-and-indent","i":4369}," ()\n  ",{"c":1,"s":"\"Move forward an S-expression, indenting it with `indent-region'.\""},"\n  ",{"c":1,"s":"(let ((start (point)))\n    (forward-sexp)\n    (indent-region start (point)))"},")\n\n(",{"c":5,"s":"defun","i":4371}," ",{"c":5,"s":"paredit-skip-whitespace","i":4373}," (",{"c":5,"s":"trailing-p","i":4375}," ",{"c":5,"s":"&optional","i":4377}," ",{"c":5,"s":"limit","i":4379},")\n  ",{"c":5,"s":"\"Skip past any whitespace, or until the point LIMIT is reached.\nIf TRAILING-P is nil, skip leading whitespace; otherwise, skip trailing\n  whitespace.\"","i":4381},"\n  (",{"c":5,"s":"funcall","i":4383}," (",{"c":5,"s":"if","i":4385}," ",{"c":5,"s":"trailing-p","i":4387}," ",{"c":5,"s":"'","i":4389},{"c":5,"s":"skip-chars-forward","i":4391}," ",{"c":5,"s":"'","i":4393},{"c":5,"s":"skip-chars-backward","i":4395},")\n           ",{"c":5,"s":"\" \\t\\n\"","i":4397},"  ",{"c":5,"s":"; This should skip using the syntax table, but LF\n","i":4399},"           ",{"c":5,"s":"limit","i":4401},"))    ",{"c":5,"s":"; is a comment end, not newline, in Lisp mode.\n","i":4403},"\n(",{"c":5,"s":"defalias","i":4405}," ",{"c":5,"s":"'","i":4407},{"c":5,"s":"paredit-region-active-p","i":4409},"\n  (",{"c":5,"s":"xcond","i":4411}," ((",{"c":5,"s":"paredit-xemacs-p","i":4413},") ",{"c":5,"s":"'","i":4415},{"c":5,"s":"region-active-p","i":4417},")\n         ((",{"c":5,"s":"paredit-gnu-emacs-p","i":4419},")\n          (",{"c":5,"s":"lambda","i":4421}," ()\n            (",{"c":5,"s":"and","i":4423}," ",{"c":5,"s":"mark-active","i":4425}," ",{"c":5,"s":"transient-mark-mode","i":4427},")))))\n\n",{"c":1,"s":"(defun paredit-hack-kill-region (start end)\n  \"Kill the region between START and END.\nDo not append to any current kill, and\n do not let the next kill append to this one.\"\n  (interactive \"r\")                     ;Eh, why not?\n  ;; KILL-REGION sets THIS-COMMAND to tell the next kill that the last\n  ;; command was a kill.  It also checks LAST-COMMAND to see whether it\n  ;; should append.  If we bind these locally, any modifications to\n  ;; THIS-COMMAND will be masked, and it will not see LAST-COMMAND to\n  ;; indicate that it should append.\n  (let ((this-command nil)\n        (last-command nil))\n    (kill-region start end)))"},"\n\n",{"c":1,"s":";;;;; S-expression Parsing Utilities\n"},"\n",{"c":1,"s":";++ These routines redundantly traverse S-expressions a great deal.\n"},{"c":1,"s":";++ If performance issues arise, this whole section will probably have\n"},{"c":1,"s":";++ to be refactored to preserve the state longer, like paredit.scm\n"},{"c":1,"s":";++ does, rather than to traverse the definition N times for every key\n"},{"c":1,"s":";++ stroke as it presently does.\n"},"\n(",{"c":5,"s":"defun","i":4429}," ",{"c":5,"s":"paredit-current-parse-state","i":4431}," ()\n  ",{"c":5,"s":"\"Return parse state of point from beginning of defun.\"","i":4433},"\n  (",{"c":5,"s":"let","i":4435}," ((",{"c":5,"s":"point","i":4437}," (",{"c":5,"s":"point","i":4439},")))\n    (",{"c":5,"s":"beginning-of-defun","i":4441},")\n    ",{"c":5,"s":";; Calling PARSE-PARTIAL-SEXP will advance the point to its second\n","i":4443},"    ",{"c":5,"s":";; argument (unless parsing stops due to an error, but we assume it\n","i":4445},"    ",{"c":5,"s":";; won't in paredit-mode).\n","i":4447},"    (",{"c":5,"s":"parse-partial-sexp","i":4449}," (",{"c":5,"s":"point","i":4451},") ",{"c":5,"s":"point","i":4453},")))\n\n(",{"c":5,"s":"defun","i":4455}," ",{"c":5,"s":"paredit-in-string-p","i":4457}," (",{"c":5,"s":"&optional","i":4459}," ",{"c":5,"s":"state","i":4461},")\n  ",{"c":5,"s":"\"True if the parse state is within a double-quote-delimited string.\nIf no parse state is supplied, compute one from the beginning of the\n  defun to the point.\"","i":4463},"\n  ",{"c":5,"s":";; 3. non-nil if inside a string (the terminator character, really)\n","i":4465},"  (",{"c":5,"s":"and","i":4467}," (",{"c":5,"s":"nth","i":4469}," ",{"c":5,"s":"3","i":4471}," (",{"c":5,"s":"or","i":4473}," ",{"c":5,"s":"state","i":4475}," (",{"c":5,"s":"paredit-current-parse-state","i":4477},")))\n       ",{"c":5,"s":"t","i":4479},"))\n\n(",{"c":5,"s":"defun","i":4481}," ",{"c":5,"s":"paredit-string-start+end-points","i":4483}," (",{"c":5,"s":"&optional","i":4485}," ",{"c":5,"s":"state","i":4487},")\n  ",{"c":5,"s":"\"Return a cons of the points of open and close quotes of the string.\nThe string is determined from the parse state STATE, or the parse state\n  from the beginning of the defun to the point.\nThis assumes that `paredit-in-string-p' has already returned true, i.e.\n  that the point is already within a string.\"","i":4489},"\n  (",{"c":5,"s":"save-excursion","i":4491},"\n    ",{"c":5,"s":";; 8. character address of start of comment or string; nil if not\n","i":4493},"    ",{"c":5,"s":";;    in one\n","i":4495},"    (",{"c":5,"s":"let","i":4497}," ((",{"c":5,"s":"start","i":4499}," (",{"c":5,"s":"nth","i":4501}," ",{"c":5,"s":"8","i":4503}," (",{"c":5,"s":"or","i":4505}," ",{"c":5,"s":"state","i":4507}," (",{"c":5,"s":"paredit-current-parse-state","i":4509},")))))\n      (",{"c":5,"s":"goto-char","i":4511}," ",{"c":5,"s":"start","i":4513},")\n      (",{"c":5,"s":"forward-sexp","i":4515}," ",{"c":5,"s":"1","i":4517},")\n      (",{"c":5,"s":"cons","i":4519}," ",{"c":5,"s":"start","i":4521}," (",{"c":5,"s":"1-","i":4523}," (",{"c":5,"s":"point","i":4525},"))))))\n\n(",{"c":5,"s":"defun","i":4527}," ",{"c":5,"s":"paredit-in-comment-p","i":4529}," (",{"c":5,"s":"&optional","i":4531}," ",{"c":5,"s":"state","i":4533},")\n  ",{"c":5,"s":"\"True if parse state STATE is within a comment.\nIf no parse state is supplied, compute one from the beginning of the\n  defun to the point.\"","i":4535},"\n  ",{"c":5,"s":";; 4. nil if outside a comment, t if inside a non-nestable comment,\n","i":4537},"  ",{"c":5,"s":";;    else an integer (the current comment nesting)\n","i":4539},"  (",{"c":5,"s":"and","i":4541}," (",{"c":5,"s":"nth","i":4543}," ",{"c":5,"s":"4","i":4545}," (",{"c":5,"s":"or","i":4547}," ",{"c":5,"s":"state","i":4549}," (",{"c":5,"s":"paredit-current-parse-state","i":4551},")))\n       ",{"c":5,"s":"t","i":4553},"))\n\n(",{"c":5,"s":"defun","i":4555}," ",{"c":5,"s":"paredit-point-at-sexp-boundary","i":4557}," (",{"c":5,"s":"n","i":4559},")\n  (",{"c":5,"s":"cond","i":4561}," ((",{"c":5,"s":"<","i":4563}," ",{"c":5,"s":"n","i":4565}," ",{"c":5,"s":"0","i":4567},") (",{"c":5,"s":"paredit-point-at-sexp-start","i":4569},"))\n        ((",{"c":5,"s":"=","i":4571}," ",{"c":5,"s":"n","i":4573}," ",{"c":5,"s":"0","i":4575},") (",{"c":5,"s":"point","i":4577},"))\n        ((",{"c":5,"s":">","i":4579}," ",{"c":5,"s":"n","i":4581}," ",{"c":5,"s":"0","i":4583},") (",{"c":5,"s":"paredit-point-at-sexp-end","i":4585},"))))\n\n(",{"c":5,"s":"defun","i":4587}," ",{"c":5,"s":"paredit-point-at-sexp-start","i":4589}," ()\n  ",{"c":1,"s":"(save-excursion\n    (forward-sexp)\n    (backward-sexp)\n    (point))"},")\n\n(",{"c":5,"s":"defun","i":4591}," ",{"c":5,"s":"paredit-point-at-sexp-end","i":4593}," ()\n  ",{"c":1,"s":"(save-excursion\n    (backward-sexp)\n    (forward-sexp)\n    (point))"},")\n\n",{"c":1,"s":"(defun paredit-lose-if-not-in-sexp (command)\n  (if (or (paredit-in-string-p)\n          (paredit-in-comment-p)\n          (paredit-in-char-p))\n      (error \"Invalid context for command `%s'.\" command)))"},"\n\n",{"c":1,"s":"(defun paredit-check-region (start end)\n  (save-restriction\n    (narrow-to-region start end)\n    (if (fboundp 'check-parens)\n        (check-parens)\n        (save-excursion\n          (goto-char (point-min))\n          (while (not (eobp))\n            (forward-sexp))))))"},"\n\n",{"c":1,"s":"(defun paredit-region-ok-p (start end)\n  (paredit-handle-sexp-errors\n      (progn\n        (save-restriction\n          (narrow-to-region start end)\n          ;; Can't use `check-parens' here -- it signals the wrong kind\n          ;; of errors.\n          (save-excursion\n            (goto-char (point-min))\n            (while (not (eobp))\n              (forward-sexp))))\n        t)\n    nil))"},"\n\n",{"c":1,"s":";;;; Initialization\n"},"\n(",{"c":5,"s":"paredit-define-keys","i":4595},")\n(",{"c":5,"s":"paredit-annotate-mode-with-examples","i":4597},")\n(",{"c":5,"s":"paredit-annotate-functions-with-examples","i":4599},")\n\n(",{"c":5,"s":"provide","i":4601}," ",{"c":5,"s":"'","i":4603},{"c":5,"s":"paredit","i":4605},")\n\n",{"c":1,"s":";;; Local Variables:\n"},{"c":1,"s":";;; outline-regexp: \"\\n;;;;+\"\n"},{"c":1,"s":";;; End:\n"},"\n",{"c":1,"s":";;; paredit.el ends here\n"},"\n"]}</div></body></html>